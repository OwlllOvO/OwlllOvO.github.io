<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="2021/04/12/2021-4-12/"/>
      <url>2021/04/12/2021-4-12/</url>
      
        <content type="html"><![CDATA[<h1 id="2021-4-12"><a href="#2021-4-12" class="headerlink" title="2021.4.12"></a>2021.4.12</h1><h2 id="问题引入"><a href="#问题引入" class="headerlink" title="问题引入"></a>问题引入</h2><p>给定 2 个字符串 text 和 pattern，在 text 中寻找是否存在 pattern 这个子串（连续）</p><h3 id="传统方法-•-暴力"><a href="#传统方法-•-暴力" class="headerlink" title="传统方法 • 暴力"></a>传统方法 • 暴力</h3><h4 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h4><p>从第一位开始，对两个字符串进行逐位比对， 不相等则从下一位开始逐位比对</p><h4 id="复杂度-•-O-mn"><a href="#复杂度-•-O-mn" class="headerlink" title="复杂度 • O(mn)"></a>复杂度 • O(mn)</h4><h2 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><blockquote><p>KMP 算法是一种改进的字符串匹配算法，由 D.E.Knuth，J.H.Morris 和 V.R.Pratt 提出的，因此人们称它为克努特—莫里斯—普拉特操作（简称 KMP 算法）。KMP 算法的核心是利用匹配失败后的信息，尽量减少模式串与主串的匹配次数以达到快速匹配的目的。具体实现就是通过一个 next() 函数实现，函数本身包含了模式串的局部匹配信息。</p><p>KMP 算法是三位学者在 Brute-Force 算法的基础上同时提出的模式匹配的改进算法。Brute- Force 算法在模式串中有多个字符和主串中的若干个连续字符比较都相等，但最后一个字符比较不相等时，主串的比较位置需要回退。KMP 算法在上述情况下，主串位置不需要回退，从而可以大大提高效率</p></blockquote><h3 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h3><p>不难发现，暴力的方法进行了大量的无效比对。如以下这个例子：text: “aaaaaaaaab”, pattern: “aaaab”<br>每次都对比到第 n 位才发现不相等，后移一 位后又从第一位开始比对，因此可以创造 一种算法，先对 pattern 字符串进行预处理，标记上前缀与后缀相等的长度，之后再进行比对时，当比对到不相等的位置时，由于已知前缀与后缀相等的长度，因此可以跳过这一段，比对之后的串即可。</p><p>例子中， 当比对第 1 位时，</p><table><thead><tr><th>pos</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th></tr></thead><tbody><tr><td>text</td><td>a</td><td>a</td><td>a</td><td>a</td><td>a</td><td>a</td><td>a</td><td>a</td><td>a</td><td>b</td></tr><tr><td>pattern</td><td>a</td><td>a</td><td>a</td><td>a</td><td>b</td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>前 4 位都相等，到了第 5 位时不相等，而对 pattern 串，除去不相等的第 5 位，前 4 位中的前缀与后缀的相等长度为 2（1, 2与 3, 4相等），而经过比比对，3, 4 位已经与 text 对应相等，因此可以把第 1, 2 位直接移到此位置即可，减少无效比对。</p><table><thead><tr><th>pos</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th></tr></thead><tbody><tr><td>text</td><td>a</td><td>a</td><td>a</td><td>a</td><td>a</td><td>a</td><td>a</td><td>a</td><td>a</td><td>b</td></tr><tr><td>pattern</td><td></td><td></td><td>a</td><td>a</td><td>a</td><td>a</td><td>b</td><td></td><td></td><td></td></tr></tbody></table><h3 id="做法-1"><a href="#做法-1" class="headerlink" title="做法"></a>做法</h3><ol><li><p>对 pattern 进行预处理得到 pattern 的前缀表 prefix table</p><p>逐位判断前后缀相等长度，保存在 prefix 数组</p><p>将 prefix 数组整体后移 1 位，prefix[0] = -1</p></li><li><p>KMP<br>两串相等继续；不相等则将 pattern 的指针 j 指向 pattern[j]</p></li></ol><h3 id="复杂度-•-O-m-n"><a href="#复杂度-•-O-m-n" class="headerlink" title="复杂度 • O(m + n)"></a>复杂度 • O(m + n)</h3><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define _CRTSECURE_NOWARNINGS#pragma warning(disable:4996)#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;cmath&gt;#include&lt;cctype&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;vector&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;list&gt;using namespace std;const int MAX_LEN = 10000017;int lenpattern, lentext;char pattern[MAX_LEN];char text[MAX_LEN];int prefix[MAX_LEN];void prefix_table(){prefix[0] = 0;int len = 0;int i = 1;while (i &lt; lenpattern){if (pattern[i] == pattern[len]){len++;prefix[i] = len;i++;}else{if (len &gt; 0) len = prefix[len - 1];else{prefix[i] = len;i++;}}}}void move_prefix_table(){for (int i = lenpattern - 1; i &gt; 0; i--) prefix[i] = prefix[i - 1];prefix[0] = -1;}void kmp_search(){prefix_table();move_prefix_table();int i = 0, j = 0;while (i &lt; lentext){if (j == lenpattern - 1 &amp;&amp; text[i] == pattern[j]){printf("Found pattern at %d\n", i - j);j = prefix[j];if (j == -1){i++;j++;}}else{if (text[i] == pattern[j]){i++;j++;}else{j = prefix[j];if (j == -1){i++;j++;}}}}}int main(){scanf("%s", text);scanf("%s", pattern);lentext = strlen(text);lenpattern = strlen(pattern);kmp_search();return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>text: 目标字符串</p><p>pattern: 匹配字符串</p><h3 id="101466E-•-Text-Editor"><a href="#101466E-•-Text-Editor" class="headerlink" title="101466E • Text Editor"></a><a href="https://codeforces.com/gym/101466/problem/E">101466E • Text Editor</a></h3><p>time limit per test: 1 second</p><p>memory limit per test: 512 megabytes</p><p>input: standard input</p><p>output: standard output</p><h4 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h4><p>One of the most useful tools nowadays are text editors, their use is so important that the Unique Natural Advanced Language (UNAL) organization has studied many of the benefits working with them.</p><p>They are interested specifically in the feature “find”, that option looks when a pattern occurs in a text, furthermore, it counts the number of times the pattern occurs in a text. The tool is so well designed that while writing each character of the pattern it updates the number of times that the corresponding prefix of the total pattern appears on the text.</p><p>Now the UNAL is working with the editor, finding patterns in some texts, however, they realize that many of the patterns appear just very few times in the corresponding texts, as they really want to see more number of appearances of the patterns in the texts, they put a lower bound on the minimum number of times the pattern should be found in the text and use only prefixes of the original pattern. On the other hand, the UNAL is very picky about language, so they will just use the largest non-empty prefix of the original pattern that fit into the bound.</p><h4 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h4><p>The first line contains the text <em>A</em> (1 ≤ |<em>A</em>| ≤  10<sup>5</sup>) The second line contains the original pattern <em>B</em> (1 ≤ |<em>B</em>| ≤  |<em>A</em>|) The third line contains an integer <em>n</em> (1 ≤ <em>n</em> ≤  |<em>A</em>|) - the minimum number of times a pattern should be found on the text.</p><h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><p>A single line, with the prefix of the original pattern used by the UNAL, if there is no such prefix then print “IMPOSSIBLE” (without the quotes)</p><h4 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h4><h5 id="Input-1"><a href="#Input-1" class="headerlink" title="Input 1"></a>Input 1</h5><pre class="line-numbers language-none"><code class="language-none">aaaaaaaa4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h5 id="Output-1"><a href="#Output-1" class="headerlink" title="Output 1"></a>Output 1</h5><pre class="line-numbers language-none"><code class="language-none">aa<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="Input-2"><a href="#Input-2" class="headerlink" title="Input 2"></a>Input 2</h5><pre class="line-numbers language-none"><code class="language-none">programmingunal1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h5 id="Output-2"><a href="#Output-2" class="headerlink" title="Output 2"></a>Output 2</h5><pre class="line-numbers language-none"><code class="language-none">IMPOSSIBLE<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="Input-3"><a href="#Input-3" class="headerlink" title="Input 3"></a>Input 3</h5><pre class="line-numbers language-none"><code class="language-none">abracadabraabra1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h5 id="Output-3"><a href="#Output-3" class="headerlink" title="Output 3"></a>Output 3</h5><pre class="line-numbers language-none"><code class="language-none">abra<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="Input-4"><a href="#Input-4" class="headerlink" title="Input 4"></a>Input 4</h5><pre class="line-numbers language-none"><code class="language-none">Hello World!H W5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h5 id="Output-4"><a href="#Output-4" class="headerlink" title="Output 4"></a>Output 4</h5><pre class="line-numbers language-none"><code class="language-none">IMPOSSIBLE<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><p>把 B 字符串对 A 字符串进行 KMP。</p><p>但是如果单纯的从长到短 KMP 的话复杂度为 O(n<sup>2</sup>)，因此要对长度进行二分。</p><h4 id="Accepted-Code"><a href="#Accepted-Code" class="headerlink" title="Accepted Code"></a>Accepted Code</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define _CRTSECURE_NOWARNINGS#pragma warning(disable:4996)#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;cmath&gt;#include&lt;cctype&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;vector&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;list&gt;using namespace std;const int MAX_LEN = 10000017;int n;int lenpattern, lentext;char pattern[MAX_LEN];char text[MAX_LEN];int prefix[MAX_LEN];void prefix_table(){prefix[0] = 0;int len = 0;int i = 1;while (i &lt; lenpattern){if (pattern[i] == pattern[len]){len++;prefix[i] = len;i++;}else{if (len &gt; 0) len = prefix[len - 1];else{prefix[i] = len;i++;}}}}void move_prefix_table(){for (int i = lenpattern; i &gt; 0; i--) prefix[i] = prefix[i - 1];prefix[0] = -1;}int kmp_search(int x){int cnt = 0;int i = 0, j = 0;while (i &lt; lentext){if (j == x - 1 &amp;&amp; text[i] == pattern[j]){cnt++;j = prefix[j];if (j == -1){i++;j++;}}else{if (text[i] == pattern[j]){i++;j++;}else{j = prefix[j];if (j == -1){i++;j++;}}}}return cnt;}int main(){freopen("in.txt", "r", stdin);gets_s(text);gets_s(pattern);scanf("%d", &amp;n);lenpattern = strlen(pattern);lentext = strlen(text);prefix_table();move_prefix_table();int l = 0, r = lenpattern, mid, ans = 0;while (l &lt;= r){int mid = (l + r) / 2;if (kmp_search(mid) &gt;= n){ans = mid;l = mid + 1;}else r = mid - 1;}if (ans){for (int i = 0; i &lt; ans; i++) printf("%c", pattern[i]);}else printf("IMPOSSIBLE");        return 0;    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Qualified for ZJPSC 2021</title>
      <link href="2021/04/02/qualified-for-zjpsc-2021/"/>
      <url>2021/04/02/qualified-for-zjpsc-2021/</url>
      
        <content type="html"><![CDATA[<h1 id="Qualified-for-ZJPSC-2021"><a href="#Qualified-for-ZJPSC-2021" class="headerlink" title="Qualified for ZJPSC 2021"></a>Qualified for ZJPSC 2021</h1><p>2021.3.31，我们实验室举行了2021年浙江省赛的选拔赛，我们学校总共有8支队伍的名额。虽然最终我们 Accepted-Graph 队获得了省赛的资格，但是一路可谓是跌宕起伏，幸好最后是有惊无险</p><h2 id="The-Qualification-Trial"><a href="#The-Qualification-Trial" class="headerlink" title="The Qualification Trial"></a>The Qualification Trial</h2><p>这次比赛学长说题目很简单，但是由于我们的的能力问题，总共只 AC 了四道题：A, H, I, J. 其中 A, H, J 是签到题……</p><h3 id="A-•-Array-Permutation"><a href="#A-•-Array-Permutation" class="headerlink" title="A • Array Permutation"></a>A • Array Permutation</h3><h4 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h4><blockquote><p>Little H is so boring that he wants to generate an array of length n.</p><p>Little H uses the following method to generate the array.</p><ul><li>Suppose the current array length is m(m &lt; n). Then he will randomly generate a number x from [1, n − m]. Then he will follow the ordered permutation of [1, x](such as x = 3, the ordered permutation is [1, 2, 3]) after the array.</li><li>If the length of the array after the append operation is completed is n，then finish the entire process, otherwise repeat the above steps.</li></ul><p>Now little H want to know how many different arrays there are for a certain n。</p><p>Due to the limited ability of counting little H, you just need to output the answer modulo 10<sup>9</sup> + 7.</p></blockquote><h4 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h4><blockquote><p>There are several test cases.</p><p>The first line contains a single integer T(1 ≤ T ≤ 10<sup>3</sup>), denoting the number of test cases. Then follow all the test cases.</p><p>For each test case, only one line which contains a single integer n(1 ≤ n ≤ 10<sup>6</sup>), denoting the length of the array little H wants to generate.</p></blockquote><h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><blockquote><p>For each test case, print a integer in one line which denoting the answer.</p></blockquote><h4 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h4><pre class="line-numbers language-none"><code class="language-none">311001000000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h4><pre class="line-numbers language-none"><code class="language-none">1988185646617521033<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><p>理解题意，我们要按照规则生成一个长度为 n 的数列：已生成数列长度为 m，在 [1, n - m] 之间随机取一个数字 x，然后将 x 长度的数列添加到已生成的数列中，问有多少种可能性。</p><p>从长度为 1 开始找规律</p><p>n = 1 时，只有一种可能性</p><p>n = 2 时，第一次生成的 x 可能为 1 or 2</p><p>​    若 x = 1，则剩余长度为 1，只有 1 种可能性</p><p>​    若 x = 2，则剩余长度为 0，此时为 1 种可能性</p><p>​    因此 n = 2 时有两种可能性</p><p>n = 3 时，第一次生成的 x 可能为 1, 2 or 3</p><p>​    若 x = 1，则剩余长度为 2，根据之前推到结果，有 2 种可能性</p><p>​    若 x = 2，则剩余长度为 1，根据之前推到结果，有 1 种可能性</p><p>​    若 x = 3，则剩余长度为 0，此时为 1 种可能性</p><p>​    因此 n = 3 时有 4 种可能性</p><p>……</p><p>易得，答案为 2<sup>n-1</sup>.</p><p>只需按快速幂的方法，求出 2<sup>n-1</sup> % (10<sup>9</sup> + 7) 即可</p><h4 id="Accepted-Code"><a href="#Accepted-Code" class="headerlink" title="Accepted Code"></a>Accepted Code</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define _CRTSECURE_NOWARNINGS#pragma warning(disable:4996)#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;cmath&gt;#include&lt;cctype&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;vector&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;list&gt;using namespace std;const int mod = 1e9 + 7;int t, n;long long qpow(int x){if (!x) return 1;else if (x &amp; 1) return (qpow(x - 1) &lt;&lt; 1) % mod;else{long long temp = (qpow(x &gt;&gt; 1)) % mod;return temp * temp % mod;}}int main(){scanf("%d", &amp;t);while (t--){scanf("%d", &amp;n);printf("%lld\n", qpow(n - 1));}return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="H-•-Hsueh-And-Treasure"><a href="#H-•-Hsueh-And-Treasure" class="headerlink" title="H • Hsueh- And Treasure"></a>H • Hsueh- And Treasure</h3><h4 id="Description-1"><a href="#Description-1" class="headerlink" title="Description"></a>Description</h4><blockquote><p>Hsueh- Dreaming one night, dreaming that he was in a vast ocean.</p><p>In a faraway place, there is an island. It is said that there are some precious treasures on it. There are treasures left by the King of Sailing Kwords to give to the world.</p><p>So Hsueh- wants to find the treasure left by Kwords。</p><p>We assume that the sea is a two-dimensional plane, Hsueh- is currently at (0, 0), and the location of the treasure is at (x, y).</p><p>Next, due to the influence of the cosmic background radiation wave, Hsueh- can only take exactly i steps at the i-th moment, and each step can only walk one square in four directions, up, down, left, and right. The initial moment is 0.</p><p>Hsueh- is too anxious to find the last treasure, so he asks you, can you help him plan the shortest route to the destination (x, y). And please output this route.</p><p>Note that there may be multiple routes, and you can output any route.</p></blockquote><h4 id="Input-1"><a href="#Input-1" class="headerlink" title="Input"></a>Input</h4><blockquote><p>The first line contains a single integer T(1 ≤ T ≤ 10), denoting the number of test cases.</p><p>For next T lines, each line contains two integers x, y(|x|,|y| ≤ 10<sup>9</sup>), representing the location of the treasure.</p></blockquote><h4 id="Output-1"><a href="#Output-1" class="headerlink" title="Output"></a>Output</h4><blockquote><p>For each test case,the output format must meet the following requirements.</p><p>The first line you need to print “Case #i:”(without quotation marks), representing the current number of test cases.</p><p>The second line you need to print a single integer t, which indicates the final moment at which it can reach (xi, yi).</p><p>Next t lines, each line contains two integers separated by a space, denoting the location of the j-th moment.</p></blockquote><h4 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input"></a>Sample Input</h4><pre class="line-numbers language-none"><code class="language-none">21 02 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output"></a>Sample Output</h4><pre class="line-numbers language-none"><code class="language-none">Case #1:11 0Case #2:31 01 22 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h4><p>比赛时审了好几次题，每次审题都有新发现（英语差是原罪</p><p>第一次审题，把题目审难了：没看到 <code>each step can only walk one square in four directions</code>，以为是第 i 次可以走 i 步，但是这 i 步都是要朝同一方向，那就还得考虑越后面能走得越多，会产生朝一个方向的浪费的问题了</p><p>第二次审题，把题目审简单了：没看到 <code>exactly i steps at the i-th moment</code>，以为是第 i 次可以走 i 步，每一步任意方向，只要走到就可以了。那很简单啊，先按左右方向，然后上下方向走完就可以了。甚至还自信地 Submit 了三次，都直接 WA 在了 test1，这才意识到一定是题目读错了，重新审了一次题</p><p>（这里必须 diss 江宇杰，写完代码只测样例就敢 Submit，都不自己造数据测试、、连负数都没考虑到！）</p><p>第三次审题，终于读对题目了，第 i 次一定要走完 i 步。因此，前期还是跟上一次的想法一样，先左右走，走到了以后再向上下走。如果已经到了目的地就左右横跳。如果剩余步数为奇数就走到相邻的一格，如果是偶数就在原地。</p><p>第三次审题，终于读对题目了，第 i 次一定要走完 i 步。因此，前期还是跟上一次的想法一样，先左右走，走到了以后再向上下走</p><h4 id="Accepted-Code-1"><a href="#Accepted-Code-1" class="headerlink" title="Accepted Code"></a>Accepted Code</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define _CRTSECURE_NOWARNINGS#pragma warning(disable:4996)#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;cmath&gt;#include&lt;cctype&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;vector&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;list&gt;using namespace std;int T;long long sx, sy;//当前的坐标long long fx, fy;//目的地坐标int negx = 1, negy = 1;//用于标记目的地的方向是正方向还是负方向bool flag, FLAG;//flag:是否到达过目的地; FLAG:是否恰好到达了目的地int res;//每一次剩余的步数int px[100015], py[100015], cnt;bool arrive(){if (sx == fx &amp;&amp; sy == fy) return 1;return 0;}int LeftRight(int x){if (x &lt; fx - sx){sx += x;x = 0;}else{x -= fx - sx;sx = fx;}return x;}int UpDown(int y){if (y &lt; fy - sy){sy += y;y = 0;}else{y -= fy - sy;sy = fy;}return y;}void init(){negx = fx &gt; 0 ? 1 : -1;negy = fy &gt; 0 ? 1 : -1;fx = abs(fx);fy = abs(fy);sx = 0;sy = 0;flag = 0;FLAG = 0;    memset (px, 0, sizeof (px));    memset (py, 0, sizeof (py));return;}int main(){scanf("%d", &amp;T);for (int t = 1; t &lt;= T; t++){scanf("%lld%lld", &amp;fx, &amp;fy);printf("Case #%d:\n", t);if (!fx &amp;&amp; !fy)//如果目的地为原点，应该输出共 0 步，并且输出 0 行坐标{printf("0\n");continue;}init();for (cnt = 1; !FLAG; cnt++){res = cnt;if (!flag){res = LeftRight(res);res = UpDown(res);if (arrive()) flag = 1;}if (flag){if (res % 2){if (arrive()) sx++;else sx--;}res = 0;if (arrive()) FLAG = 1;}px[cnt] = sx * negx;py[cnt] = sy * negy;}cnt--;printf("%d\n", cnt);for (int i = 1; i &lt;= cnt; i++) printf("%d %d\n", px[i], py[i]);}return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="I-•-Iaom-and-Chicken-feet"><a href="#I-•-Iaom-and-Chicken-feet" class="headerlink" title="I • Iaom and Chicken feet"></a>I • Iaom and Chicken feet</h3><h4 id="Description-2"><a href="#Description-2" class="headerlink" title="Description"></a>Description</h4><blockquote><p>Baom likes chicken very much.</p><p>One day ,while he was thinking a problem on tree he found it looks like chicken’s feet.</p><p><img src="https://cdn.jsdelivr.net/gh/OwlllOvO/Hexo-image/20210402224246.png"></p><p>He fall into thinking,how much chicken feet are there on the tree.</p><p>The “chicken feet” is a subgraph of given tree which shapes like the picture above</p><p>Baom wonder the number of “chicken feet” all over the tree.Two “feet”s are consider the same iff the set of edges of “chicken feet”s are the same.</p></blockquote><h4 id="Input-2"><a href="#Input-2" class="headerlink" title="Input"></a>Input</h4><blockquote><p>The first line contains one integer n(1 ≤ n ≤ 5 ⋅ 10<sup>5</sup>) —The number of nodes each of next n − 1 line contains a description of an edge: two integers u and v(1 ≤ u, v ≤ n, u ≠ v) The given edges form a tree.</p></blockquote><h4 id="Output-2"><a href="#Output-2" class="headerlink" title="Output"></a>Output</h4><blockquote><p>Print a single integer — the number of “chicken feet” modulo 998244353.</p></blockquote><h4 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input"></a>Sample Input</h4><pre class="line-numbers language-none"><code class="language-none">71 22 32 45 46 47 4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output"></a>Sample Output</h4><pre class="line-numbers language-none"><code class="language-none">1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h4><p>将 4 号点提起，枚举 2 号点，令 sz[x] 表示与点 x 相连的点的个数，答案为 C<sup>3</sup><sub>sz[4]−1</sub> · C<sup>2</sup><sub>sz[2]−1</sub> 之和</p><p>（这里再次 diss 江宇杰，莫名其妙喜欢用 cin/cout，导致 TLE… scanf/printf 它不香吗？？？</p><h4 id="Accepted-Code-2"><a href="#Accepted-Code-2" class="headerlink" title="Accepted Code"></a>Accepted Code</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define _CRTSECURE_NOWARNINGS#pragma warning(disable:4996)#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;cmath&gt;#include&lt;cctype&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;vector&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;list&gt;using namespace std;const int maxn = 5e5 + 10;const int mod = 998244353;int t;int u, v;long long sum = 0;long long num[maxn];vector&lt;int&gt; q[maxn];int main(){scanf("%d", &amp;t);for (int i = 1; i &lt;= t - 1; i++)//建立边{scanf("%d%d", &amp;u, &amp;v);q[u].push_back(v);q[v].push_back(u);num[u]++;num[v]++;}for (int i = 1; i &lt;= t; i++){if (num[i] &gt;= 3){for (int j = 0; j &lt; num[i]; j++){if (num[q[i][j]] &gt;= 4){sum += (((num[i] - 1) * (num[i] - 2)) &gt;&gt; 1) * ((num[q[i][j]] - 1) * (num[q[i][j]] - 2) * (num[q[i][j]] - 3) / 6) % mod;sum %= mod;}}}}printf("%lld\n", sum);return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="J-•-Jew-Sorting"><a href="#J-•-Jew-Sorting" class="headerlink" title="J • Jew Sorting"></a>J • Jew Sorting</h3><h4 id="Description-3"><a href="#Description-3" class="headerlink" title="Description"></a>Description</h4><blockquote><p>Hello, guys, I am the King of boredom.</p><p>I have a array of length 2<sup>k</sup>(0 ≤ k ≤ 20). You can delete the first half or the second half of each operation.</p><p>So, you need to tell me the minimum number of operations required can make this sequence non-decreasing.</p></blockquote><h4 id="Input-3"><a href="#Input-3" class="headerlink" title="Input"></a>Input</h4><blockquote><p>The first line contains a single integer k(0 ≤ k ≤ 20), denoting the length of the array is 2<sup>k</sup>.</p><p>The second line contains 2<sup>k</sup> integers, the ii-th integer is ai(1 ≤ ai ≤ 10<sup>9</sup>) representing the array.</p></blockquote><h4 id="Output-3"><a href="#Output-3" class="headerlink" title="Output"></a>Output</h4><blockquote><p>Print a single integer, denoting the answer.</p></blockquote><h4 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input 1"></a>Sample Input 1</h4><pre class="line-numbers language-none"><code class="language-none">21 3 2 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="Sample-Output1"><a href="#Sample-Output1" class="headerlink" title="Sample Output1"></a>Sample Output1</h4><pre class="line-numbers language-none"><code class="language-none">1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input 2"></a>Sample Input 2</h4><pre class="line-numbers language-none"><code class="language-none">21 2 3 4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output 2"></a>Sample Output 2</h4><pre class="line-numbers language-none"><code class="language-none">0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h4><p>按照题目模拟</p><h4 id="Accepted-Code-3"><a href="#Accepted-Code-3" class="headerlink" title="Accepted Code"></a>Accepted Code</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define _CRTSECURE_NOWARNINGS#pragma warning(disable:4996)#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;cmath&gt;#include&lt;cctype&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;vector&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;list&gt;using namespace std;int k, start = 1, num = 1, minans = INT_MAX, times;int a[2000006];int head[2000006];long long maxnum;void init(int x, int n, int halfsize){if (n != k + 1){head[x] = n;init(x + halfsize / 2, n + 1, halfsize / 2);init(x - halfsize / 2, n + 1, halfsize / 2);}}int main(){scanf("%d", &amp;k);maxnum = pow(2, k);init(1 + maxnum / 2, 1, maxnum / 2);scanf("%d", &amp;a[1]);for (int i = 2; i &lt;= maxnum; i++){scanf("%d", &amp;a[i]);if (a[i] &gt;= a[i - 1] &amp;&amp; i != maxnum) num += 1;else{times = 0;int temp = maxnum;if (i == maxnum &amp;&amp; a[i] &gt;= a[i - 1]) num++;while (num &lt; temp){temp /= 2;times++;}times = max(times, head[start]);if (times &lt; minans) minans = times;start = i;num = 1;}}printf("%d\n", minans);return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="After-Trial"><a href="#After-Trial" class="headerlink" title="After Trial"></a>After Trial</h2><p>这段的故事就比较跌宕起伏了……</p><p>首先是在比赛中我们队伍排名第十</p><p>但是有三个队伍是打星队伍，不参加排名，所以我们又排名第 7.</p><p>然而，有两个队伍是不用参加选拔赛的，我们又排名第 9 了 :)</p><p>就在今天，队长又突然通知我，有一个队伍放弃参赛，于是名额就轮到我们了，听到这个消息那是真的激动啊！</p><p>作为唯一一支大一的队伍参赛，既是兴奋，又有忐忑……</p><p>清明节也留校参加实验室的训练了，这几天一定要认真训练，巩固基础知识，多学习算法，再刷点往年的省赛题目，争取在省赛中取得好的名次（虽然只是第一次参赛）</p><h1 id="End"><a href="#End" class="headerlink" title="End"></a>End</h1><p>特别鸣谢：江宇杰、王梓仰</p>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ZJPSC 2021 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ETH</title>
      <link href="2021/03/20/eth/"/>
      <url>2021/03/20/eth/</url>
      
        <content type="html"><![CDATA[<h1 id="ETH"><a href="#ETH" class="headerlink" title="ETH"></a>ETH</h1><h2 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h2><h3 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h3><p>很早就看到网络虚拟货币的消息，近两年突然又火了起来，各种虚拟货币币值直线上升。我对此一直抱着怀疑的态度，毕竟它没有任何的实际作用，也就没有尝试自己挖矿，一直都觉得挖矿离自己很遥远，都是矿主们在大规模地挖矿。直到昨天，看到了关注的 UP 主 <a href="https://space.bilibili.com/4401694?spm_id_from=333.788.b_765f7570696e666f.2"><strong>林亦LYi</strong></a> 发布了自己尝试挖矿的视频 <a href="https://www.bilibili.com/video/BV1nN411X7wB">唠唠GPU挖矿的暴富密码：你知道显卡都去哪了吗？</a>，才想起来自己电脑就是 RTX2070，算力也还算挺高，为什么不在闲置的时候也顺便挖一挖矿，还能赚一点钱呢？于是我开始了尝试挖矿。</p><h2 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h2><h3 id="创建钱包"><a href="#创建钱包" class="headerlink" title="创建钱包"></a>创建钱包</h3><p>进入网站 <a href="https://metamask.io/">METAMASK</a>，点击 <code>Download</code>，推荐选择 Chrome 插件，比 iOS / Android 手机端更加方便。浏览器选择 Chrome (需科学上网) 或者 Edge 皆可。插件安装成功后，按照提示注册账号 <strong>！保存好密码、密钥信息！</strong> 然后就可以在插件里获取自己钱包的地址信息。</p><h3 id="挖矿平台"><a href="#挖矿平台" class="headerlink" title="挖矿平台"></a>挖矿平台</h3><p>进入网站 <a href="https://ethermine.org/">ETHERMINE</a>，点击右上角 <code>Start Mining</code>，这里可以看到挖矿相关的数据。然后向下拉选择自己的平台。比如我是 Windows 系统，NVIDIA RTX 2070 的显卡，就选择 Windows - NVIDIA。可以看到第一项是 <code>T-Rex</code>。这时不用在这里打开，转到 <a href="https://github.com/">Github</a>，搜索 <code>T-Rex</code>，点击 <a href="https://github.com/trexminer/T-Rex">trexminer/T-Rex</a> ，右边 <code>Releases</code> 中下载最新版的 zip，解压缩。</p><p>新建文件，重命名为 <code>start.bat</code>，编辑这个文件。可以在 Github 的说明中找到挖矿的命令为</p><pre class="line-numbers language-none"><code class="language-none">t-rex -a ethash -o stratum+tcp://eu1.ethermine.org:4444 -u 0x1f75eccd8fbddf057495b96669ac15f8e296c2cd -p x -w rig0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>。将这一行命令粘贴到文件中，然后根据 <a href="https://ethermine.org/start">Start Mining</a> 的数据进行如下编辑：</p><ul><li>将模式 <code>tcp</code> 修改为 <code>ssl</code></li><li>将地区 <code>eu</code> 欧洲修改为 <code>asia</code> 亚洲</li><li>将 SSL Port <code>4444</code> 修改为 <code>5555</code></li><li><strong>将作者钱包地址 <code>0x1f75eccd8fbddf057495b96669ac15f8e296c2cd</code> 修改为自己的钱包地址（METAMASK 插件中查看）</strong><ul><li>一定要记得改，否则挖矿成果都进了别人的钱包！</li></ul></li><li>将机器名 <code>rig0</code> 修改为自己喜欢的名字</li></ul><p>我的修改结果：</p><pre class="line-numbers language-none"><code class="language-none">t-rex -a ethash -o stratum+ssl://asia1.ethermine.org:5555 -u 0xDD96344e7AaA420Db97c67168E70b841C49a466D -p x -w OwlllOvO1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="开始挖矿"><a href="#开始挖矿" class="headerlink" title="开始挖矿"></a>开始挖矿</h3><p>双击 <code>start.bat</code> 即可开始挖矿。</p><p>此时打开 <a href="https://ethermine.org/">ETHERMINE</a>，中间的输入框中输入自己的钱包地址，即可进入自己的控制面板（Dashboard），查看挖矿的相关信息：已获得的 ETH 数量（金额）、预计 ETH 获得数量（金额）（每 日/周/月）、当前算力 等。</p><p><img src="https://cdn.jsdelivr.net/gh/OwlllOvO/Hexo-image/20210320220855.png" alt="Dashboard"></p><p>然后点击 <code>Settings</code> 填写自己的邮箱地址、最低提现额（建议0.1）、IP地址（可以用 <a href="https://www.whatismyip.org/">What Is My IP</a> 查询），点击 <code>Submit</code> 保存。</p><h3 id="优化效率"><a href="#优化效率" class="headerlink" title="优化效率"></a>优化效率</h3><p>下载软件 <a href="https://cn.msi.com/Landing/afterburner/">msi AfterBurner</a> <strong>此软件用于超频，可能会对显卡造成损害，谨慎使用</strong></p><p>安装打开后点击齿轮图标，勾选 <code>解锁电压调整控制</code> 和 <code>解锁电压监控制</code>，重启软件后， 进行如下调节：</p><ul><li><code>Power Limit</code> 拉到最低</li><li><code>Temp. Limit</code> 拉到最低</li><li><code>Core Clock</code> 拉到最低</li><li><code>Memory Clock</code> 调至 700 ~ 1300<ul><li>调的越高效率越高</li><li>此项操作有风险，害怕显卡烧坏就少调一点或者保持为 0</li></ul></li><li><code>Fan Speed</code> 保持自动或者手动调低以降低噪声<ul><li>尽量不要手动拉低，否则显卡容易过热</li></ul></li></ul><h3 id="停止挖矿"><a href="#停止挖矿" class="headerlink" title="停止挖矿"></a>停止挖矿</h3><p>将 <code>start.bat</code> 关闭即可</p>]]></content>
      
      
      
        <tags>
            
            <tag> ETH </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021.2.21</title>
      <link href="2021/02/21/2021-2-21/"/>
      <url>2021/02/21/2021-2-21/</url>
      
        <content type="html"><![CDATA[<h1 id="2021-2-21"><a href="#2021-2-21" class="headerlink" title="2021.2.21"></a>2021.2.21</h1><h2 id="计算几何"><a href="#计算几何" class="headerlink" title="计算几何"></a>计算几何</h2><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><h4 id="高精度圆周率"><a href="#高精度圆周率" class="headerlink" title="高精度圆周率"></a>高精度圆周率</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">const double pi = acos(-1.0);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="偏差值"><a href="#偏差值" class="headerlink" title="偏差值"></a>偏差值</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">const double eps = 1e-8;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="sgn"><a href="#sgn" class="headerlink" title="sgn"></a>sgn</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int sgn(double x)// 判断x是否等于0{if (fabs(x) &lt; eps) return 0;else return x &lt; 0 ? -1 : 1;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="dcmp"><a href="#dcmp" class="headerlink" title="dcmp"></a>dcmp</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int dcmp(double x, double y)// 比较两个浮点数，0为相等，-1为小于，1为大于{if (fabs(x - y) &lt; eps) return 0;else return x &lt; y ? -1 : 1;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="点和向量"><a href="#点和向量" class="headerlink" title="点和向量"></a>点和向量</h3><h4 id="点"><a href="#点" class="headerlink" title="点"></a>点</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">struct Point{double x, y;Point() {}Point(double x, double y) : x(x), y(y) {}};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="两点间距离"><a href="#两点间距离" class="headerlink" title="两点间距离"></a>两点间距离</h4><ol><li><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">double Dist(Point A, Point B){return hypot(A.x - B.x, A.y - B.y);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">double Dist(Point A, Point B){return sqrt((A.x - B.x) * (A.x - B.x) + (A.y - B.y) * (A.y - B.y));}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h4 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">typedef Point Vector;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="向量的运算"><a href="#向量的运算" class="headerlink" title="向量的运算"></a>向量的运算</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">struct Point{double x, y;Point() {}Point(double x, double y) : x(x), y(y) {}Point operator+(Point B) { return Point(x + B.x, y + B.y); }// 加Point operator-(Point B) { return Point(x - B.x, y - B.y); }// 减Point operator*(double k) { return Point(x * k, y * k); }// 乘Point operator/(double k) { return Point(x / k, y / k); }// 除bool operator==(Point B) { return sgn(x - B.x) == 0 &amp;&amp; sgn(y - B.y) == 0; }// 等于};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="点积"><a href="#点积" class="headerlink" title="点积"></a>点积</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p><code>A • B = |A||B|cosθ</code></p><h4 id="几何定义"><a href="#几何定义" class="headerlink" title="几何定义"></a>几何定义</h4><p>θ: 表示向量 b 与向量 a 的夹角</p><p>向量 b 在向量 a 上的投影长度乘以向量 a 的模长</p><h4 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h4><p><code>A • B = A.x * B.x + A.y * B.y</code></p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">double Dot(Vector A, Vector B){return A.x * B.x + A.y * B.y;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><ol><li><p>判断向量 A 与向量 B 的夹角是钝角还是锐角</p><ul><li>若 Dot(A, B) &gt; 0: 向量 A 与向量 B 的夹角为锐角</li><li>若 Dot(A, B) &lt; 0: 向量 A 与向量 B 的夹角为顿角</li><li>若 Dot(A, B) = 0: 向量 A 与向量 B 的夹角为直角</li></ul></li><li><p>求向量 A 的模长</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">double Len(Vector A){return sqrt(Dot(A, A));}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>求向量 A 与向量 B 的夹角大小</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">double Angle(Vector A, Vector B){return acos(Dot(A, B) / Len(A) / Len(B));}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="叉积"><a href="#叉积" class="headerlink" title="叉积"></a>叉积</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p><code>A × B = |A||B|sinθ</code></p><h4 id="几何意义"><a href="#几何意义" class="headerlink" title="几何意义"></a>几何意义</h4><p>θ: 向量 A 旋转到向量 B 所经过的夹角</p><p>|A × B| 在数值上等于由向量和向量构成的平行四边形的面积</p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">double Cross(Vector A, Vector B){return A.x * B.y - A.y * B.x;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h4><ol><li><p>判断向量与向量的方向关系</p><ul><li>若 A × B &gt; 0，B 在 A 的逆时针方向</li><li>若 A × B &lt; 0，B 在 A 的顺时针方向</li><li>若 A × B = 0，B 与 A 共线，可能是同方向，也可能是反方向</li></ul></li><li><p>计算两向量构成的平行四边形的有向面积</p><p>3 个点 A, B, C 以 A 为公共点，得到两个向量 B - A, C - A 它们构成的平行四边形的面积如下</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">double Area2(Point A, Point B, Point C){return Cross(B - A, C - A);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>同理 Area2(A, B, C) / 2 就是计算以 A, B, C 三点构成三角形的面积</p></li><li><p>向量旋转</p><p>向量 A 逆时针旋转的角度为 rad</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">Vector Rotate(Vector A, double rad){return Vector(A.x * cos(rad) - A.y * sin(rad), A.x * sin(rad) + A.y * cos(rad));}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>有时需要求单位法向量，即逆时针旋转 90°，然后取单位值</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">Vector Normal(Vector A){return Vector(-A.y / Len(A), A.x / Len(A));}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>用叉积检查两个向量是否平行或重合</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">bool Parallel(Vector A, Vector B){return sgn(Cross(A, B)) == 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="点和线"><a href="#点和线" class="headerlink" title="点和线"></a>点和线</h3><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">struct Line// 直线{Point p1, p2;// 线上的两个点Line() {}// 直接用两个点来构造直线Line(Point p1, Point p2) : p1(p1), p2(p2) {}// 根据一个点和倾斜角angle确定直线，0≤angle≤piLine(Point p, double angle){p1 = p;if (sgn(angle - pi / 2) == 0)p2 = (p1 + Point(0, 1));elsep2 = (p1 + Point(1, tan(angle)));}// ax + by + c = 0Line(double a, double b, double c){if (sgn(a) == 0){p1 = Point(0, -c / b);p2 = Point(1, -c / b);}else if (sgn(b) == 0){p1 = Point(-c / a, 0);p2 = Point(-c / a, 1);}else{p1 = Point(0, -c / b);p2 = Point(1, (-c - a) / b);}}};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="线段的表示"><a href="#线段的表示" class="headerlink" title="线段的表示"></a>线段的表示</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">typedef Line Segment;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="点和直线的位置关系"><a href="#点和直线的位置关系" class="headerlink" title="点和直线的位置关系"></a>点和直线的位置关系</h4><p>用直线 v 上的两点 p1 和 p2 与点 p 构成两个向量，用叉积的正负判断方向，得到相对的位置关系点</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int Point_line_relation(Point p, Line v){int c = sgn(Cross(p - v.p1, v.p2 - v.p1));if (c &lt; 0) // 1：p在v的左边return 1;if (c &gt; 0) // 2：p在v的右边return 2;return 0; // 0：p在v上}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="点和线段的位置关系"><a href="#点和线段的位置关系" class="headerlink" title="点和线段的位置关系"></a>点和线段的位置关系</h4><p>判断点 p 是否在线段 v 上，先用叉积判断是否共线，然后用点积看 p 和 v 的两个端点产生的角是否为钝角</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">bool Point_on_seg(Point p, Line v)// 0为点不在线段v上；1为点在线段v上{return sgn(Cross(p - v.p1, v.p2 - v.p1)) == 0 &amp;&amp; sgn(Dot(p - v.p1, p - v.p2)) &lt;= 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="点到直线的距离"><a href="#点到直线的距离" class="headerlink" title="点到直线的距离"></a>点到直线的距离</h4><p>已知点 p 和直线 v(p1, p2)，求 p 到 v 的距离。首先用叉积求 p, p1, p2 构成的平行四边形的面积，然后用面积除以平行四边形的底边长，也就是线段 (p1, p2) 的长度，就得到了平行四边形的高，即点 p 到直线 v 的距离</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">double Dis_point_line(Point p, Line v){return fabs(Cross(p - v.p1, v.p2 - v.p1)) / Dist(v.p1, v.p2);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="点在直线上的投影"><a href="#点在直线上的投影" class="headerlink" title="点在直线上的投影"></a>点在直线上的投影</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">Point Point_line_proj(Point p, Line v)// 点p在直线v上的投影{double k = Dot(v.p2 - v.p1, p - v.p1) / Len2(v.p2 - v.p1);return v.p1 + (v.p2 - v.p1) * k;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="点关于直线的对称点"><a href="#点关于直线的对称点" class="headerlink" title="点关于直线的对称点"></a>点关于直线的对称点</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">Point Point_line_symmetry(Point p, Line v)// 点p关于直线v的对称点{Point q = Point_line_proj(p, v);return Point(2 * q.x - p.x, 2 * q.y - p.y);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="点到线段的距离"><a href="#点到线段的距离" class="headerlink" title="点到线段的距离"></a>点到线段的距离</h4><p>对于点 p 到线段 v(p1, p2) 的距离，在以下 3 个距离中取最小值：从 p 出发对线段 v 做垂线，如果交点在 v 上，这个距离就是最小值；p 到 p1 的距离，p 到 p2 的距离</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">double Dis_point_seg(Point p, Segment v){if (sgn(Dot(p - v.p1, v.p2 - v.p1)) &lt; 0 || sgn(Dot(p - v.p2, v.p1 - v.p2)) &lt; 0)return min(Dist(p, v.p1), Dist(p, v.p2));return Dis_point_line(p, v);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="两条直线的位置关系"><a href="#两条直线的位置关系" class="headerlink" title="两条直线的位置关系"></a>两条直线的位置关系</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int Line_relation(Line v1, Line v2){if (sgn(Cross(v1.p2 - v1.p1, v2.p2 - v2.p1)) == 0){if (Point_line_relation(v1.p1, v2) == 0)return 1; // 1：重合elsereturn 0; // 0：平行}return 2; // 2：相交}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="求两条直线的交点"><a href="#求两条直线的交点" class="headerlink" title="求两条直线的交点"></a>求两条直线的交点</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">Point Cross_point(Point a, Point b, Point c, Point d)// Line: ab, Line: cd{double s1 = Cross(b - a, c - a);double s2 = Cross(b - a, d - a);return Point(c.x * s2 - d.x * s1, c.y * s2 - d.y * s1) / (s2 - s1);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="判断两个线段是否规范相交"><a href="#判断两个线段是否规范相交" class="headerlink" title="判断两个线段是否规范相交"></a>判断两个线段是否规范相交</h4><p>这里利用叉积有正负的特点。如果一条线段的两端在另一条线段的两侧，那么两个端点与另一线段产生的两个叉积的正负相反，也就是说两个叉积相乘为负。如果两条线段互相满足这一点，那么就是规范相交的。</p><p>规范相交：交点在线段内部</p><p>非规范相交：交点在某条线段的端点</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">bool Cross_segment(Point a, Point b, Point c, Point d){// 规范相交double c1 = Cross(b - a, c - a), c2 = Cross(b - a, d - a);double d1 = Cross(d - c, a - c), d2 = Cross(d - c, b - c);return sgn(c1) * sgn(c2) &lt; 0 &amp;&amp; sgn(d1) * sgn(d2) &lt; 0; // 1: 相交，0: 不相交// 非规范相交return max(a.x, b.x) &gt;= min(c.x, d.x) &amp;&amp; max(c.x, d.x) &gt;= min(a.x, b.x) &amp;&amp; max(a.y, b.y) &gt;= min(c.y, d.y) &amp;&amp; max(c.y, d.y) &gt;= min(a.y, b.y) &amp;&amp; sgn(Cross(b - a, c - a)) * sgn(Cross(b - a, d - a)) &lt;= 0 &amp;&amp; sgn(Cross(d - c, a - c)) * sgn(Cross(d - c, b - c)) &lt;= 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="多边形"><a href="#多边形" class="headerlink" title="多边形"></a>多边形</h3><h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">Point p[N];<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="应用-2"><a href="#应用-2" class="headerlink" title="应用"></a>应用</h4><ol><li><p>判断点是否在多边形内部</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int Point_in_polygon(Point pt, Point* p, int n)// 点pt，多边形Point* p{for (int i = 0; i &lt; n; ++i)if (p[i] == pt)return 3;// 3: 点在多边形的顶点上for (int i = 0; i &lt; n; ++i){Line v = Line(p[i], p[(i + 1) % n]);if (Point_on_seg(pt, v))return 2;// 2: 点在多边形的边上}int num = 0;for (int i = 0; i &lt; n; ++i){int j = (i + 1) % n;int c = sgn(Cross(pt - p[j], p[i] - p[j]));int u = sgn(p[i].y - pt.y);int v = sgn(p[j].y - pt.y);if (c &gt; 0 &amp;&amp; u &lt; 0 &amp;&amp; v &gt;= 0)++num;if (c &lt; 0 &amp;&amp; u &gt;= 0 &amp;&amp; v &lt; 0)--num;}return num != 0;// 1: 点在内部；0: 点在外部}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>多边形的面积</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">double Polygon_area(Point* p, int n){double area = 0;for (int i = 0; i &lt; n; ++i)area += Cross(p[i], p[(i + 1) % n]);return area / 2;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>求多边形的重心</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">Point Polygon_center(Point* p, int n){Point ans(0, 0);if (Polygon_area(p, n) == 0)return ans;for (int i = 0; i &lt; n; ++i)ans = ans + (p[i] + p[(i + 1) % n]) * Cross(p[i], p[(i + 1) % n]);return ans / Polygon_area(p, n) / 6;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 计算几何 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021.2.20</title>
      <link href="2021/02/20/2021-2-20/"/>
      <url>2021/02/20/2021-2-20/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 博弈论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021.2.4</title>
      <link href="2021/02/04/2021-2-4/"/>
      <url>2021/02/04/2021-2-4/</url>
      
        <content type="html"><![CDATA[<h1 id="2021-2-4"><a href="#2021-2-4" class="headerlink" title="2021.2.4"></a>2021.2.4</h1><h2 id="LCA"><a href="#LCA" class="headerlink" title="LCA"></a>LCA</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><blockquote><p>对于有根树 T 的两个结点 u、v，最近公共祖先 LCA(T, u, v) 表示一个结点 x，满足 x 是 u 和 v 的祖先且 x 的深度尽可能大。在这里，一个节点也可以是它自己的祖先。</p><p>——百度百科</p></blockquote><h3 id="Tarjan-•-离线"><a href="#Tarjan-•-离线" class="headerlink" title="Tarjan • 离线"></a>Tarjan • 离线</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><blockquote><p>利用并查集优越的时空复杂度，我们可以实现 LCA 问题的 O(n + Q) 算法，这里 Q 表示询问的次数。</p></blockquote><ul><li>Tarjan 算法基于深度优先搜索的框架，对于新搜索到的一个结点，首先创建由这个结点构成的集合，再对当前结点的每一个子树进行搜索，每搜索完一棵子树，则可确定子树内的 LCA 询问都已解决。其他的 LCA 询问的结果必然在这个子树之外，这时把子树所形成的集合与当前结点的集合合并，并将当前结点设为这个集合的祖先。</li><li>之后继续搜索下一棵子树，直到当前结点的所 有子树搜索完。这时把当前结点也设为已被检查过的，同时可以处理有关当前结点的 LCA 询问，如果有一个从当前结点到结点 v 的询问，且 v 已被检查过，则由于进行的是深度优先搜索，当前结点与 v 的最近公共祖先一定还没有被检查，而这个最近公共祖先的包涵 v 的子树一定已经搜索过了，那么这个最近公共祖先一定是 v 所在集合的祖先。</li></ul>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> LCA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021.2.3</title>
      <link href="2021/02/03/2021-2-3/"/>
      <url>2021/02/03/2021-2-3/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021.2.2</title>
      <link href="2021/02/02/2021-2-2/"/>
      <url>2021/02/02/2021-2-2/</url>
      
        <content type="html"><![CDATA[<h1 id="2021-2-2"><a href="#2021-2-2" class="headerlink" title="2021.2.2"></a>2021.2.2</h1><h2 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><blockquote><p>背包问题 (Knapsack problem) 是一种组合优化的 NP 完全问题。问题可以描述为：给定一组物品，每种物品都有自己的重量和价格，在限定的总重量内，我们如何选择，才能使得物品的总价格最高。</p><p>——百度百科</p></blockquote><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul><li>01 背包：有 N 件物品和一个容量为 V 的背包。第 i 件物品的重量是 w[i]，价值是 v[i]。求解将哪些物品装入背包可使这些物品的重量总和不超过背包容量，且价值总和最大。<strong>每样物品可取1件</strong></li><li>完全背包：有 N 种物品和一个容量为 V 的背包，每种物品都有 <strong>无限</strong> 件可用。第 i 种物品的体积是 c，价值是 w。将哪些物品装入背包可使这些物品的体积总和不超过背包容量，且价值总和最大。</li><li>多重背包：有 N 种物品和一个容量为 V 的背包。第 i 种物品最多 <strong>有 n 件</strong> 可用，每件体积是 c，价值是 w。求解将哪些物品装入背包可使这些物品的体积总和不超过背包容量，且价值总和最大。</li></ul><h2 id="01-背包"><a href="#01-背包" class="headerlink" title="01 背包"></a>01 背包</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>有 N 件物品和一个容量为 V 的背包。第 i 件物品的重量是 w[i]，价值是 v[i]。求解将哪些物品装入背包可使这些物品的重量总和不超过背包容量，且价值总和最大。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>每样物品最多可以取1次，即对于每样物品只有 <strong>取</strong> 或 <strong>不取</strong> 两种状态。</p>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> DP </tag>
            
            <tag> 01背包 </tag>
            
            <tag> 完全背包 </tag>
            
            <tag> 多重背包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021.1.31</title>
      <link href="2021/01/31/2021-1-31/"/>
      <url>2021/01/31/2021-1-31/</url>
      
        <content type="html"><![CDATA[<h1 id="2021-1-31"><a href="#2021-1-31" class="headerlink" title="2021.1.31"></a>2021.1.31</h1><h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><blockquote><p>一个有 n 个结点的连通图的生成树是原图的极小连通子图，且包含原图中的所有 n 个结点，并且有保持图连通的最少的边。</p><p>——百度百科</p></blockquote><h3 id="Kruskal"><a href="#Kruskal" class="headerlink" title="Kruskal"></a>Kruskal</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>用贪心的思想，把所有的边从短到长排序，从最短的边开始判断，如果连接的两个点不是已经联通的，那就把这条边连起来。如果已经联通，则忽略这条边。</p><p>用并查集维护所有的点，联通的点在同一集合，从而判断点是否联通。</p><h4 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 110;int n, m, f[maxn];struct Edge{int u, v, w;bool operator &lt; (const Edge&amp; r)const//边权从小到大排序{return w &lt; r.w;}} E[maxn * maxn];int find(int x){return x == f[x] ? x : f[x] = find(f[x]);}void Kruskal(int n, int m){int res = 0;// 存放结果int num = 0;// 记录当前选择了多少条边sort(E + 1, E + 1 + m);for (int i = 1; i &lt;= n; i++) f[i] = i;//初始化 每个点自己为一个集合for (int i = 1; i &lt;= m; i++){int f1 = find(E[i].u);//  查询u顶点在哪个集合中int f2 = find(E[i].v);//  查询v顶点在哪个集合中if (f1 != f2)//  如果不在同一个集合中{num++;//  选中的边数 +1res += E[i].w;//  答案加上这条边的权值f[f1] = f2;//  将这两个点合并到一个集合中}if (num == n - 1)// 如果已经找到了 n - 1条边，说明最小生成树已经构建完成了break;}if (num == n - 1) printf("%d\n", res);else  puts("?");}int main() {while (~scanf("%d %d", &amp;m, &amp;n)) {if (m == 0) break;for (int i = 1; i &lt;= m; i++)scanf("%d%d%d", &amp;E[i].u, &amp;E[i].v, &amp;E[i].w);Kruskal(n, m);}return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h4><ul><li>O(m log m)</li></ul><h3 id="Prim"><a href="#Prim" class="headerlink" title="Prim"></a>Prim</h3><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><ol><li>选用图中的任意一个顶点 v<sub>0</sub>，从 v<sub>0</sub> 开始生成最小生成树</li><li>初始化 d[v<sub>0</sub>] = 0，其他的点的距离值 d[i] = INF，其中 d[i] 表示当前这棵小树到其他点的最小距离值</li><li>经过 N 次如下步骤操作，最后得到一个含 N 各顶点，N - 1 条边的最小生成树<ol><li>选择一个未标记的点 K，并且 d[K] 的值是最小的</li><li>标记点 K 进入这棵小树</li><li>以 K 为中间点，更新这棵小树到未标记点的距离的最小值</li></ol></li><li>得到最小生成树 T</li></ol><h4 id="模板-1"><a href="#模板-1" class="headerlink" title="模板"></a>模板</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;bits/stdc++.h&gt;#define inf 0x3f3f3f3fusing namespace std;const int maxn = 110;int n, m, G[maxn][maxn], vis[maxn], d[maxn];void Prim(int n, int m){memset(vis, 0, sizeof(vis));int index = 1;  // 当前加入到小树的顶点int res = 0;    //  存放结果vis[index] = 1;for (int i = 1; i &lt;= n; i++)    // 更新这个点到其他点的距离  d[i] = G[index][i];for (int i = 1; i &lt; n; i++)     // 执行 n - 1 次， 找剩下的n - 1 个点{int minn = inf;for (int j = 1; j &lt;= n; j++)    // 找出未加入小树且 d 最小的点{if (!vis[j] &amp;&amp; d[j] &lt; minn){minn = d[j];index = j;}}if (minn == inf)     // 如果没有找到， 说明不存在最小生成树{puts("?");return;}res += minn;    // 累加答案vis[index] = 1;     // 将这个点加入最小生成树中for (int j = 1; j &lt;= n; j++)    // 更新这个点加入后，当前这棵小树到未加入的点的最近距离{if (!vis[j] &amp;&amp; d[j] &gt; G[index][j])  d[j] = G[index][j];}}printf("%d\n", res);}int main(){while (~scanf("%d%d", &amp;m, &amp;n)){if (m == 0) break;for (int i = 1; i &lt;= n; i++)    // 邻接矩阵的初始化{for (int j = 1; j &lt;= n; j++){if (i == j) G[i][j] = 0;else G[i][j] = inf;}}for (int i = 1, u, v, w; i &lt;= m; i++){scanf("%d%d%d", &amp;u, &amp;v, &amp;w);G[u][v] = G[v][u] = min(w, G[u][v]);    // 消除重边的影响}Prim(n, m);}return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h4><ul><li>O(n<sup>2</sup>)</li></ul>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 最小生成树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021.1.30</title>
      <link href="2021/01/30/2021-1-30/"/>
      <url>2021/01/30/2021-1-30/</url>
      
        <content type="html"><![CDATA[<h1 id="2021-1-30"><a href="#2021-1-30" class="headerlink" title="2021.1.30"></a>2021.1.30</h1><h2 id="最短路问题"><a href="#最短路问题" class="headerlink" title="最短路问题"></a>最短路问题</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><blockquote><p>最短路问题是图论理论的一个经典问题。寻找最短路径就是在指定网络中两结点间找一条距离最小的路。最短路不仅仅指一般地理意义上的距离最短,还可以引申到其它的度量,如时间、费用、线路容量等。</p><p>——百度百科</p></blockquote><h3 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h3><ul><li><p>Chain • 链：一个点和边的交错序列 v<sub>0</sub> - e<sub>1</sub> - v<sub>1</sub> - e<sub>2</sub> - v<sub>2</sub> - … - e<sub>k</sub> - v<sub>k</sub></p></li><li><p>Trail • 迹：对于一条路径 w，若e<sub>1</sub>, e<sub>2</sub>, …, e<sub>k</sub> 两两互不相同，则 w 是一条迹</p></li><li><p>Path • 路径：对于一条迹 w，除了 v<sub>0</sub> 和 v<sub>k</sub> 允许相同外，其余点两两互不相同，则称 w 是一条路径</p></li><li><p>Circuit • 回路：对于一个迹 w，若 v<sub>0</sub> = v<sub>k</sub>，则称 w 是一个回路</p></li><li><p>Cycle • 环：对于一条路径 w，若 v<sub>0</sub> = v<sub>k</sub>，则称 w 是一个环</p></li></ul><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul><li><p>单源最短路</p><p>包括确定起点的最短路径问题，确定终点的最短路径问题（与确定起点的问题相反，该问题是已知终结结点，求最短路径的问题。在无向图中该问题与确定起点的问题完全等同，在有向图中该问题等同于把所有路径方向反转的确定起点的问题。） 。</p></li><li><p>多源最短路</p></li></ul><h2 id="Dijkstra-•-单源最短路"><a href="#Dijkstra-•-单源最短路" class="headerlink" title="Dijkstra • 单源最短路"></a>Dijkstra • 单源最短路</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>将所有节点分成两个集合，已求出最短路的集合（集合1）和未求出最短路的集合（集合2）。</li><li>更新并记录集合2 中所有节点和源点的距离</li><li>从集合2 中找到距离源点距离最近的点</li><li>将该点移到集合1 中</li><li>重复步骤 2-3，直到集合2 为空</li></ol><p>这个方法用了贪心的思想，每次把距离最小的点视作确定的，因为它已经是未确定的点中距离源点最近的了，不可能存在一条路经过其他未确定的点到这个点，距离还比直接到这个点近的了。</p><ul><li><strong>不能有负权边</strong></li></ul><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><ul><li>dis[]：每个点到源点的距离</li><li>vis[]：每个点属于的集合，0 - 未确定，1 - 已确定</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void Dijkstra(int x){    memset (dis, INF, sizeof (dis));//源点到未更新到的点的距离为无穷大（无法达到）    memset (vis, 0, sizeof (vis));//所有点都先放在集合2 中    dis[x] = 0;    for (int i = 1; i &lt; n; i++)    {        int tmp;        for (int j = 1; j &lt;= n; j++)            if (!vis[j] &amp;&amp; dis[j] &lt; dis[tmp]) tmp = j;//找到集合2 中距离源点最近的点        vis[tmp] = 1;        for (int j = 1; j &lt;= n; j++)            dis[j] = min(dis[j], dis[tmp] + mp[x][j]);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><ul><li>O(n<sup>2</sup>)</li></ul><h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><ul><li><p>从一个点出发到所有点的距离：正 Dijkstra</p></li><li><p>从所有点出发到一个点的距离（<a href="http://poj.org/problem?id=3268">POJ 3268 • Silver Cow Party</a>）</p><ul><li><p>把图反向</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int tmp = map[i][j];map[i][j] = map[j][i];map[j][i] = tmp;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>Dijkstra</p></li></ul></li></ul><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><h2 id="Floyd-•-多源最短路"><a href="#Floyd-•-多源最短路" class="headerlink" title="Floyd • 多源最短路"></a>Floyd • 多源最短路</h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>我们定义一个数组 <code>dis[k][x][y]</code> ，表示只允许经过结点 V<sub>1</sub> 到 V<sub>k</sub>，结点 x 到结点 y 的最短路长度。很显然， <code>dis[n][x][y]</code> 就是最终结点 x 到结点 y 的最短路长度。</p><p><code>dis[0][x][y]</code> 是 x 与 y 的边权，或者 0 ，或者 INF（当 x 与 y 间有直接相连的边的时候，为它们的边权；当 x = y 的时候为零，因为到本身的距离为零；当 x 与 y 没有直接相连的边的时候，为 INF）</p><p><code>dis[k][x][y] = min(dis[k-1][x][y], dis[k-1][x][k]+dis[k-1][k][y])</code> （ <code>dis[k-1][x][y]</code> 为不经过 k 点的最短路径，而 <code>dis[k-1][x][k]+dis[k-1][k][y]</code> 为经过了 k 点的最短路）。</p><ul><li><p><strong>能有负权边</strong></p></li><li><p><strong>不能有负环</strong></p></li></ul><h3 id="模板-1"><a href="#模板-1" class="headerlink" title="模板"></a>模板</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void Floyd(){    for (int k = 1; k &lt;= n; k++)    {        for (int i = 1; i &lt;= n; i++)        {        for(int j = 1; j &lt;= n; j++)            {                dis[k][i][j] = min(dis[k - 1][i][j], dis[k - 1][i][k] + dis[k - 1][k][j]);            }        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>不难看出，k 每次循环后只是调用了 k - 1 的数据，而 k 之前的数据对结果没有作用，因此第一维是可以省略的（数据可以不保存，直接在下一次循环被覆盖，但是还是需要有这 k 次循环）</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void Floyd(){    for (int k = 1; k &lt;= n; k++)    {        for (int i = 1; i &lt;= n; i++)        {        for(int j = 1; j &lt;= n; j++)            {                dis[i][j] = min(dis[i][j], dis[i][k] + di[k][j]);            }        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h3><ul><li>时间复杂度：O(n<sup>3</sup>)</li><li>空间复杂度：O(n<sup>2</sup>)</li></ul><h2 id="Bellman-Ford-•-单源最短路"><a href="#Bellman-Ford-•-单源最短路" class="headerlink" title="Bellman-Ford • 单源最短路"></a>Bellman-Ford • 单源最短路</h2><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ul><li><p>松弛</p><p>每次松弛操作实际上是对相邻节点的访问，第 n 次松弛操作保证了所有深度为 n 的路径最短。由于图的最短路径最长不会经过超过 |V| - 1 条边，所以可知贝尔曼-福特算法所得为最短路径。</p></li><li><p>负边权操作</p><p>与 Dijkstra 算法不同的是，迪科斯彻算法的基本操作“拓展”是在深度上寻路，而“松弛”操作则是在广度上寻路，这就确定了贝尔曼-福特算法可以对负边进行操作而不会影响结果。</p></li><li><p>负权环判定</p><p>因为负权环可以无限制的降低总花费，所以如果发现第 n 次操作仍可降低花销，就一定存在负权环。</p></li></ul><ul><li><p><strong>能有负权边</strong></p></li><li><p><strong>能有负环</strong></p></li></ul><h3 id="优化-1"><a href="#优化-1" class="headerlink" title="优化"></a>优化</h3><ul><li><p>循环的提前跳出</p><p>在实际操作中，贝尔曼-福特算法经常会在未达到 |V| - 1 次前就出解，|V| - 1 其实是最大值。于是可以在循环中设置判定，在某次循环不再进行松弛时，直接退出循环，进行负权环判定。</p></li><li><p>最短路径快速算法</p><p>松弛操作必定只会发生在最短路径前导节点松弛成功过的节点上，用一个队列记录松弛过的节点，可以避免了冗余计算。该算法的复杂度为 O(k|E|)，k 是个比较小的系数，但该结论未得到广泛认可。</p></li></ul><h3 id="模板-2"><a href="#模板-2" class="headerlink" title="模板"></a>模板</h3><ul><li><del>SPFA已死</del></li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;list&gt;using namespace std;struct Edge{int to, len;};bool SPFA(const int&amp; beg,//出发点const vector&lt;list&lt;Edge&gt; &gt;&amp; adjlist,//邻接表，通过传引用避免拷贝vector&lt;int&gt;&amp; dist,//出发点到各点的最短路径长度vector&lt;int&gt;&amp; path)//路径上到达该点的前一个点//没有负权回路返回0{const int INF = 0x7FFFFFFF, NODE = adjlist.size();//用邻接表的大小传递顶点个数，减少参数传递dist.assign(NODE, INF);//初始化距离为无穷大path.assign(NODE, -1);//初始化路径为未知list&lt;int&gt; que(1, beg);//处理队列vector&lt;int&gt; cnt(NODE, 0);//记录各点入队次数，用于判断负权回路vector&lt;bool&gt; flag(NODE, 0);//标志数组，判断是否在队列中dist[beg] = 0;//出发点到自身路径长度为0cnt[beg] = flag[beg] = 1;//入队并开始计数while (!que.empty()){const int now = que.front();que.pop_front();flag[now] = 0;//将当前处理的点出队for (list&lt;Edge&gt;::const_iterator//用常量迭代器遍历邻接表i = adjlist[now].begin(); i != adjlist[now].end(); ++i)if (dist[i-&gt;to] &gt; dist[now] + i-&gt;len)//不满足三角不等式{dist[i-&gt;to] = dist[now] + i-&gt;len;//更新path[i-&gt;to] = now;//记录路径if (!flag[i-&gt;to])//若未在处理队列中{if (NODE == ++cnt[i-&gt;to])return 1;//计数后出现负权回路if (!que.empty() &amp;&amp; dist[i-&gt;to] &lt; dist[que.front()])//队列非空且优于队首（SLF）que.push_front(i-&gt;to);//放在队首else que.push_back(i-&gt;to);//否则放在队尾flag[i-&gt;to] = 1;//入队}}}return 0;}int main(){int n_num, e_num, beg;//含义见下cout &lt;&lt; "输入点数、边数、出发点：";cin &gt;&gt; n_num &gt;&gt; e_num &gt;&gt; beg;vector&lt;list&lt;Edge&gt; &gt; adjlist(n_num, list&lt;Edge&gt;());//默认初始化邻接表for (int i = 0, p; i != e_num; ++i){Edge tmp;cout &lt;&lt; "输入第" &lt;&lt; i + 1 &lt;&lt; "条边的起点、终点、长度：";cin &gt;&gt; p &gt;&gt; tmp.to &gt;&gt; tmp.len;adjlist[p].push_back(tmp);}vector&lt;int&gt; dist, path;//用于接收最短路径长度及路径各点if (SPFA(beg, adjlist, dist, path))cout &lt;&lt; "图中存在负权回路\n";else for (int i = 0; i != n_num; ++i){cout &lt;&lt; beg &lt;&lt; "到" &lt;&lt; i &lt;&lt; "的最短距离为" &lt;&lt; dist[i] &lt;&lt; "，反向打印路径：";for (int w = i; path[w] &gt;= 0; w = path[w])cout &lt;&lt; w &lt;&lt; "&lt;-";cout &lt;&lt; beg &lt;&lt; '\n';}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="复杂度-2"><a href="#复杂度-2" class="headerlink" title="复杂度"></a>复杂度</h3><ul><li>O(|V| · |E|)</li></ul><h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><h3 id="A-最短路-•-HDU-2544"><a href="#A-最短路-•-HDU-2544" class="headerlink" title="A  最短路 • HDU 2544"></a>A <a href="https://vjudge.net/contest/420578#problem/A"> 最短路</a> • <a href="http://acm.hdu.edu.cn/showproblem.php?pid=2544">HDU 2544</a></h3><h3 id="B-Til-the-Cows-Come-Home-•-POJ-2387"><a href="#B-Til-the-Cows-Come-Home-•-POJ-2387" class="headerlink" title="B  Til the Cows Come Home • POJ 2387"></a>B <a href="https://vjudge.net/contest/420578#problem/B"> Til the Cows Come Home</a> • <a href="http://poj.org/problem?id=2387">POJ 2387</a></h3><h3 id="C-Silver-Cow-Party-•-POJ-3268"><a href="#C-Silver-Cow-Party-•-POJ-3268" class="headerlink" title="C  Silver Cow Party • POJ 3268"></a>C <a href="https://vjudge.net/contest/420578#problem/C"> Silver Cow Party</a> • <a href="http://poj.org/problem?id=3268">POJ 3268</a></h3><h3 id="D-Heavy-Transportation-•-POJ-1797"><a href="#D-Heavy-Transportation-•-POJ-1797" class="headerlink" title="D  Heavy Transportation •  POJ 1797"></a>D <a href="https://vjudge.net/contest/420578#problem/D"> Heavy Transportation</a> • <a href="http://poj.org/problem?id=1797"> POJ 1797</a></h3><h3 id="E-Cow-Contest-•-POJ-3660"><a href="#E-Cow-Contest-•-POJ-3660" class="headerlink" title="E  Cow Contest • POJ 3660"></a>E <a href="https://vjudge.net/contest/420578#problem/E"> Cow Contest</a> • <a href="http://poj.org/problem?id=3660">POJ 3660</a></h3><h3 id="F-Edge-Deletion-•-CodeForces-1076D"><a href="#F-Edge-Deletion-•-CodeForces-1076D" class="headerlink" title="F Edge Deletion • CodeForces 1076D"></a>F <a href="https://vjudge.net/contest/420578#problem/F">Edge Deletion</a> • <a href="https://codeforces.com/problemset/problem/1076/D">CodeForces 1076D</a></h3>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> Floyd </tag>
            
            <tag> Dijkstra </tag>
            
            <tag> SPFA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021.1.29</title>
      <link href="2021/01/29/2021-1-29/"/>
      <url>2021/01/29/2021-1-29/</url>
      
        <content type="html"><![CDATA[<h1 id="2021-1-29"><a href="#2021-1-29" class="headerlink" title="2021.1.29"></a>2021.1.29</h1><h2 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h2><blockquote><p>Hash，一般翻译做散列、杂凑，或音译为哈希，是把任意长度的输入（又叫做预映射pre-image）通过散列算法变换成固定长度的输出，该输出就是散列值。这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，所以不可能从散列值来确定唯一的输入值。简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> Hash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021.1.27</title>
      <link href="2021/01/27/2021-1-27/"/>
      <url>2021/01/27/2021-1-27/</url>
      
        <content type="html"><![CDATA[<h1 id="2021-1-27"><a href="#2021-1-27" class="headerlink" title="2021.1.27"></a>2021.1.27</h1><h2 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>斐波那契数列：1, 1, 2, 3, 5, 8, 13, 21, 34, 55, …</p><p>即：</p><ul><li>a<sub>n</sub> = 1    (n = 1 or n = 2)</li><li>a<sub>n</sub> = a<sub>n-1</sub> + a<sub>n-2</sub>    (n &gt;= 3)</li></ul><p>求斐波那契的第 n 项</p><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>找到了其中的 <strong>最优子结构</strong>（递归公式）：f(n) = f(n - 1) + f(n - 2)</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">long long func(int n){    if (n == 1 || n == 2) return 1;    return func(n - 1) + func(n - 2);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h4><ul><li>时间复杂度 • O(2<sup>n</sup>)</li></ul><h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>计算 f(n) 时要计算 f(n - 1) 和 f(n - 2)，而计算 f(n - 1) 要计算 f(n - 2) 和 f(n - 3)…因此有很多是重复计算，因此考虑到用空间换时间，记录下这些值，以后需要计算这些值的时候直接返回已经计算得到的值即可</p><h3 id="空间换时间-•-记忆化"><a href="#空间换时间-•-记忆化" class="headerlink" title="空间换时间 • 记忆化"></a>空间换时间 • 记忆化</h3><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>发现有很多值重复计算，用空间换时间</p><h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">long long f[1001] = {0, 1, 1};long long func(int n){    if (!f[n]) f[n] = func(n - 1) + func(n - 2);    return f[n];}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h4><ul><li>时间复杂度 • O(n)</li></ul><h4 id="优化-1"><a href="#优化-1" class="headerlink" title="优化"></a>优化</h4><p>不难发现，结果是从前往后一位一位计算得到的，第 3 位，第 4 位…第 n 位。而每次计算的时候只与这一位的前两位有关系，因此可以使用循环的方法完成。</p><h3 id="递归变循环"><a href="#递归变循环" class="headerlink" title="递归变循环"></a>递归变循环</h3><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>打印空间，发现是按顺序从前往后运行的</p><h4 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">long long f[10001] = {0, 1, 1};long long func(int n){    for (int i = 3; i &lt;= n; i++) f[i] = f[i - 1] + f[i - 2];    return f[n];}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="复杂度-2"><a href="#复杂度-2" class="headerlink" title="复杂度"></a>复杂度</h4><ul><li><p>时间复杂度 • O(n)</p></li><li><p>空间复杂度 • O(n)</p></li></ul><h4 id="优化-2"><a href="#优化-2" class="headerlink" title="优化"></a>优化</h4><p>不难发现，当前值至于前两个值有关，因此不需要保留前两个之前的值</p><h3 id="空间压缩-•-即用即抛"><a href="#空间压缩-•-即用即抛" class="headerlink" title="空间压缩 • 即用即抛"></a>空间压缩 • 即用即抛</h3><h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><p>发现很多空间被重复利用，每次计算只与前两项有关</p><h4 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">long long a = 1, b = 1, c;long long func(int n){    for (int i = 3; i &lt;= n; i++)    {        c = b;        b = a + b;        a = c;    }    return b ;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>时间复杂度 • O(n)</p></li><li><p>空间复杂度 • O(1)</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021.1.25</title>
      <link href="2021/01/25/2021-1-25/"/>
      <url>2021/01/25/2021-1-25/</url>
      
        <content type="html"><![CDATA[<h1 id="2021-1-25"><a href="#2021-1-25" class="headerlink" title="2021.1.25"></a>2021.1.25</h1><h2 id="问题引入"><a href="#问题引入" class="headerlink" title="问题引入"></a>问题引入</h2><p>假设需要反复对一个数组 a[] 进行以下两个操作：</p><ul><li><p>Query • 求和</p><p>对 a[l] ~ a[r] 求和</p></li><li><p>Update • 修改</p><p>将 a[idx] 的值修改为 val</p></li></ul><p>则有如下解决办法：</p><h3 id="朴素做法"><a href="#朴素做法" class="headerlink" title="朴素做法"></a>朴素做法</h3><ul><li><p>Build</p><p><code>for (int i = 1; i &lt;= n; i++) scanf ("%d", &amp;a[i]);</code></p></li><li><p>Query</p><p><code>for (int i = l; i &lt;= r; i++) sum += a[i];</code> <code>O(n)</code></p></li><li><p>Update</p><p><code>a[idx] = val;</code> <code>O(1)</code></p></li></ul><h3 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h3><ul><li><p>Build</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">for (int i = 1; i &lt;= l; i++){scanf ("%d", &amp;a[i]);sum_a[i] = sum_a[i-1] + a[i];}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>Query</p><p><code>sum = sum_a[r] - sum_a[l - 1];</code> <code>O(1)</code></p></li><li><p>Update</p><p><code>for (int i = idx; i &lt;= n; i++) sum_a[i] += val; </code> <code>O(n)</code></p></li></ul><p>可见，两种方法的时间复杂度都较高，于是引入线段树的数据结构</p><h2 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><blockquote><p>线段树是一种二叉搜索树，与区间树相似，它将一个区间划分成一些单元区间，每个单元区间对应线段树中的一个叶结点。</p><p>——百度百科</p></blockquote><ul><li><p>Build</p><p>如图，区间依次对半分，每个节点存储一部分区间的和，节点按序标记为 1 ~ n（图中为 0 ~ n - 1）</p><img src="https://cdn.jsdelivr.net/gh/OwlllOvO/Hexo-image/20210125202804.png" style="zoom: 50%;"></li><li><p>Query <code>O(logn)</code></p><ul><li>从根结点开始划分求和区间</li><li>如果节点区间为求和区间的子集：返回节点值</li><li>如果节点区间与求和区间无交集：返回 0</li></ul></li><li><p>Update <code>O(logn)</code></p><ul><li>找到修改的节点，修改值</li><li>向上更新节点值</li></ul></li></ul><h3 id="模板-•-单点修改-•-数组"><a href="#模板-•-单点修改-•-数组" class="headerlink" title="模板 • 单点修改 • 数组"></a>模板 • 单点修改 • 数组</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define _CRTSECURE_NOWARNINGS#pragma warning(disable:4996)#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;cmath&gt;#include&lt;cctype&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;vector&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;list&gt;using namespace std;const int MAX_LEN = 1000016;int n, m, q;int arr[MAX_LEN], tree[MAX_LEN &lt;&lt; 2];void build_tree(int node, int start, int end){if (start == end){tree[node] = arr[start];return;}int mid = (start + end) &gt;&gt; 1;int left_node  = node &lt;&lt; 1;int right_node = node &lt;&lt; 1 | 1;build_tree(left_node,  start,   mid);build_tree(right_node, mid + 1, end);tree[node] = tree[left_node] + tree[right_node];}void update_tree(int node, int start, int end, int idx, int val){if (start == end){arr[idx] = val;tree[node] = arr[idx];return;}int mid = (start + end) &gt;&gt; 1;int left_node  = node &lt;&lt; 1;int right_node = node &lt;&lt; 1 | 1;if (idx &lt;= mid)        update_tree(left_node,  start,   mid, idx, val);else        update_tree(right_node, mid + 1, end, idx, val);tree[node] = tree[left_node] + tree[right_node];}int query_tree(int node, int start, int end, int l, int r){if (r &lt; start || l &gt; end) return 0;if (l &lt;= start &amp;&amp; r &gt;= end) return tree[node];if (start == end) return tree[node];int mid = (start + end) &gt;&gt; 1;int left_node  = node &lt;&lt; 1;int right_node = node &lt;&lt; 1 | 1;int sum_left  = query_tree(left_node,  start,   mid, l, r);int sum_right = query_tree(right_node, mid + 1, end, l, r);return sum_left + sum_right;}int main(){while (scanf("%d", &amp;n) != EOF){for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;arr[i]);build_tree(1, 1, n);scanf("%d", &amp;m);while (m--){int idx, val;scanf("%d%d", &amp;idx, &amp;val);update_tree(1, 1, n, idx, val);}scanf("%d", &amp;q);while (q--){int l, r;scanf("%d%d", &amp;l, &amp;r);printf("%d\n", query_tree(1, 1, n, l, r));}}return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="模板-•-区间修改"><a href="#模板-•-区间修改" class="headerlink" title="模板 • 区间修改"></a>模板 • 区间修改</h3><h3 id="权值线段树"><a href="#权值线段树" class="headerlink" title="权值线段树"></a>权值线段树</h3><h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><h3 id="A-例题1-•-SPOJ-GSS1"><a href="#A-例题1-•-SPOJ-GSS1" class="headerlink" title="A 例题1 • SPOJ GSS1"></a>A <a href="https://vjudge.net/contest/419506#problem/A">例题1</a> • <a href="https://vjudge.net/problem/SPOJ-GSS1/origin">SPOJ GSS1</a></h3><h3 id="B-例题2-•-Gym-102770B"><a href="#B-例题2-•-Gym-102770B" class="headerlink" title="B 例题2 • Gym 102770B"></a>B <a href="https://vjudge.net/contest/419506#problem/B">例题2</a> • <a href="https://vjudge.net/problem/Gym-102770B/origin">Gym 102770B</a></h3><h3 id="C-例题3-•-POJ-2182"><a href="#C-例题3-•-POJ-2182" class="headerlink" title="C 例题3 • POJ 2182"></a>C <a href="https://vjudge.net/contest/419506#problem/C">例题3</a> • <a href="https://vjudge.net/problem/POJ-2182/origin">POJ 2182</a></h3><h3 id="D-【模板】单点修改-•-HDU-1166"><a href="#D-【模板】单点修改-•-HDU-1166" class="headerlink" title="D 【模板】单点修改 • HDU 1166"></a>D <a href="https://vjudge.net/contest/419506#problem/D">【模板】单点修改</a> • <a href="https://vjudge.net/problem/HDU-1166/origin">HDU 1166</a></h3><h3 id="E-【模板】区间修改-•-POJ-3468"><a href="#E-【模板】区间修改-•-POJ-3468" class="headerlink" title="E 【模板】区间修改 • POJ 3468"></a>E <a href="https://vjudge.net/contest/419506#problem/E">【模板】区间修改</a> • <a href="https://vjudge.net/problem/POJ-3468/origin">POJ 3468</a></h3><h3 id="F-练习题1-•-CodeForces-339D"><a href="#F-练习题1-•-CodeForces-339D" class="headerlink" title="F 练习题1 • CodeForces 339D"></a>F <a href="https://vjudge.net/contest/419506#problem/F">练习题1</a> • <a href="https://vjudge.net/problem/CodeForces-339D/origin">CodeForces 339D</a></h3><h3 id="G-练习题2-•-HDU-2795"><a href="#G-练习题2-•-HDU-2795" class="headerlink" title="G 练习题2 • HDU 2795"></a>G <a href="https://vjudge.net/contest/419506#problem/G">练习题2</a> • <a href="https://vjudge.net/problem/HDU-2795/origin">HDU 2795</a></h3><h3 id="H-练习题3-•-HDU-2852"><a href="#H-练习题3-•-HDU-2852" class="headerlink" title="H 练习题3 • HDU 2852"></a>H <a href="https://vjudge.net/contest/419506#problem/H">练习题3</a> • <a href="https://vjudge.net/problem/HDU-2852/origin">HDU 2852</a></h3>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021.1.23</title>
      <link href="2021/01/23/2021-1-23/"/>
      <url>2021/01/23/2021-1-23/</url>
      
        <content type="html"><![CDATA[<h1 id="2021-1-23"><a href="#2021-1-23" class="headerlink" title="2021.1.23"></a>2021.1.23</h1><h2 id="DFS-•-深度优先搜索"><a href="#DFS-•-深度优先搜索" class="headerlink" title="DFS • 深度优先搜索"></a>DFS • 深度优先搜索</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><blockquote><p>深度优先搜索属于图算法的一种，英文缩写为 DFS 即 Depth First Search. 其过程简要来说是对每一个可能的分支路径深入到不能再深入为止，而且每个节点只能访问一次。</p><p>——百度百科</p></blockquote><blockquote><p>在一条路上的分岔按顺序选择方向，一条路走到底再返回到最近分岔选择下一条路，这个分岔下所有路全走完后再返回到更上一个分岔走下一条路。</p></blockquote><h3 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h3><blockquote><p>深度优先遍历图的方法是，从图中某顶点v出发：</p><ol><li>访问顶点 v ；</li><li>依次从v的未被访问的邻接点出发，对图进行深度优先遍历；直至图中和v有路径相通的顶点都被访问；</li><li>若此时图中尚有顶点未被访问，则从一个未被访问的顶点出发，重新进行深度优先遍历，直到图中所有顶点均被访问过为止。</li></ol></blockquote><p><u>搜索完节点后注意是否需要回溯！</u></p><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">bool judge(int x, int y) {};//判断当前状态是否合法bool check(int x, int y) {};//判断是否为最终答案void dfs(int x, int y, int z){    if(!judge(x, y)) return;    if(check(x, y))    {        //保存答案    }    visited[x][y] = 1;//标记已搜索过此节点，防止重复搜索    /*        操作...    */    dfs(x - 1, y, z + 1);    dfs(x + 1, y, z + 1);    dfs(x, y - 1, z + 1);    dfs(x, y + 1, z + 1);    visited[x][y] = 0;//回溯}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><h4 id="剪枝"><a href="#剪枝" class="headerlink" title="剪枝"></a>剪枝</h4><p>有些求最优解的题目，可以不用完全遍历，当目前 dfs 的解已经比历史遍历得到的最优解更差时，可以停止遍历，节省一部分时间复杂度。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">bool judge(int x, int y) {};//判断当前状态是否合法bool check(int x, int y) {};//判断是否为最终答案void dfs(int x, int y, int z){    if(!judge(x, y)) return;    if(z &gt; ans) return;    if(check(x, y))    {        ans = z;        //保存答案    }    visited[x][y] = 1;//标记已搜索过此节点，防止重复搜索    /*        操作...    */    dfs(x - 1, y, z + 1);    dfs(x + 1, y, z + 1);    dfs(x, y - 1, z + 1);    dfs(x, y + 1, z + 1);    visited[x][y] = 0;//回溯}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="记忆化搜索"><a href="#记忆化搜索" class="headerlink" title="记忆化搜索"></a>记忆化搜索</h4><p>对于遍历某些确定的类型时，如果到达一个节点之后的遍历结果是可以确定的，第一遍先向下遍历得到结果，将这个结果保存，之后再遍历到此节点时直接返回已得到的结果，可以节省一部分时间复杂度。</p><p>如：<a href="https://www.luogu.com.cn/problem/P1434">洛谷 P1434 [SHOI2002]滑雪</a></p><p>题目大意：矩阵求最长下降线路长度</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int fx[5] = { 0, 0, 0, 1, -1 };int fy[5] = { 0, 1, -1, 0, 0 };int dfs(int x, int y){if (f[x][y]) return f[x][y];//记忆化搜索f[x][y] = 1;//题目中答案是有包含这个点的for (int i = 1; i &lt;= 4; i++){int xx = fx[i] + x;int yy = fy[i] + y;//四个方向if (xx &gt; 0 &amp;&amp; yy &gt; 0 &amp;&amp; xx &lt;= n &amp;&amp; yy &lt;= m &amp;&amp; a[x][y] &gt; a[xx][yy]){f[x][y] = max(f[x][y], dfs(xx, yy) + 1);}}return f[x][y];}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="BFS-•-广度优先搜索"><a href="#BFS-•-广度优先搜索" class="headerlink" title="BFS • 广度优先搜索"></a>BFS • 广度优先搜索</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><blockquote><p>从出发点一层一层向外遍历，到达终点就结束。因此，到达终点的方案一定是最优解。</p></blockquote><blockquote><p>无论有多少条路，每条路都只走一步，并记录下状态，等到所有的路都走完一步后，再从第一条路开始走第二步，直至有一条路走到终点。</p></blockquote><h3 id="基本思路-1"><a href="#基本思路-1" class="headerlink" title="基本思路"></a>基本思路</h3><blockquote><p>广度优先搜索使用队列（queue）来实现，整个过程也可以看做一个倒立的树形：</p><ol><li><p>把根节点放到队列的末尾。</p></li><li><p>每次从队列的头部取出一个元素，查看这个元素所有的下一级元素，把它们放到队列的末尾。并把这个元素记为它下一级元素的前驱。</p></li><li><p>找到所要找的元素时结束程序。</p></li><li><p>如果遍历整个树还没有找到，结束程序。</p></li></ol></blockquote><h3 id="模板-1"><a href="#模板-1" class="headerlink" title="模板"></a>模板</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int fx[5] = { 0, -1, 1, 0, 0 };int fy[5] = { 0, 0, 0, -1, 1 };//上下左右struct node{    int x, y, z;};bool check (int x, int y) {};//判断点是否能走void bfs(int x, int y, int z){    node start;start.x = x;start.y = y;start.z = 0;//start 为出发点，z 为步数    queue &lt;node&gt; q;q.push(start);//将出发点推入队列中等待处理while (!q.empty()){        node now;now = q.front();//从队列中取出首元素处理q.pop();//将该元素取出后要记得推出，否则只推入不推出，死循环t[now.x][now.y] = now.z;//这里是记录了到 [now.x][now.y] 的最短路径，也可以做其他操作for (int i = 1; i &lt;= 4; i++)//往四个方向继续遍历{            if (check (now.x + fx[i], now.y + fy[i])){node next;next.x = now.x + fx[i];next.y = now.y + fy[i];next.z = now.z + 1;vi[next.x][next.y] = 1;q.push(next);//将该点保存并推入队列中，等待前面的处理完后再走下一步}}}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><blockquote><p>对一个有向无环图 (Directed Acyclic Graph简称DAG) G进行拓扑排序，是将 G 中所有顶点排成一个线性序列，使得图中任意一对顶点 u 和 v，若边 &lt;u,v&gt;∈E(G)，则u在线性序列中出现在 v 之前。通常，这样的线性序列称为满足拓扑次序 (Topological Order) 的序列，简称拓扑序列。简单的说，由某个集合上的一个偏序得到该集合上的一个全序，这个操作称之为拓扑排序。</p><p>——百度百科</p></blockquote><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p>由 AOV 网构造拓扑序列的拓扑排序算法主要是循环执行以下两步，直到不存在入度为0的顶点为止。</p><ol><li><p>选择一个入度为 0 的顶点并输出之；</p></li><li><p>从网中删除此顶点及所有出边。</p><p>循环结束后，若输出的顶点数小于网中的顶点数，则输出“有回路”信息，否则输出的顶点序列就是一种拓扑序列。</p></li></ol><h2 id="二分图"><a href="#二分图" class="headerlink" title="二分图"></a>二分图</h2><p>待更</p><h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><h3 id="A-Find-a-way-•-HDU-2612"><a href="#A-Find-a-way-•-HDU-2612" class="headerlink" title="A Find a way • HDU 2612"></a>A <a href="https://vjudge.net/contest/419048#problem/A">Find a way</a> • <a href="https://vjudge.net/problem/HDU-2612/origin">HDU 2612</a></h3><h3 id="B-Dungeon-Master-•-POJ-2251"><a href="#B-Dungeon-Master-•-POJ-2251" class="headerlink" title="B Dungeon Master • POJ 2251"></a>B <a href="https://vjudge.net/contest/419048#problem/B">Dungeon Master</a> • <a href="https://vjudge.net/problem/POJ-2251/origin">POJ 2251</a></h3><h3 id="C-Red-and-Black-•-HDU-1312"><a href="#C-Red-and-Black-•-HDU-1312" class="headerlink" title="C Red and Black • HDU 1312"></a>C <a href="https://vjudge.net/contest/419048#problem/C">Red and Black</a> • <a href="https://vjudge.net/problem/HDU-1312/origin">HDU 1312</a></h3><h3 id="D-Counting-Sheep-•-HDU-2952"><a href="#D-Counting-Sheep-•-HDU-2952" class="headerlink" title="D Counting Sheep • HDU 2952"></a>D <a href="https://vjudge.net/contest/419048#problem/D">Counting Sheep</a> • <a href="https://vjudge.net/problem/HDU-2952/origin">HDU 2952</a></h3><h3 id="E-N皇后问题-•-HDU-2553"><a href="#E-N皇后问题-•-HDU-2553" class="headerlink" title="E N皇后问题 • HDU 2553"></a>E <a href="https://vjudge.net/contest/419048#problem/E">N皇后问题</a> • <a href="https://vjudge.net/problem/HDU-2553/origin">HDU 2553</a></h3><h3 id="F-A-Funny-Bipartite-Graph-•-计蒜客-42577"><a href="#F-A-Funny-Bipartite-Graph-•-计蒜客-42577" class="headerlink" title="F  A Funny Bipartite Graph • 计蒜客 42577"></a>F <a href="https://vjudge.net/contest/419048#problem/F"> A Funny Bipartite Graph</a> • <a href="https://vjudge.net/problem/%E8%AE%A1%E8%92%9C%E5%AE%A2-42577/origin">计蒜客 42577</a></h3><h3 id="G-wyh2000-and-pupil-•-HDU-5285"><a href="#G-wyh2000-and-pupil-•-HDU-5285" class="headerlink" title="G wyh2000 and pupil • HDU 5285"></a>G <a href="https://vjudge.net/contest/419048#problem/G">wyh2000 and pupil</a> • <a href="https://vjudge.net/problem/HDU-5285/origin">HDU 5285</a></h3><h3 id="H-Legal-or-Not-•-HDU-3342"><a href="#H-Legal-or-Not-•-HDU-3342" class="headerlink" title="H Legal or Not • HDU 3342"></a>H <a href="https://vjudge.net/contest/419048#problem/H">Legal or Not</a> • <a href="https://vjudge.net/problem/HDU-3342/origin">HDU 3342</a></h3>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> DFS </tag>
            
            <tag> BFS </tag>
            
            <tag> 拓扑排序 </tag>
            
            <tag> 二分图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021.1.22</title>
      <link href="2021/01/22/2021-1-22/"/>
      <url>2021/01/22/2021-1-22/</url>
      
        <content type="html"><![CDATA[<h1 id="2021-1-22"><a href="#2021-1-22" class="headerlink" title="2021.1.22"></a>2021.1.22</h1><h2 id="二分查找-•-Binary-Search"><a href="#二分查找-•-Binary-Search" class="headerlink" title="二分查找 • Binary Search"></a>二分查找 • Binary Search</h2><blockquote><p>二分查找也称折半查找（Binary Search），它是一种效率较高的查找方法。但是，折半查找要求线性表必须采用顺序存储结构，而且表中元素按关键字有序排列。</p><p>——百度百科</p></blockquote><ul><li><p>有序排列</p><p><code>sort (a + 1, a + n + 1, cmp);</code></p></li><li><p>时间复杂度 <strong>O(logn)</strong></p></li></ul><p>学了二分以后给我的感觉就是很多东西都可以拿来二分，以前以为只有查找可以用二分，现在知道原来很多有范围的东西，都可以用二分来逼近答案。</p><h3 id="整数二分"><a href="#整数二分" class="headerlink" title="整数二分"></a>整数二分</h3><h4 id="找-gt-s-的数中最小的"><a href="#找-gt-s-的数中最小的" class="headerlink" title="找 >= s 的数中最小的"></a>找 &gt;= s 的数中最小的</h4><ul><li><p>记录答案</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">bool check (int x){    if (a[x] &gt;= s) return 1;    else return 0;}int l = 1, r = n, ans = 0;while (l &lt;= r){    int mid = (l + r) / 2;    if (check (mid))    {        ans = mid;        r = mid - 1;    }    else l = mid + 1;}printf ("%d", a[ans]);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><ul><li><p>不记录答案 • r 逼近答案</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int l = 1, r = n;while (l &lt; r){    int mid = (l + r) / 2;    if (a[mid] &gt;= s) r = mid;    else l = mid + 1;}printf ("%d", a[r]);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>如果 a[mid] &gt;= s 成立，接下来应该向左继续查找，而此时 mid 是符合要求的，所以要保留，因此 r = mid</p></li><li><p>如果 a[mid] &gt;= s 不成立，接下来应该向右继续查找，而此时 mid 是不符合要求的，所以要舍弃，因此 l = mid + 1</p></li><li><p>输出的数一定是要符合要求的，每次查找 r = mid，r一定是符合要求，而 l 不一定，所以输出 r</p></li></ul><h4 id="找-lt-s-的数中最大的"><a href="#找-lt-s-的数中最大的" class="headerlink" title="找 < s 的数中最大的"></a>找 &lt; s 的数中最大的</h4><ul><li><p>记录答案</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">bool check (int x){    if (a[x] &lt; s) return 1;    else return 0;}int l = 1, r = n, ans = 0;while (l &lt;= r){    int mid = (l + r) / 2;    if (check (mid))    {        ans = mid;        l = mid + 1;    }    else r = mid - 1;}printf ("%d", a[ans]);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><ul><li><p>不记录答案 • l 逼近答案</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int l = 1, r = n;while (l &lt; r){    int mid = (l + r + 1) / 2;    if (a[i] &lt; s) l = mid;    else r = mid - 1;}printf ("%d", a[l]);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>如果 a[mid] &lt; s 成立，接下来应该向右继续查找，而此时 mid 是符合答案的，所以要保留，因此 l = mid</p></li><li><p>如果 a[mid] &lt; s 不成立，接下来应该向左继续查找，而此时 mid 是不符合答案的，所以要舍弃，因此 r = mid - 1</p></li><li><p>输出的数一定是要符合要求的，每次查找 l = mid，l一定是符合要求，而 r 不一定，所以输出 l</p></li></ul><h3 id="浮点二分"><a href="#浮点二分" class="headerlink" title="浮点二分"></a>浮点二分</h3><p>浮点二分只能用记录答案方法，而且要设置一个范围使得查找能退出循环</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">const double eps = 1e-8;double l = 0, r = n;while (r - l &gt; eps){    double mid = (l + r) / 2;    if (check (mid))    {        ans = mid;        r = mid - 1;    }    else l = r + 1;}printf ("%d", ans);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><h3 id="A-Can-you-solve-this-equation-•-HDU-2199"><a href="#A-Can-you-solve-this-equation-•-HDU-2199" class="headerlink" title="A Can you solve this equation? • HDU 2199"></a>A <a href="https://vjudge.net/contest/418909#problem/A">Can you solve this equation?</a> • <a href="http://acm.hdu.edu.cn/showproblem.php?pid=2199">HDU 2199</a></h3><h3 id="B-Dating-with-girls-1-•-HDU-2578"><a href="#B-Dating-with-girls-1-•-HDU-2578" class="headerlink" title="B Dating with girls(1) • HDU 2578"></a>B <a href="https://vjudge.net/contest/418909#problem/B">Dating with girls(1)</a> • <a href="http://acm.hdu.edu.cn/showproblem.php?pid=2578">HDU 2578</a></h3><h3 id="C-Aggressive-cows-•-POJ-2456"><a href="#C-Aggressive-cows-•-POJ-2456" class="headerlink" title="C Aggressive cows • POJ 2456"></a>C <a href="https://vjudge.net/contest/418909#problem/C">Aggressive cows</a> • <a href="http://poj.org/problem?id=2456">POJ 2456</a></h3><h3 id="D-Pie-•-POJ-3122"><a href="#D-Pie-•-POJ-3122" class="headerlink" title="D  Pie • POJ 3122"></a>D <a href="https://vjudge.net/contest/418909#problem/D"> Pie</a> • <a href="http://poj.org/problem?id=3122">POJ 3122</a></h3><h3 id="E-River-Hopscotch-•-POJ-3258"><a href="#E-River-Hopscotch-•-POJ-3258" class="headerlink" title="E River Hopscotch • POJ 3258"></a>E <a href="https://vjudge.net/contest/418909#problem/E">River Hopscotch</a> • <a href="http://poj.org/problem?id=3258">POJ 3258</a></h3><h3 id="F-4-Values-whose-Sum-is-0-•-POJ-2785"><a href="#F-4-Values-whose-Sum-is-0-•-POJ-2785" class="headerlink" title="F 4 Values whose Sum is 0 • POJ 2785"></a>F <a href="https://vjudge.net/contest/418909#problem/F">4 Values whose Sum is 0</a> • <a href="http://poj.org/problem?id=2785">POJ 2785</a></h3><h3 id="G-Defuse-the-Bombs-•-Gym-102822D"><a href="#G-Defuse-the-Bombs-•-Gym-102822D" class="headerlink" title="G Defuse the Bombs • Gym 102822D"></a>G <a href="https://vjudge.net/contest/418909#problem/G">Defuse the Bombs</a> • <a href="https://vjudge.net/problem/Gym-102822D/origin">Gym 102822D</a></h3>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 二分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021.1.21</title>
      <link href="2021/01/21/2021-1-21/"/>
      <url>2021/01/21/2021-1-21/</url>
      
        <content type="html"><![CDATA[<h1 id="2021-1-21"><a href="#2021-1-21" class="headerlink" title="2021.1.21"></a>2021.1.21</h1><h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><blockquote><p>并查集是一种树型的数据结构，用于处理一些不相交集合（disjoint sets）的合并及查询问题。常常在使用中以森林来表示。</p><p>——百度百科</p></blockquote><h3 id="主要操作"><a href="#主要操作" class="headerlink" title="主要操作"></a>主要操作</h3><ul><li><p>初始化</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int f[N];void ini(int x){for (int i = 1; i &lt;= x; i++)f[i] = i;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使所有元素都指向自己，将自己作为父节点</p></li><li><p>查找</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int find(int x){    if (x == f[x]) return x;    return find(x);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>合并</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void merge(int x, int y){    f[find(x)] = find(y);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><h4 id="路径压缩"><a href="#路径压缩" class="headerlink" title="路径压缩"></a>路径压缩</h4><blockquote><p>每次查找的时候，如果路径较长，则修改信息，以便下次查找的时候速度更快。</p><p>第一步，找到根结点。</p><p>第二步，修改查找路径上的所有节点，将它们都指向根结点。</p><p>——百度百科</p></blockquote><ul><li><p>查找</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int find(int x){    if (x == f[x]) return x;    f[x] = find (f[x]);    return f[x];}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>或者写成这样：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int find(int x){    if (x != f[x]) f[x] = find (f[x]);    return f[x];}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>再用二元运算符：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int find(int x) { return x == f[x] ? x : (f[x] = find(f[x])); }<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><del>这么写可以让自己看起来更加大佬</del></p></li></ul><h4 id="按秩合并"><a href="#按秩合并" class="headerlink" title="按秩合并"></a>按秩合并</h4><p>将深度小的树合并到深度大的树上</p><ul><li><p>初始化</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void ini(int x){for (int i = 1; i &lt;= x; i++){f[i] = i;rank[i] = 1;//深度都初始化为1}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>合并</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void merge(int x, int y){int a = find(x), b = find(y);//先找到两个根节点if (rank[a] &lt;= rank[b]) f[a] = b;else fa[b] = a;if (rank[a] == rank[b] &amp;&amp; a != b) rank[b]++;//如果深度相同且根节点不同，则新的根节点的深度+1}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因为是小的直接连接到大的根节点，所以合并时小的那一支的深度+1，只有当两者深度相同时才会产生更大的深度</p></li></ul><h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><h4 id="种族并查集"><a href="#种族并查集" class="headerlink" title="种族并查集"></a>种族并查集</h4><p>通过多个并查集将不同的元素归类，并维护相互之间的关系</p><p>例题：<a href="https://www.luogu.com.cn/problem/P2024">洛谷 P2024 食物链</a></p><p>​    用三个并查集分别表示自己、自己的猎物（自己吃的）以及自己的天敌（吃自己的），同时维护三个并查集，通过他们三者的关系判断当前读入数据是否为真</p><h4 id="带权并查集"><a href="#带权并查集" class="headerlink" title="带权并查集"></a>带权并查集</h4><p><u>基于路径压缩</u>，每个节点都记录的是与根节点之间的权值</p><ul><li><p>查找</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int find(int x){if (x != f[x]){int t = f[x];f[x] = find(f[x]);value[x] += value[t];}return f[x];}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>合并</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void merge(int x, int y){    int px = find(x);    int py = find(y);    if (px != py)    {        f[px] = py;        value[px] = -value[x] + value[y] + s;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/OwlllOvO/Hexo-image/20210121213127.PNG"></p></li></ul><h3 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h3><h4 id="A-Ubiquitous-Religions-•-POJ-2524"><a href="#A-Ubiquitous-Religions-•-POJ-2524" class="headerlink" title="A Ubiquitous Religions • POJ 2524"></a>A <a href="https://vjudge.net/contest/418701#problem/A">Ubiquitous Religions</a> • <a href="http://poj.org/problem?id=252">POJ 2524</a></h4><h4 id="B-食物链-•-洛谷-P2024"><a href="#B-食物链-•-洛谷-P2024" class="headerlink" title="B 食物链 • 洛谷 P2024"></a>B <a href="https://vjudge.net/contest/418701#problem/B">食物链</a> • <a href="https://www.luogu.com.cn/problem/P2024">洛谷 P2024</a></h4><h4 id="C-How-Many-Tables-•-HDU-1213"><a href="#C-How-Many-Tables-•-HDU-1213" class="headerlink" title="C How Many Tables • HDU 1213"></a>C <a href="https://vjudge.net/contest/418701#problem/C">How Many Tables</a> • <a href="http://acm.hdu.edu.cn/showproblem.php?pid=1213">HDU 1213</a></h4><h4 id="D-畅通工程-•-HDU-1232"><a href="#D-畅通工程-•-HDU-1232" class="headerlink" title="D 畅通工程 • HDU 1232"></a>D <a href="https://vjudge.net/contest/418701#problem/D">畅通工程</a> • <a href="https://vjudge.net/problem/HDU-1232/origin">HDU 1232</a></h4><h4 id="E-人见人爱A-B-•-HDU-2035"><a href="#E-人见人爱A-B-•-HDU-2035" class="headerlink" title="E 人见人爱A^B •  HDU 2035"></a>E <a href="https://vjudge.net/contest/418701#problem/E">人见人爱A^B</a> • <a href="http://acm.hdu.edu.cn/showproblem.php?pid=2035"> HDU 2035</a></h4><h4 id="F-How-Many-Answers-Are-Wrong-•-HDU-3038"><a href="#F-How-Many-Answers-Are-Wrong-•-HDU-3038" class="headerlink" title="F How Many Answers Are Wrong •  HDU 3038"></a>F <a href="https://vjudge.net/contest/418701#problem/F">How Many Answers Are Wrong</a> • <a href="http://acm.hdu.edu.cn/showproblem.php?pid=3038"> HDU 3038</a></h4>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021.1.20</title>
      <link href="2021/01/20/2021-1-20/"/>
      <url>2021/01/20/2021-1-20/</url>
      
        <content type="html"><![CDATA[<h1 id="2021-1-20"><a href="#2021-1-20" class="headerlink" title="2021.1.20"></a>2021.1.20</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="常用-OJ"><a href="#常用-OJ" class="headerlink" title="常用 OJ"></a>常用 OJ</h3><ul><li><p><a href="https://vjudge.net/">Vjudge</a></p></li><li><p><a href="http://www.nowcoder.com/">nowcoder</a></p></li><li><p><a href="https://pintia.cn/">PTA</a></p></li></ul><h3 id="常用语言-C"><a href="#常用语言-C" class="headerlink" title="常用语言 - C++"></a>常用语言 - C++</h3><p><del>终于用回 C++ 了，上程序设计基础转 C 好累</del></p><p>万能头文件 <code>#include&lt;bits/stdc++.h&gt;</code></p><p>等于以下头文件：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;algorithm&gt;#include &lt;bitset&gt;#include &lt;complex&gt;#include &lt;deque&gt;#include &lt;exception&gt;#include &lt;fstream&gt;#include &lt;functional&gt;#include &lt;iomanip&gt;#include &lt;ios&gt;#include &lt;iosfwd&gt;#include &lt;iostream&gt;#include &lt;istream&gt;#include &lt;iterator&gt;#include &lt;limits&gt;#include &lt;list&gt;#include &lt;locale&gt;#include &lt;map&gt;#include &lt;memory&gt;#include &lt;new&gt;#include &lt;numeric&gt;#include &lt;ostream&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;sstream&gt;#include &lt;stack&gt;#include &lt;stdexcept&gt;#include &lt;streambuf&gt;#include &lt;string&gt;#include &lt;typeinfo&gt;#include &lt;utility&gt;#include &lt;valarray&gt;#include &lt;vector&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>(Visual Studio 不自带万能头文件)</p><h3 id="时间（空间）复杂度"><a href="#时间（空间）复杂度" class="headerlink" title="时间（空间）复杂度"></a>时间（空间）复杂度</h3><p><del>dddd懂的都懂</del></p><h2 id="C-STL"><a href="#C-STL" class="headerlink" title="C++: STL"></a>C++: STL</h2><h3 id="string-•-字符串"><a href="#string-•-字符串" class="headerlink" title="string • 字符串"></a>string • 字符串</h3><h4 id="头文件-include-lt-string-gt"><a href="#头文件-include-lt-string-gt" class="headerlink" title="头文件 : #include<string>"></a>头文件 : <code>#include&lt;string&gt;</code></h4><h4 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h4><ul><li>赋初值</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">string s1 = "1234";string s2;s2 = "1234";<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><p>清除</p><p><code>s1.clear();</code></p></li><li><p>求长度</p><p><code>l = s1.length();</code></p></li><li><p>在尾部插入字符</p><p><code>s1.push_back('x');</code></p></li><li><p>在尾部插入字符串</p><p><code>s1.append(s2);</code></p></li><li><p>从s1中找到字符 ‘x’ 的位置</p><p><code>pos = s1.find('x');</code></p></li><li><p>删除</p><p><code>s1.erase()</code></p></li></ul><h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><h4 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h4><p>​    <code>    vector&lt;int&gt;v1;</code></p><p>​    <code>vector&lt;string&gt;v2("1234");</code></p><p>​    <code>vecotr&lt;int&gt;v3(5,2);</code></p><p>​    <code>vector&lt;int&gt;v4(v3);</code></p><h4 id="常用函数-1"><a href="#常用函数-1" class="headerlink" title="常用函数"></a>常用函数</h4><ul><li><p>在数组的最后添加一个数据</p><p><code>v1.push_back();</code></p></li><li><p>去掉数组的最后一个数据</p><p><code>v1.pop_back();</code></p></li><li><p>得到数组头的引用</p><p><code>v1.front();</code></p></li><li><p>得到数组的最后一个单元的引用</p><p><code>v1.back();</code></p></li><li><p>获取 vector 大小</p><p><code>v1.size();</code></p></li></ul><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><ul><li>随机访问 <strong>O(1)</strong></li><li>删除 <strong>O(n)</strong></li></ul><h3 id="queue-•-FIFO"><a href="#queue-•-FIFO" class="headerlink" title="queue • FIFO"></a>queue • FIFO</h3><h4 id="构造-1"><a href="#构造-1" class="headerlink" title="构造"></a>构造</h4><p>​    <code>queue&lt;int&gt; q;</code></p><h4 id="常用函数-2"><a href="#常用函数-2" class="headerlink" title="常用函数"></a>常用函数</h4><ul><li><p>入队</p><p><code>q.push();</code></p></li><li><p>出队</p><p><code>q.pop();</code></p></li><li><p>首位</p><p><code>q.front();</code></p></li><li><p>末位</p><p><code>q.back();</code></p></li><li><p>大小</p><p><code>q.size();</code></p></li><li><p>判断是否为空</p><p><code>q.empty();</code></p></li></ul><h3 id="stack-•-FILO"><a href="#stack-•-FILO" class="headerlink" title="stack • FILO"></a>stack • FILO</h3><h4 id="构造-2"><a href="#构造-2" class="headerlink" title="构造"></a>构造</h4><p>​    <code>stack&lt;int&gt; s;</code></p><h4 id="常用函数-3"><a href="#常用函数-3" class="headerlink" title="常用函数"></a>常用函数</h4><ul><li><p>入队</p><p><code>s.push();</code></p></li><li><p>出队</p><p><code>s.pop();</code></p></li><li><p>首位</p><p><code>s.top();</code></p></li><li><p>大小</p><p><code>s.size();</code></p></li><li><p>判断是否为空</p><p><code>s.empty();</code></p></li></ul><h3 id="set-•-集合"><a href="#set-•-集合" class="headerlink" title="set • 集合"></a>set • 集合</h3><h4 id="构造-3"><a href="#构造-3" class="headerlink" title="构造"></a>构造</h4><p>​    <code>set&lt;int&gt;s;</code></p><h4 id="常用函数-4"><a href="#常用函数-4" class="headerlink" title="常用函数"></a>常用函数</h4><ul><li><p>插入</p><p><code>s.insert();</code></p></li><li><p>清除</p><p><code>s.erase();</code></p></li><li><p>查找</p><p><code>s.find([int]);</code></p></li><li><p>大小</p><p><code>[int] = s.size();</code></p></li><li><p>清空</p><p><code>s.clear();</code></p></li><li><p>值元素个数</p><p><code>s.count([int]);</code></p></li><li><p>首元</p><p><code>s.begin();</code></p></li><li><p>末元</p><p><code>s.end();</code></p></li><li><p>是否为空</p><p><code>s.empty();</code></p></li></ul><h4 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><ul><li>查询 <strong>O(logn)</strong></li><li>插入 <strong>O(logn)</strong></li><li>删除 <strong>O(logn)</strong></li></ul><h3 id="map-•-key-value"><a href="#map-•-key-value" class="headerlink" title="map • key - value"></a>map • key - value</h3><h4 id="构造-4"><a href="#构造-4" class="headerlink" title="构造"></a>构造</h4><p>​    1.<code>map&lt;int,int&gt;mp;</code></p><p>​    2.<code>map&lt;string,int&gt;mp;</code></p><h4 id="常用函数-5"><a href="#常用函数-5" class="headerlink" title="常用函数"></a>常用函数</h4><ul><li><p>访问</p><p>1.<code>mp[[int]] = [int];</code></p><p>2.<code>mp[[string]] = [int];</code></p></li></ul><h4 id="时间复杂度-2"><a href="#时间复杂度-2" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><ul><li>插入 <strong>O(logn)</strong></li><li>删除 <strong>O(logn)</strong></li></ul><h3 id="list-•-双向链表"><a href="#list-•-双向链表" class="headerlink" title="list • 双向链表"></a>list • 双向链表</h3><h4 id="构造-5"><a href="#构造-5" class="headerlink" title="构造"></a>构造</h4><p>​    <code>list&lt;int&gt;li;</code></p><h4 id="常用函数-6"><a href="#常用函数-6" class="headerlink" title="常用函数"></a>常用函数</h4><ul><li><p>加到末位</p><p><code>li.push_back();</code></p></li><li><p>加到首位</p><p><code>li.push_front();</code></p></li><li><p>去掉末位</p><p><code>li.pop_back();</code></p></li><li><p>去掉首位</p><p><code>li.pop_front();</code></p></li><li><p>插入</p><p><code>li.insert();</code></p></li><li><p>删除</p><p><code>li.erase();</code></p></li></ul><h4 id="时间复杂度-3"><a href="#时间复杂度-3" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><ul><li>随机访问 <strong>×</strong></li><li>插入 <strong>O(1)</strong></li><li>删除 <strong>O(1)</strong></li></ul><h3 id="sort-•-快速排序"><a href="#sort-•-快速排序" class="headerlink" title="sort • 快速排序"></a>sort • 快速排序</h3><p><del>用习惯 sort 后受够了 qsort 的折磨，现在终于回来了</del></p><p><del>qsort 到现在都还没学会，还好期末开卷照着书打</del></p><h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><h3 id="A-Rails-•-POJ-1363"><a href="#A-Rails-•-POJ-1363" class="headerlink" title="A Rails • POJ 1363"></a>A <a href="https://vjudge.net/contest/418487#problem/A">Rails</a> • <a href="https://vjudge.net/problem/POJ-1363/origin">POJ 1363</a></h3><h3 id="B-表达式括号匹配-•-计蒜客-T1655"><a href="#B-表达式括号匹配-•-计蒜客-T1655" class="headerlink" title="B 表达式括号匹配 • 计蒜客 T1655"></a>B <a href="https://vjudge.net/contest/418487#problem/B">表达式括号匹配</a> • <a href="https://vjudge.net/problem/%E8%AE%A1%E8%92%9C%E5%AE%A2-T1655/origin">计蒜客 T1655</a></h3><h3 id="C-Let-the-Balloon-Rise-•-HDU-1004"><a href="#C-Let-the-Balloon-Rise-•-HDU-1004" class="headerlink" title="C  Let the Balloon Rise  • HDU 1004"></a>C <a href="https://vjudge.net/contest/418487#problem/C"> Let the Balloon Rise</a>  • <a href="https://vjudge.net/problem/HDU-1004/origin">HDU 1004</a></h3><h3 id="D-ACboy-needs-your-help-again-•-HDU-1702"><a href="#D-ACboy-needs-your-help-again-•-HDU-1702" class="headerlink" title="D  ACboy needs your help again! • HDU 1702"></a>D <a href="https://vjudge.net/contest/418487#problem/D"> ACboy needs your help again!</a> • <a href="https://vjudge.net/problem/HDU-1702/origin">HDU 1702</a></h3><h3 id="E-排名-•-HDU-1236"><a href="#E-排名-•-HDU-1236" class="headerlink" title="E 排名 • HDU 1236"></a>E <a href="https://vjudge.net/contest/418487#problem/E">排名</a> • <a href="https://vjudge.net/problem/HDU-1236/origin">HDU 1236</a></h3><h3 id="F-人见人爱A-B-•-HDU-2034"><a href="#F-人见人爱A-B-•-HDU-2034" class="headerlink" title="F  人见人爱A-B • HDU 2034"></a>F <a href="https://vjudge.net/contest/418487#problem/F"> 人见人爱A-B</a> • <a href="https://vjudge.net/problem/HDU-2034/origin">HDU 2034</a></h3><h3 id="G-水果-•-HDU-1263"><a href="#G-水果-•-HDU-1263" class="headerlink" title="G 水果 • HDU 1263"></a>G <a href="https://vjudge.net/contest/418487#problem/G">水果</a> • <a href="https://vjudge.net/problem/HDU-1263/origin">HDU 1263</a></h3><h3 id="H-看病要排队-•-HDU-1873"><a href="#H-看病要排队-•-HDU-1873" class="headerlink" title="H 看病要排队 • HDU 1873"></a>H <a href="https://vjudge.net/contest/418487#problem/H">看病要排队</a> • <a href="https://vjudge.net/problem/HDU-1873/origin">HDU 1873</a></h3>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mouseline • 鼠标吸附线条效果</title>
      <link href="2021/01/20/mouseline-shu-biao-xi-fu-xian-tiao-xiao-guo/"/>
      <url>2021/01/20/mouseline-shu-biao-xi-fu-xian-tiao-xiao-guo/</url>
      
        <content type="html"><![CDATA[<p>将以下 JavaScript 代码粘贴到网页的页脚 HTML 中即可实现。</p><p>对于 matery 主题来说，放置在 <code>matery\layout\_partial\footer.ejs</code> 文件末尾即可。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token operator">&lt;</span>script<span class="token operator">&gt;</span><span class="token operator">!</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">function</span> <span class="token function">n</span><span class="token punctuation">(</span><span class="token parameter">n<span class="token punctuation">,</span>e<span class="token punctuation">,</span>t</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span> n<span class="token punctuation">.</span><span class="token function">getAttribute</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token operator">||</span>t<span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">e</span><span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span> document<span class="token punctuation">.</span><span class="token function">getElementsByTagName</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">t</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">var</span> t<span class="token operator">=</span><span class="token function">e</span><span class="token punctuation">(</span><span class="token string">"script"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>o<span class="token operator">=</span>t<span class="token punctuation">.</span>length<span class="token punctuation">,</span>i<span class="token operator">=</span>t<span class="token punctuation">[</span>o<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">return</span><span class="token punctuation">{</span>l<span class="token operator">:</span>o<span class="token punctuation">,</span>z<span class="token operator">:</span><span class="token function">n</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span><span class="token string">"zIndex"</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>o<span class="token operator">:</span><span class="token function">n</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span><span class="token string">"opacity"</span><span class="token punctuation">,</span><span class="token number">.5</span><span class="token punctuation">)</span><span class="token punctuation">,</span>c<span class="token operator">:</span><span class="token function">n</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span><span class="token string">"color"</span><span class="token punctuation">,</span><span class="token string">"0,0,0"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>n<span class="token operator">:</span><span class="token function">n</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span><span class="token string">"count"</span><span class="token punctuation">,</span><span class="token number">99</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">o</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>a<span class="token operator">=</span>m<span class="token punctuation">.</span>width<span class="token operator">=</span>window<span class="token punctuation">.</span>innerWidth<span class="token operator">||</span>document<span class="token punctuation">.</span>documentElement<span class="token punctuation">.</span>clientWidth<span class="token operator">||</span>document<span class="token punctuation">.</span>body<span class="token punctuation">.</span>clientWidth<span class="token punctuation">,</span>c<span class="token operator">=</span>m<span class="token punctuation">.</span>height<span class="token operator">=</span>window<span class="token punctuation">.</span>innerHeight<span class="token operator">||</span>document<span class="token punctuation">.</span>documentElement<span class="token punctuation">.</span>clientHeight<span class="token operator">||</span>document<span class="token punctuation">.</span>body<span class="token punctuation">.</span>clientHeight<span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">i</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>r<span class="token punctuation">.</span><span class="token function">clearRect</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>a<span class="token punctuation">,</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> n<span class="token punctuation">,</span>e<span class="token punctuation">,</span>t<span class="token punctuation">,</span>o<span class="token punctuation">,</span>m<span class="token punctuation">,</span>l<span class="token punctuation">;</span>s<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">i<span class="token punctuation">,</span>x</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token punctuation">.</span>x<span class="token operator">+=</span>i<span class="token punctuation">.</span>xa<span class="token punctuation">,</span>i<span class="token punctuation">.</span>y<span class="token operator">+=</span>i<span class="token punctuation">.</span>ya<span class="token punctuation">,</span>i<span class="token punctuation">.</span>xa<span class="token operator">*=</span>i<span class="token punctuation">.</span>x<span class="token operator">&gt;</span>a<span class="token operator">||</span>i<span class="token punctuation">.</span>x<span class="token operator">&lt;</span><span class="token number">0</span><span class="token operator">?</span><span class="token operator">-</span><span class="token number">1</span><span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">,</span>i<span class="token punctuation">.</span>ya<span class="token operator">*=</span>i<span class="token punctuation">.</span>y<span class="token operator">&gt;</span>c<span class="token operator">||</span>i<span class="token punctuation">.</span>y<span class="token operator">&lt;</span><span class="token number">0</span><span class="token operator">?</span><span class="token operator">-</span><span class="token number">1</span><span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">,</span>r<span class="token punctuation">.</span><span class="token function">fillRect</span><span class="token punctuation">(</span>i<span class="token punctuation">.</span>x<span class="token operator">-</span><span class="token number">.5</span><span class="token punctuation">,</span>i<span class="token punctuation">.</span>y<span class="token operator">-</span><span class="token number">.5</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>e<span class="token operator">=</span>x<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>e<span class="token operator">&lt;</span>u<span class="token punctuation">.</span>length<span class="token punctuation">;</span>e<span class="token operator">++</span><span class="token punctuation">)</span>n<span class="token operator">=</span>u<span class="token punctuation">[</span>e<span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">null</span><span class="token operator">!==</span>n<span class="token punctuation">.</span>x<span class="token operator">&amp;&amp;</span><span class="token keyword">null</span><span class="token operator">!==</span>n<span class="token punctuation">.</span>y<span class="token operator">&amp;&amp;</span><span class="token punctuation">(</span>o<span class="token operator">=</span>i<span class="token punctuation">.</span>x<span class="token operator">-</span>n<span class="token punctuation">.</span>x<span class="token punctuation">,</span>m<span class="token operator">=</span>i<span class="token punctuation">.</span>y<span class="token operator">-</span>n<span class="token punctuation">.</span>y<span class="token punctuation">,</span>l<span class="token operator">=</span>o<span class="token operator">*</span>o<span class="token operator">+</span>m<span class="token operator">*</span>m<span class="token punctuation">,</span>l<span class="token operator">&lt;</span>n<span class="token punctuation">.</span>max<span class="token operator">&amp;&amp;</span><span class="token punctuation">(</span>n<span class="token operator">===</span>y<span class="token operator">&amp;&amp;</span>l<span class="token operator">&gt;=</span>n<span class="token punctuation">.</span>max<span class="token operator">/</span><span class="token number">2</span><span class="token operator">&amp;&amp;</span><span class="token punctuation">(</span>i<span class="token punctuation">.</span>x<span class="token operator">-=</span><span class="token number">.03</span><span class="token operator">*</span>o<span class="token punctuation">,</span>i<span class="token punctuation">.</span>y<span class="token operator">-=</span><span class="token number">.03</span><span class="token operator">*</span>m<span class="token punctuation">)</span><span class="token punctuation">,</span>t<span class="token operator">=</span><span class="token punctuation">(</span>n<span class="token punctuation">.</span>max<span class="token operator">-</span>l<span class="token punctuation">)</span><span class="token operator">/</span>n<span class="token punctuation">.</span>max<span class="token punctuation">,</span>r<span class="token punctuation">.</span><span class="token function">beginPath</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>r<span class="token punctuation">.</span>lineWidth<span class="token operator">=</span>t<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">,</span>r<span class="token punctuation">.</span>strokeStyle<span class="token operator">=</span><span class="token string">"rgba("</span><span class="token operator">+</span>d<span class="token punctuation">.</span>c<span class="token operator">+</span><span class="token string">","</span><span class="token operator">+</span><span class="token punctuation">(</span>t<span class="token operator">+</span><span class="token number">.2</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">")"</span><span class="token punctuation">,</span>r<span class="token punctuation">.</span><span class="token function">moveTo</span><span class="token punctuation">(</span>i<span class="token punctuation">.</span>x<span class="token punctuation">,</span>i<span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">,</span>r<span class="token punctuation">.</span><span class="token function">lineTo</span><span class="token punctuation">(</span>n<span class="token punctuation">.</span>x<span class="token punctuation">,</span>n<span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">,</span>r<span class="token punctuation">.</span><span class="token function">stroke</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">x</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">var</span> a<span class="token punctuation">,</span>c<span class="token punctuation">,</span>u<span class="token punctuation">,</span>m<span class="token operator">=</span>document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">"canvas"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>d<span class="token operator">=</span><span class="token function">t</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>l<span class="token operator">=</span><span class="token string">"c_n"</span><span class="token operator">+</span>d<span class="token punctuation">.</span>l<span class="token punctuation">,</span>r<span class="token operator">=</span>m<span class="token punctuation">.</span><span class="token function">getContext</span><span class="token punctuation">(</span><span class="token string">"2d"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>x<span class="token operator">=</span>window<span class="token punctuation">.</span>requestAnimationFrame<span class="token operator">||</span>window<span class="token punctuation">.</span>webkitRequestAnimationFrame<span class="token operator">||</span>window<span class="token punctuation">.</span>mozRequestAnimationFrame<span class="token operator">||</span>window<span class="token punctuation">.</span>oRequestAnimationFrame<span class="token operator">||</span>window<span class="token punctuation">.</span>msRequestAnimationFrame<span class="token operator">||</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span><span class="token punctuation">{</span>window<span class="token punctuation">.</span><span class="token function">setTimeout</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span><span class="token number">1e3</span><span class="token operator">/</span><span class="token number">45</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">,</span>w<span class="token operator">=</span>Math<span class="token punctuation">.</span>random<span class="token punctuation">,</span>y<span class="token operator">=</span><span class="token punctuation">{</span>x<span class="token operator">:</span><span class="token keyword">null</span><span class="token punctuation">,</span>y<span class="token operator">:</span><span class="token keyword">null</span><span class="token punctuation">,</span>max<span class="token operator">:</span><span class="token number">2e4</span><span class="token punctuation">}</span><span class="token punctuation">;</span>m<span class="token punctuation">.</span>id<span class="token operator">=</span>l<span class="token punctuation">,</span>m<span class="token punctuation">.</span>style<span class="token punctuation">.</span>cssText<span class="token operator">=</span><span class="token string">"position:fixed;top:0;left:0;z-index:"</span><span class="token operator">+</span>d<span class="token punctuation">.</span>z<span class="token operator">+</span><span class="token string">";opacity:"</span><span class="token operator">+</span>d<span class="token punctuation">.</span>o<span class="token punctuation">,</span><span class="token function">e</span><span class="token punctuation">(</span><span class="token string">"body"</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">o</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>window<span class="token punctuation">.</span>onresize<span class="token operator">=</span>o<span class="token punctuation">,</span>window<span class="token punctuation">.</span><span class="token function-variable function">onmousemove</span><span class="token operator">=</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span><span class="token punctuation">{</span>n<span class="token operator">=</span>n<span class="token operator">||</span>window<span class="token punctuation">.</span>event<span class="token punctuation">,</span>y<span class="token punctuation">.</span>x<span class="token operator">=</span>n<span class="token punctuation">.</span>clientX<span class="token punctuation">,</span>y<span class="token punctuation">.</span>y<span class="token operator">=</span>n<span class="token punctuation">.</span>clientY<span class="token punctuation">}</span><span class="token punctuation">,</span>window<span class="token punctuation">.</span><span class="token function-variable function">onmouseout</span><span class="token operator">=</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>y<span class="token punctuation">.</span>x<span class="token operator">=</span><span class="token keyword">null</span><span class="token punctuation">,</span>y<span class="token punctuation">.</span>y<span class="token operator">=</span><span class="token keyword">null</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> s<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>f<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>d<span class="token punctuation">.</span>n<span class="token operator">&gt;</span>f<span class="token punctuation">;</span>f<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">var</span> h<span class="token operator">=</span><span class="token function">w</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">*</span>a<span class="token punctuation">,</span>g<span class="token operator">=</span><span class="token function">w</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">*</span>c<span class="token punctuation">,</span>v<span class="token operator">=</span><span class="token number">2</span><span class="token operator">*</span><span class="token function">w</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>p<span class="token operator">=</span><span class="token number">2</span><span class="token operator">*</span><span class="token function">w</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>s<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span>x<span class="token operator">:</span>h<span class="token punctuation">,</span>y<span class="token operator">:</span>g<span class="token punctuation">,</span>xa<span class="token operator">:</span>v<span class="token punctuation">,</span>ya<span class="token operator">:</span>p<span class="token punctuation">,</span>max<span class="token operator">:</span><span class="token number">6e3</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span>u<span class="token operator">=</span>s<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">i</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Creating my blog</title>
      <link href="2021/01/20/creating-my-blog/"/>
      <url>2021/01/20/creating-my-blog/</url>
      
        <content type="html"><![CDATA[<h1 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h1><h2 id="为什么选择-Hexo"><a href="#为什么选择-Hexo" class="headerlink" title="为什么选择 Hexo"></a>为什么选择 Hexo</h2><p>以前第一次建站的时候因为什么都不知道，就跟着一个教程做了 Wordpress 网站。Wordpress 的优点很明显——非常的方便。不仅建站的时候直接选择 Wordpress 就完成了，之后再在控制台维护网站就行。但之后因为上学，就没再去维护，服务器也没有续，网站就这么没有了..</p><p>这次 ACM 寒假训练，要求我们创建自己的博客，我想着自己都已经创建过自己的网站，就不想用 CSDN、博客园之类的博客，于是又准备重新搭建网站。这时候我了解到了 Hexo，这是一个静态网站，把文件都放在 Github 上，由 Github 托管。这是 Hexo 的一大优点，这样一来不仅不收费，而且只要 Github 还在，网站就不会消失。但这不是我选择 Hexo 的原因。我选择 Hexo 的主要原因还是看到很多非常精美的博客都是用的 Hexo，而 Wordpress 的网站实在找不到好看的主题，于是我也想搭建 Hexo 网站。</p><p>一开始用 Hexo 觉得很麻烦，什么东西都是在文件里修改参数，对网站的操作都要用命令执行，不像 Wordpress 有后台可以非常方便、直观地维护网站。但是用久了之后，学会了之后发现，Hexo 这样才更加方便。因为所有文件都在本地，网站的任何属性都写在文件里面了，想要修改什么直接在文件里修改，更加的灵活，这也是 Hexo 能做得更精美，更加个性化的原因。</p><h2 id="Hexo-建站过程"><a href="#Hexo-建站过程" class="headerlink" title="Hexo 建站过程"></a>Hexo 建站过程</h2><p>写这些不仅是记录我建站的整个过程，还详细地记录我对网站的操作和修改，以后万一需要重做网站，也可以帮助自己回忆 XD</p><h3 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h3><ul><li><p>macOS 切换 Root 用户</p><ul><li>终端输入指令：<code>sudo su</code></li><li>输入用户密码</li></ul></li><li><p>安装 Node.js</p><ul><li>访问网站 <a href="https://nodejs.org/en/">Node.js</a> 下载最新版本</li><li>安装</li><li>安装完成后即可在终端（cmd）输入指令：<ul><li><code>node -v </code>：查看已安装的 Node 版本，查看是否安装成功</li><li><code>npm -v</code>：查看已安装的 npm 版本，查看是否安装成功</li></ul></li></ul></li><li><p>安装淘宝 cnpm 管理器（加速）</p><ul><li><code>npm install -g cnpm --registry=http://registry.npm.taobao.org</code></li><li>自动安装</li><li><code>cnpm -v</code>：查看已安装的 cnpm 版本，查看是否安装成功</li></ul></li></ul><h3 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h3><ul><li><p>安装 Hexo 框架</p><ul><li><code>cnpm install -g hexo-cli</code></li><li>自动安装</li><li><code>hexo -v</code>：查看已安装的 Hexo 版本，查看是否安装成功</li></ul></li><li><p>建立 Blog 文件夹</p><ul><li><code>mkdir Blog</code>：创建 Blog 文件夹</li><li><code>cd blog</code>：进入 Blog 文件夹</li><li>之后要是出现问题，直接删除 Blog 文件夹从头开始重新做就行</li></ul></li><li><p>Windows 安装 Git</p><ul><li>访问 <a href="https://git-scm.com/">Git</a>，下载 Git 并安装</li><li>之后用 Git Bash 输命令或者继续用 cmd</li></ul></li><li><p>创建 Hexo</p><ul><li>macOS：<code>sudo hexo init</code>：用管理员权限初始化 Hexo</li><li>Windows：<code>hexo init</code>：初始化 Hexo</li></ul></li></ul><h3 id="Hexo-操作"><a href="#Hexo-操作" class="headerlink" title="Hexo 操作"></a>Hexo 操作</h3><ul><li><p>启动 Hexo（本地预览）</p><ul><li><code>hexo s</code> s: start 启动 Hexo</li><li>复制显示的网址用浏览器打开即可</li><li><code>Ctrl + C</code> <code>Y</code> 停止</li></ul></li><li><p>新建文章</p><ul><li><code>hexo n "title"</code> n: new 新建文章</li><li>在 <code>Blog\source\_posts\</code> 中找到新建的 .md 文件用 Typora 编辑</li></ul></li><li><p>生成 Hexo</p><ul><li><code>hexo clean</code>：清理 Hexo</li><li><code>hexo g</code>：生成 Hexo</li></ul></li><li><p>先生成，应用修改，后启动查看效果</p></li></ul><h3 id="将博客部署到远端（Github）"><a href="#将博客部署到远端（Github）" class="headerlink" title="将博客部署到远端（Github）"></a>将博客部署到远端（Github）</h3><ul><li><p>访问 <a href="https://github.com/">Github</a></p></li><li><p>注册/登录 账号</p></li><li><p>新建仓库</p><ul><li>点击右上角 <code>+</code></li><li>点击 <code>New repository</code></li><li>Repository name 填写：Username.github.io</li><li>点击 <code>create repository</code></li></ul></li><li><p><code>cnpm install --save hexo-deployer-git</code> ：在 Blog 目录下安装 Git 部署插件</p></li><li><p>自动安装 忽略 Warning</p></li><li><p>编辑 <code>Blog\_config.yml</code> 文件</p><ul><li><p>下拉找到 <code>\# Deployment</code></p><pre class="line-numbers language-none"><code class="language-none">deploy:  type: git  repo: https://github.com/Username/Username.github.io  branch: master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>如果 type 后有单引号’’，git 填在单引号里面</p><p>repo 填的是 Github Repo 的地址，复制过来就行</p></li><li><p>保存并退出</p></li></ul></li><li><p><code>hexo d</code> d: deploy 部署到远端</p><ul><li>第一次部署要求输入 Github 账号密码</li></ul></li><li><p>访问 Username.github.io 即可</p></li></ul><h3 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h3><ul><li><p><code>git clone 主题网址.git themes/主题名</code></p></li><li><p>编辑 <code>Blog\_config.yml</code> 文件</p><ul><li><p>下拉找到 <code>theme</code></p></li><li><p>修改为 <code>theme: 主题名</code></p></li><li><p>重新清理，生成，启动</p></li><li><p><code>hexo clean</code></p></li><li><p><code>hexo g</code></p></li><li><p><code>hexo s</code></p></li></ul></li></ul><h2 id="Hexo-个性化定制"><a href="#Hexo-个性化定制" class="headerlink" title="Hexo 个性化定制"></a>Hexo 个性化定制</h2><h3 id="将目录背景设为透明"><a href="#将目录背景设为透明" class="headerlink" title="将目录背景设为透明"></a>将目录背景设为透明</h3><p><code>themes/matery/source/libs/materialize/materialize.min.css</code> 中搜索 <code>.card</code>，有一个结果的 <code>.card</code> 后面直接跟着 <code>{</code>。在这个大括号中删除原来的背景，添加 <code>background-color: rgba(255,255,255, 0) !important;</code></p><p>（主要是在 <code>element.style</code> 里有将背景设为白色，但是找不到这个在哪，就用 <code>! important</code> 强制将背景改为透明，曲线救国）</p>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2021/01/20/hello-world/"/>
      <url>2021/01/20/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
