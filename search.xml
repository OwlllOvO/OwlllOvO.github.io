<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>AC 自动机</title>
      <link href="2021/05/13/2021-5-13-ac-zi-dong-ji/"/>
      <url>2021/05/13/2021-5-13-ac-zi-dong-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="AC-自动机"><a href="#AC-自动机" class="headerlink" title="AC 自动机"></a>AC 自动机</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>AC 自动机是以 Trie 的结构为基础，结合 KMP 的思想建立的。</p><p>简单来说，建立一个 AC 自动机有两个步骤：</p><ol><li>基础的 Trie 结构：将所有的模式串构成一棵 Trie。</li><li>KMP 的思想：对 Trie 树上所有的结点构造失配指针。</li></ol><p>然后就可以利用它进行多模式匹配了。</p><h2 id="构建字典树"><a href="#构建字典树" class="headerlink" title="构建字典树"></a>构建字典树</h2><p>AC 自动机在初始时会将若干个模式串丢到一个 Trie 里，然后在 Trie 上建立 AC 自动机。这个 Trie 就是普通的 Trie，该怎么建怎么建。</p><p>这里需要仔细解释一下 Trie 的结点的含义，尽管这很小儿科，但在之后的理解中极其重要。Trie 中的结点表示的是某个模式串的前缀。我们在后文也将其称作状态。一个结点表示一个状态，Trie 的边就是状态的转移。</p><p>形式化地说，对于若干个模式串 $s_{1}, \ s_{2}, \ \cdots, \ s_{n}$，将它们构建一棵字典树后的所有状态的集合记作 $Q$。</p><h2 id="失配指针"><a href="#失配指针" class="headerlink" title="失配指针"></a>失配指针</h2><p>AC 自动机利用一个 fail 指针来辅助多模式串的匹配。</p><p>状态 $u$ 的 fail 指针指向另一个状态 $v$，其中 $v \ \in \ Q$，且 $v$ 是 $u$ 的最长后缀（即在若干个后缀状态中取最长的一个作为 fail 指针）。fail 指针与 KMP 中的 next 指针：</p><ul><li>共同点：两者同样是在失配的时候用于跳转的指针。</li><li>不同点：next 指针求的是最长 Border（即最长的相同前后缀），而 fail 指针指向所有模式串的前缀中匹配当前状态的最长后缀。</li></ul><p>因为 KMP 只对一个模式串做匹配，而 AC 自动机要对多个模式串做匹配。有可能 fail 指针指向的结点对应着另一个模式串，两者前缀不同。</p><p>AC 自动机的失配指针指向当前状态的最长后缀状态</p><p>AC 自动机在做匹配时，同一位上可匹配多个模式串。</p><h3 id="构建指针"><a href="#构建指针" class="headerlink" title="构建指针"></a>构建指针</h3><p>下面介绍构建 fail 指针的基础思想（强调！基础思想！基础！）：</p><p>构建 fail 指针，可以参考 KMP 中构造 Next 指针的思想。</p><p>考虑字典树中当前的结点 $u$ ，$u$ 的父结点是 $p$，$p$ 通过字符 <code>c</code> 的边指向 $u$，即 trie[p, c] = u。假设深度小于 $u$ 的所有结点的 fail 指针都已求得。</p><ol><li>如果 trie[fail[p], c] 存在：则让 u 的 fail 指针指向 trie[fail[p], c]。相当于在 $p$ 和 fail[p] 后面加一个字符 <code>c</code>，分别对应 $u$ 和 fail[u]。</li><li>如果 trie[fail[p], c] 不存在：那么我们继续找到 trie[fail[fail[p]], c]。重复 1 的判断过程，一直跳 fail 指针直到根结点。</li><li>如果真的没有，就让 fail 指针指向根结点。</li></ol><p>如此即完成了 fail[u] 的构建。</p><h2 id="字典树与字典图"><a href="#字典树与字典图" class="headerlink" title="字典树与字典图"></a>字典树与字典图</h2><h3 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h3><p>该函数的目标有两个，一个是构建 fail 指针，一个是构建自动机。参数如下：</p><ol><li><code>tr[u,c]</code>：有两种理解方式。我们可以简单理解为字典树上的一条边，即 trie[u, c]；也可以理解为从状态（结点）$u$ 后加一个字符 <code>c</code> 到达的状态（结点），即一个状态转移函数 trans(u, c)。下文中我们将用第二种理解方式继续讲解。</li><li>队列 <code>q</code>：用于 BFS 遍历字典树。</li><li><code>fail[u]</code>：结点 $u$ 的 fail 指针。</li></ol><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void build(){  for (int i = 0; i &lt; 26; i++)    if (tr[0][i]) q.push(tr[0][i]);  while (q.size())  {    int u = q.front();    q.pop();    for (int i = 0; i &lt; 26; i++)    {      if (tr[u][i])        fail[tr[u][i]] = tr[fail[u]][i], q.push(tr[u][i]);      else        tr[u][i] = tr[fail[u]][i];    }  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>解释一下上面的代码：build 函数将结点按 BFS 顺序入队，依次求 fail 指针。这里的字典树根结点为 0，我们将根结点的子结点一一入队。若将根结点入队，则在第一次 BFS 的时候，会将根结点儿子的 fail 指针标记为本身。因此我们将根结点的儿子一一入队，而不是将根结点入队。</p><p>然后开始 BFS：每次取出队首的结点 u（fail[u] 在之前的 BFS 过程中已求得），然后遍历字符集（这里是 0-25，对应 a-z，即 $u$ 的各个子节点）：</p><ol><li>如果 trans[u][i] 存在，我们就将 trans[u][i] 的 fail 指针赋值为 trans[fail[u]][i]。这里似乎有一个问题。根据之前的讲解，我们应该用 while 循环，不停的跳 fail 指针，判断是否存在字符 <code>i</code> 对应的结点，然后赋值，但是这里通过特殊处理简化了这些代码。</li><li>否则，令 trans[u][i] 指向 trans[fail[u]][i] 的状态。</li></ol><p>这里的处理是，通过 <code>else</code> 语句的代码修改字典树的结构。没错，它将不存在的字典树的状态链接到了失配指针的对应状态。在原字典树中，每一个结点代表一个字符串 S，是某个模式串的前缀。而在修改字典树结构后，尽管增加了许多转移关系，但结点（状态）所代表的字符串是不变的。</p><p>而 trans[S][c] 相当于是在 S 后添加一个字符 <code>c</code> 变成另一个状态 S’。如果 S’ 存在，说明存在一个模式串的前缀是 S’，否则我们让 trans[S][c] 指向 trans[fail[S]][c]。由于 fail[S] 对应的字符串是 S 的后缀，因此 trans[fail[S]][c] 对应的字符串也是 S’ 的后缀。</p><p>换言之在 Trie 上跳转的时侯，我们只会从 S 跳转到 S’，相当于匹配了一个 S’；但在 AC 自动机上跳转的时侯，我们会从 S 跳转到 S’ 的后缀，也就是说我们匹配一个字符 <code>c</code>，然后舍弃 S 的部分前缀。舍弃前缀显然是能匹配的。那么 fail 指针呢？它也是在舍弃前缀啊！试想一下，如果文本串能匹配 S，显然它也能匹配 S 的后缀。所谓的 fail 指针其实就是 S 的一个后缀集合。</p><p><code>tr</code> 数组还有另一种比较简单的理解方式：如果在位置 $u$ 失配，我们会跳转到 fail[u] 的位置。所以我们可能沿着 fail 数组跳转多次才能来到下一个能匹配的位置。所以我们可以用 <code>tr</code> 数组直接记录记录下一个能匹配的位置，这样就能节省下很多时间。</p><p>这样修改字典树的结构，使得匹配转移更加完善。同时它将 fail 指针跳转的路径做了压缩（就像并查集的路径压缩），使得本来需要跳很多次 fail 指针变成跳一次。</p><h3 id="多模式匹配"><a href="#多模式匹配" class="headerlink" title="多模式匹配"></a>多模式匹配</h3><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int query(char *t){  int u = 0, res = 0;  for (int i = 1; t[i]; i++)  {    u = tr[u][t[i] - 'a'];  // 转移    for (int j = u; j &amp;&amp; e[j] != -1; j = fail[j])    {      res += e[j], e[j] = -1;    }  }  return res;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里 $u$ 作为字典树上当前匹配到的结点，<code>res</code> 即返回的答案。循环遍历匹配串，$u$ 在字典树上跟踪当前字符。利用 fail 指针找出所有匹配的模式串，累加到答案中。然后清零。在上文中我们分析过，字典树的结构其实就是一个 trans 函数，而构建好这个函数后，在匹配字符串的过程中，我们会舍弃部分前缀达到最低限度的匹配。fail 指针则指向了更多的匹配状态。</p>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> AC 自动机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MathJax</title>
      <link href="2021/05/10/2021-5-10-mathjax/"/>
      <url>2021/05/10/2021-5-10-mathjax/</url>
      
        <content type="html"><![CDATA[<h1 id="MathJax"><a href="#MathJax" class="headerlink" title="MathJax"></a>MathJax</h1><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><h3 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h3><ul><li>行内公式（Inline）<code>$...$</code></li><li>单独公式（Display）<code>$$...$$</code></li></ul><h3 id="运算符号"><a href="#运算符号" class="headerlink" title="运算符号"></a>运算符号</h3><table><thead><tr><th>符号</th><th>命令</th></tr></thead><tbody><tr><td>$+$</td><td><code>+</code></td></tr><tr><td>$-$</td><td><code>-</code></td></tr><tr><td>$\times$</td><td><code>\times</code></td></tr><tr><td>$\div$</td><td><code>\div</code></td></tr><tr><td>$\cdot$</td><td><code>\cdot</code></td></tr><tr><td>$\cdots$</td><td><code>\cdots</code></td></tr><tr><td>$\pm$</td><td><code>\pm</code></td></tr><tr><td>$=$</td><td><code>=</code></td></tr><tr><td>$&gt;$</td><td><code>&gt;</code></td></tr><tr><td>$&lt;$</td><td><code>&lt;</code></td></tr><tr><td>$\neq$</td><td><code>\neq</code></td></tr><tr><td>$\leq$</td><td><code>\leq</code></td></tr><tr><td>$\geq$</td><td><code>\geq</code></td></tr><tr><td>$\sum$</td><td><code>\sum</code></td></tr><tr><td>$\prod$</td><td><code>\prod</code></td></tr><tr><td>$\int$</td><td><code>\int</code></td></tr><tr><td>$\iint$</td><td><code>\iint</code></td></tr><tr><td>$\iiint$</td><td><code>\iiint</code></td></tr></tbody></table><h3 id="希腊字母"><a href="#希腊字母" class="headerlink" title="希腊字母"></a>希腊字母</h3><table><thead><tr><th>字母</th><th>命令</th><th>字母</th><th>命令</th></tr></thead><tbody><tr><td>$\alpha$</td><td><code>\alpha</code></td><td>$\Alpha$</td><td><code>\Alpha</code></td></tr><tr><td>$\beta$</td><td><code>\beta</code></td><td>$\Beta$</td><td><code>\Beta</code></td></tr><tr><td>$\gamma$</td><td><code>\gamma</code></td><td>$\Gamma$</td><td><code>\Gamma</code></td></tr><tr><td>$\delta$</td><td><code>\delta</code></td><td>$\Delta$</td><td><code>\Delta</code></td></tr><tr><td>$\epsilon$</td><td><code>\epsilon</code></td><td>$\Epsilon$</td><td><code>\Epsilon</code></td></tr><tr><td>$\zeta$</td><td><code>\zeta</code></td><td>$\Zeta$</td><td><code>\Zeta</code></td></tr><tr><td>$\eta$</td><td><code>\eta</code></td><td>$\Eta$</td><td><code>\Eta</code></td></tr><tr><td>$\theta$</td><td><code>\theta</code></td><td>$\Theta$</td><td><code>\Theta</code></td></tr><tr><td>$\iota$</td><td><code>\iota</code></td><td>$\Iota$</td><td><code>\Iota</code></td></tr><tr><td>$\kappa$</td><td><code>\kappa</code></td><td>$\Kappa$</td><td><code>\Kappa</code></td></tr><tr><td>$\lambda$</td><td><code>\lambda</code></td><td>$\Lambda$</td><td><code>\Lambda</code></td></tr><tr><td>$\mu$</td><td><code>\mu</code></td><td>$\Mu$</td><td><code>\Mu</code></td></tr><tr><td>$\nu$</td><td><code>\nu</code></td><td>$\Nu$</td><td><code>\Nu</code></td></tr><tr><td>$\xi$</td><td><code>\xi</code></td><td>$\Xi$</td><td><code>\Xi</code></td></tr><tr><td>$\pi$</td><td><code>\pi</code></td><td>$\Pi$</td><td><code>\Pi</code></td></tr><tr><td>$\rho$</td><td><code>\rho</code></td><td>$\Rho$</td><td><code>\Rho</code></td></tr><tr><td>$\sigma$</td><td><code>\sigma</code></td><td>$\Sigma$</td><td><code>\Sigma</code></td></tr><tr><td>$\tau$</td><td><code>\tau</code></td><td>$\Tau$</td><td><code>\Tau</code></td></tr><tr><td>$\upsilon$</td><td><code>\upsilon</code></td><td>$\Upsilon$</td><td><code>\Upsilon</code></td></tr><tr><td>$\phi$</td><td><code>\phi</code></td><td>$\Phi$</td><td><code>\Phi</code></td></tr><tr><td>$\chi$</td><td><code>\chi</code></td><td>$\Chi$</td><td><code>\Chi</code></td></tr><tr><td>$\psi$</td><td><code>\psi</code></td><td>$\Psi$</td><td><code>\Psi</code></td></tr><tr><td>$\omega$</td><td><code>\omega</code></td><td>$\Omega$</td><td><code>\Omega</code></td></tr></tbody></table><h3 id="括号"><a href="#括号" class="headerlink" title="括号"></a>括号</h3><table><thead><tr><th>显示</th><th>命令</th></tr></thead><tbody><tr><td>$($</td><td><code>(</code></td></tr><tr><td>$)$</td><td><code>)</code></td></tr><tr><td>$[$</td><td><code>[</code></td></tr><tr><td>$]$</td><td><code>]</code></td></tr><tr><td>$\langle$</td><td><code>\langle</code></td></tr><tr><td>$\rangle$</td><td><code>\rangle</code></td></tr><tr><td>$\lbrace$</td><td><code>\lbrace</code></td></tr><tr><td>$\rbrace$</td><td><code>\rbrace</code></td></tr><tr><td>$\lceil$</td><td><code>\lceil</code></td></tr><tr><td>$\rceil$</td><td><code>\rceil</code></td></tr><tr><td>$\lfloor$</td><td><code>\lfloor</code></td></tr><tr><td>$\rfloor$</td><td><code>\rfloor</code></td></tr></tbody></table><h3 id="位置"><a href="#位置" class="headerlink" title="位置"></a>位置</h3><ul><li>上标 <code>^{}</code> $a^{b}$ <code>a^{b}</code></li><li>下标 <code>_{}</code> $a_{b}$ <code>a_{b}</code></li><li>分数 <code>\frac{}{}</code> $\frac{a}{b}$ <code>\frac{a}{b}</code></li><li>根式 <code>\sqrt[]{}</code> $\sqrt[a]{b}$ <code>\sqrt[a]{b}</code></li><li>空格<ul><li>小空格 <code>\ </code> $a\ b$ <code>a\ b</code></li><li>四格空格 <code>\quad</code> $a\quad b$ <code>a\quad b</code></li></ul></li><li>分段 <code>\\</code></li></ul><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><table><thead><tr><th>显示</th><th>代码</th></tr></thead><tbody><tr><td>$\sin$</td><td><code>\sin</code></td></tr><tr><td>$\cos$</td><td><code>\cos</code></td></tr><tr><td>$\tan$</td><td><code>\tan</code></td></tr><tr><td>$\ln$</td><td><code>\ln</code></td></tr><tr><td>$\max$</td><td><code>\max</code></td></tr><tr><td>$\min$</td><td><code>\min</code></td></tr></tbody></table><h3 id="特殊符号"><a href="#特殊符号" class="headerlink" title="特殊符号"></a>特殊符号</h3><table><thead><tr><th>显示</th><th>代码</th></tr></thead><tbody><tr><td>$\infty$</td><td><code>\infty</code></td></tr><tr><td>$\cup$</td><td><code>\cup</code></td></tr><tr><td>$\cap$</td><td><code>\cap</code></td></tr><tr><td>$\subset$</td><td><code>\subset</code></td></tr><tr><td>$\subseteq$</td><td><code>\subseteq</code></td></tr><tr><td>$\supset$</td><td><code>\supset</code></td></tr><tr><td>$\supseteq$</td><td><code>\supseteq</code></td></tr><tr><td>$\in$</td><td><code>\in</code></td></tr><tr><td>$\notin$</td><td><code>\notin</code></td></tr><tr><td>$\varnothing$</td><td><code>\varnothing</code></td></tr><tr><td>$\forall$</td><td><code>\forall</code></td></tr><tr><td>$\exists$</td><td><code>\exists</code></td></tr><tr><td>$\lnot$</td><td><code>\lnot</code></td></tr><tr><td>$\nabla$</td><td><code>\nabla</code></td></tr><tr><td>$\partial$</td><td><code>\partial</code></td></tr></tbody></table><h3 id="矢量"><a href="#矢量" class="headerlink" title="矢量"></a>矢量</h3><ul><li>$\vec{a}$ <code>\vec{a}</code></li></ul><h3 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h3><p>起始标记 <code>\begin{matrix}</code>，结束标记 <code>\end{matrix}</code><br>每一行末尾标记 <code>\\</code>，行间元素之间以 <code>&amp;</code> 分隔</p><p>$$\begin{matrix}<br>1&amp;0&amp;0\<br>0&amp;1&amp;0\<br>0&amp;0&amp;1\<br>\end{matrix}$$</p><pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby">$$\<span class="token keyword">begin</span><span class="token punctuation">{</span>matrix<span class="token punctuation">}</span><span class="token number">1</span><span class="token operator">&amp;</span><span class="token number">0</span><span class="token operator">&amp;</span><span class="token number">0</span>\\<span class="token number">0</span><span class="token operator">&amp;</span><span class="token number">1</span><span class="token operator">&amp;</span><span class="token number">0</span>\\<span class="token number">0</span><span class="token operator">&amp;</span><span class="token number">0</span><span class="token operator">&amp;</span><span class="token number">1</span>\\\<span class="token keyword">end</span><span class="token punctuation">{</span>matrix<span class="token punctuation">}</span>$$<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> MathJax </tag>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速幂</title>
      <link href="2021/05/10/2021-5-10-kuai-su-mi/"/>
      <url>2021/05/10/2021-5-10-kuai-su-mi/</url>
      
        <content type="html"><![CDATA[<h1 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>快速幂，二进制取幂（Binary Exponentiation，也称平方法），是一个在 $O(log \ n)$ 的时间内计算 $a^{n}$ 的小技巧，而暴力的计算需要 $O(n)$ 的时间。而这个技巧也常常用在非计算的场景，因为它可以应用在任何具有结合律的运算中。其中显然的是它可以应用于模意义下取幂、矩阵幂等运算，我们接下来会讨论。</p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>计算 a 的 n 次方表示将 n 个 a 乘在一起： $a^{n} \ = a \ \times \ a \ \times \ \cdots \ \times \ a$ （n 个 a）</p><p>然而当 a, n 太大的时侯，这种方法就不太适用了。不过我们知道：$a^{b+c} \ = \ a^{b}\ \cdot \ a^{c}$, $a^{2b}\ =\ a^{b}\ \cdot \ a^{b} \ = \ (a^{b})^{2}$。二进制取幂的想法是，我们将取幂的任务按照指数的 <strong>二进制表示</strong> 来分割成更小的任务。</p><p>首先我们将 n 表示为 2 进制，举一个例子：</p><p>$3^{(13)<em>{10}} \ = \ 3^{(1101)</em>{2}} \ = \ 3^{8} \ \cdot \ 3^{4} \ \cdot \ 3^{1}$</p><p>因为 n 有 $\lfloor \log_{2}n \rfloor \ + \ 1$ 个二进制位，因此当我们知道了 $a^{1}, \ a^{2}, \ a^{4}, \ a^{8}, \ \cdots, \ a^{2^{\lfloor\log_{2}n\rfloor}}, \ $后，我们只用计算 $O(\log n)$ 次乘法就可以计算出 $a^{n}$。</p><p>于是我们只需要知道一个快速的方法来计算上述 3 的 $2^{k}$ 次幂的序列。这个问题很简单，因为序列中（除第一个）任意一个元素就是其前一个元素的平方。举一个例子：<br>$$<br>\begin{matrix}<br>3^{1} &amp; = &amp; 3\<br>3^{2} &amp; = &amp; (3^{1})^{2} &amp; = &amp; 3^{2} &amp; = &amp; 9\<br>3^{4} &amp; = &amp; (3^{2})^{2} &amp; = &amp; 9^{2} &amp; = &amp; 81\<br>3^{8} &amp; = &amp; (3^{4})^{2} &amp; = &amp; 81^{2} &amp; = &amp; 6561\<br>\end{matrix}<br>$$</p><p>因此为了计算 $3^{13}$，我们只需要将对应二进制位为 1 的整系数幂乘起来就行了：</p><p>$3^{13} \ = \ 6561 \ \cdot \ 81 \ \cdot \ 3\ = \ 1594323$</p><p>将上述过程说得形式化一些，如果把 n 写作二进制为 $(n_{t}n_{t-1}\cdots n_{1}n_{0})$，那么有：</p><p>$n \ = \ n_{t}2^{t} \ + \ n_{t-1}2^{t-1} \ + \ n_{t-2}2^{t-2} \ + \ \cdots \ + \ n_{1}2^{1} \ + \ n_{0}2^{0}$</p><p>其中 。那么就有</p><p>$a^{n} \ = \ (a^{n_{t}2^{t} \ + \ \cdots \ + \ n_{0}2^{0}}) \ = \ a^{n_{0}2^{0}} \ \times \ a^{n_{1}2^{1}} \ \times \ \cdots \ \times \ a^{n_{t}2^{t}}$</p><p>根据上式我们发现，原问题被我们转化成了形式相同的子问题的乘积，并且我们可以在常数时间内从 $2^{i}$ 项推出 $2^{i+1}$ 项。</p><p>这个算法的复杂度是 $O(\log n)$ 的，我们计算了 $O(\log n)$ 个 $2^{k}$ 次幂的数，然后花费 $O(\log n)$ 的时间选择二进制为 1 对应的幂来相乘。</p><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><ul><li><p>递归法</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">long long binpow(long long a, long long b){  if (!b) return 1;  long long res = binpow(a, b / 2);  if (b % 2)    return res * res * a;  else    return res * res;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><ul><li><p>非递归法（稍快）</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">long long binpow(long long a, long long b){  long long res = 1;  while (b &gt; 0)  {    if (b &amp; 1) res = res * a;    a = a * a;    b &gt;&gt;= 1;  }  return res;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="模意义下取幂"><a href="#模意义下取幂" class="headerlink" title="模意义下取幂"></a>模意义下取幂</h3><p>计算 $x^{n} \ mod \ m$</p><p>这是一个非常常见的应用，例如它可以用于计算模意义下的乘法逆元。</p><p>既然我们知道取模的运算不会干涉乘法运算，因此我们只需要在计算的过程中取模即可。</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">long long binpow(long long a, long long b, long long m){  a %= m;  long long res = 1;  while (b &gt; 0)  {    if (b &amp; 1) res = res * a % m;    a = a * a % m;    b &gt;&gt;= 1;  }  return res;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意：根据费马小定理，如果 m 是一个质数，我们可以计算 $x^{n \ mod \ (m-1)}$ 来加速算法过程。</p><h3 id="模意义下大整数乘法"><a href="#模意义下大整数乘法" class="headerlink" title="模意义下大整数乘法"></a>模意义下大整数乘法</h3><p>计算 $a \ \times \ b \ mod \ m, \ a, \ b \ \leq \ m \ \leq \ 10^{18}$</p><pre class="line-numbers language-none"><code class="language-none"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 快速幂 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树</title>
      <link href="2021/05/09/2021-5-9-shu/"/>
      <url>2021/05/09/2021-5-9-shu/</url>
      
        <content type="html"><![CDATA[<h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>二叉树是一棵<strong>空树</strong>，或者是一棵由一个根节点和两棵互不相交的，分别称作根的左子树和右子树组成的非空树；左子树和右子树又同样都是二叉树。</p><h3 id="基本形态"><a href="#基本形态" class="headerlink" title="基本形态"></a>基本形态</h3><p>二叉树是递归定义的，其结点有左右子树之分，逻辑上二叉树有五种基本形态：</p><ol><li><p>空二叉树</p></li><li><p>只有根结点的二叉树</p></li><li><p>只有左子树的二叉树</p></li><li><p>只有右子树的二叉树</p></li><li><p>完全二叉树</p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/OwlllOvO/Hexo-image/20210509235326.PNG"></p><ul><li>满二叉树：如果一棵二叉树只有度为 0 的结点和度为 2 的结点，并且度为 0 的结点在同一层上，则这棵二叉树为满二叉树。</li><li>完全二叉树：深度为 k，有 n 个结点的二叉树当且仅当其每一个结点都与深度为 k 的满二叉树中编号从 1 到 n 的结点一一对应时，称为完全二叉树。</li></ul><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><ol><li>二叉树的第i层上至多有 2<sup>i - 1</sup> (i ≥ 1) 个节点</li><li>深度为 h 的二叉树中至多含有 2<sup>h - 1</sup> 个节点</li><li>若在任意一棵二叉树中，有n<sub>0</sub>个叶子节点，有 n<sub>2</sub> 个度为 2 的节点，则必有n<sub>0</sub> = n<sub>2</sub>+1</li><li>具有 n 个节点的完全二叉树深为 log<sub>2</sub>x + 1（其中 x 表示不大于 n 的最大整数）</li><li>若对一棵有 n 个节点的完全二叉树进行顺序编号（1 ≤ i ≤ n），那么，对于编号为 i（i ≥ 1）的节点：<ol><li>当 i = 1 时，该节点为根，它无双亲节点</li><li>当 i &gt; 1 时，该节点的双亲节点的编号为 i / 2</li><li>若 2i ≤ n，则有编号为 2i 的左节点，否则没有左节点</li><li>若 2i + 1 ≤ n，则有编号为 2i + 1 的右节点，否则没有右节点</li></ol></li></ol><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><p> 一棵二叉树由根结点、左子树和右子树三部分组成，若规定 D、L、R 分别代表遍历根结点、遍历左子树、遍历右子树，则二叉树的遍历方式有 6 种：DLR、DRL、LDR、LRD、RDL、RLD。由于先遍历左子树和先遍历右子树在算法设计上没有本质区别，所以，只讨论三种方式：</p><p>DLR - 前序遍历（根在前，从左往右，一棵树的根永远在左子树前面，左子树又永远在右子树前面 ）</p><p>LDR - 中序遍历（根在中，从左往右，一棵树的左子树永远在根前面，根永远在右子树前面）</p><p>LRD - 后序遍历（根在后，从左往右，一棵树的左子树永远在右子树前面，右子树永远在根前面）</p><h2 id="字典树"><a href="#字典树" class="headerlink" title="字典树"></a>字典树</h2><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">struct TRIE{  int nex[100000][26], cnt;  bool exist[100000];  // 该结点结尾的字符串是否存在  void insert(char *s, int l)  // 插入字符串  {    int p = 0;    for (int i = 0; i &lt; l; i++)    {      int c = s[i] - 'a';      if (!nex[p][c]) nex[p][c] = ++cnt;  // 如果没有，就添加结点      p = nex[p][c];    }    exist[p] = 1;  }  bool find(char *s, int l)  // 查找字符串  {    int p = 0;    for (int i = 0; i &lt; l; i++)    {      int c = s[i] - 'a';      if (!nex[p][c]) return 0;      p = nex[p][c];    }    return exist[p];  }};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="于是他错误的点名开始了"><a href="#于是他错误的点名开始了" class="headerlink" title="于是他错误的点名开始了"></a><a href="https://www.luogu.com.cn/problem/P2580">于是他错误的点名开始了</a></h3><h4 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h4><p>XS 中学化学竞赛组教练是一个酷爱炉石的人。</p><p>他会一边搓炉石一边点名以至于有一天他连续点到了某个同学两次，然后正好被路过的校长发现了然后就是一顿欧拉欧拉欧拉（详情请见已结束比赛 CON900）。</p><h4 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h4><p>这之后校长任命你为特派探员，每天记录他的点名。校长会提供化学竞赛学生的人数和名单，而你需要告诉校长他有没有点错名。（为什么不直接不让他玩炉石。）</p><h4 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h4><p>第一行一个整数 n，表示班上人数。</p><p>接下来 n 行，每行一个字符串表示其名字（互不相同，且只含小写字母，长度不超过 50）。</p><p>第 n + 2 行一个整数 m，表示教练报的名字个数。</p><p>接下来 m 行，每行一个字符串表示教练报的名字（只含小写字母，且长度不超过 50）。</p><h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><p>对于每个教练报的名字，输出一行。</p><p>如果该名字正确且是第一次出现，输出 <code>OK</code>，如果该名字错误，输出 <code>WRONG</code>，如果该名字正确但不是第一次出现，输出 <code>REPEAT</code>。</p><h4 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h4><pre class="line-numbers language-none"><code class="language-none">5  abcadacd3aae<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h4><pre class="line-numbers language-none"><code class="language-none">OKREPEATWRONG<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h4><ul><li>对于 40% 的数据，$n \ \leq 1000, \ m \ \leq \ 2000$</li><li>对于 70% 的数据，$n \ \leq 10^{4}, \ m \ \leq \ 2 \ \times \ 10^{4}$</li><li>对于 100% 的数据，$n \ \leq 10^{4}, \ m \ \leq \ 2 \ \times \ 10^{5}$</li></ul><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><p>Trie</p><p>把模板中的标记数组 exist 改成 int，插入时标记为 1，查询时每查询一次 +1 即可判断是否 REPEAT</p><h4 id="Accepted-Code"><a href="#Accepted-Code" class="headerlink" title="Accepted Code"></a>Accepted Code</h4><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#define _CRTSECURE_NOWARNINGS#pragma warning(disable:4996)#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;cmath&gt;#include&lt;cctype&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;vector&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;list&gt;using namespace std;int n, m;char x[101];struct TRIE{int nex[10000000][26], cnt;int exist[10000000];  // 该结点结尾的字符串是否存在void insert(char* s, int l)  // 插入字符串{int p = 0;for (int i = 0; i &lt; l; i++){int c = s[i] - 'a';if (!nex[p][c]) nex[p][c] = ++cnt;  // 如果没有，就添加结点p = nex[p][c];}exist[p] = 1;}int find(char* s, int l)  // 查找字符串{int p = 0;for (int i = 0; i &lt; l; i++){int c = s[i] - 'a';if (!nex[p][c]) return 0;p = nex[p][c];}if (exist[p]) return exist[p]++;}};TRIE trie;int main(){scanf("%d", &amp;n);while (n--){scanf("%s", x);int l = strlen(x);trie.insert(x, l);}scanf("%d", &amp;n);while (n--){scanf("%s", x);int l = strlen(x);int ans = trie.find(x, l);if (ans){if (ans == 1) printf("OK\n");else printf("REPEAT\n");}else printf("WRONG\n");}return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DP</title>
      <link href="2021/05/02/2021-5-2-dp/"/>
      <url>2021/05/02/2021-5-2-dp/</url>
      
        <content type="html"><![CDATA[<h1 id="DP"><a href="#DP" class="headerlink" title="DP"></a>DP</h1><h2 id="基础-DP"><a href="#基础-DP" class="headerlink" title="基础 DP"></a>基础 DP</h2><h3 id="最长公共子串"><a href="#最长公共子串" class="headerlink" title="最长公共子串"></a>最长公共子串</h3><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>连续</li></ul><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>动态转移方程</p><p><code>if (a[i] == b[j]) dp[i][j] = dp[i-1][j-1] + 1;</code></p><p><code>else dp[i][j] = 0;</code></p><h4 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h4><pre class="line-numbers language-none"><code class="language-none">#define _CRTSECURE_NOWARNINGS#pragma warning(disable:4996)#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;cmath&gt;#include&lt;cctype&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;vector&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;list&gt;using namespace std;#define INF 0x7fffffffint n, m;char a[10001], b[10001];int dp[10001][10001];int maxn;int main(){    scanf ("%s", a + 1);    scanf ("%s", b + 1);    int n = strlen (a + 1);    int m = strlen (b + 1);    for (int i = 1; i &lt;= n; i++)    {        for (int j = 1; j &lt;= m; j++)        {            if (a[i]  == b[j]) dp[i][j] = dp[i-1][j-1] + 1;            maxn = max (maxn, dp[i][j]);        }    }    printf ("%d", maxn);        return 0;    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h3><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><ul><li>可以不连续</li></ul><p>动态转移方程</p><p><code>if (a[i] == b[j]) dp[i][j] = dp[i-1][j-1] + 1;</code><br><code>dp[i][j] = max(dp[i][j], dp[i-1][j], dp[i][j-1]);</code></p><h4 id="模板-1"><a href="#模板-1" class="headerlink" title="模板"></a>模板</h4><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#define _CRTSECURE_NOWARNINGS#pragma warning(disable:4996)#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;cmath&gt;#include&lt;cctype&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;vector&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;list&gt;using namespace std;#define INF 0x7fffffffint n, m;int a[10001], b[10001];int dp[10001][10001];bool cmp(int x, int y){    return x &gt; y;}int max1(int x, int y, int z){    int t[4] = { 0, x, y, z };    sort (t + 1, t + 4, cmp);    return t[1];}int main(){    scanf ("%d%d", &amp;n, &amp;m);    for (int i = 1; i &lt;= n; i++) scanf ("%d", &amp;a[i]);    for (int i = 1; i &lt;= m; i++) scanf ("%d", &amp;b[i]);    for (int i = 1; i &lt;= n; i++)    {        for (int j = 1; j &lt;= m; j++)        {            if (a[i] == b[j]) dp[i][j] = dp[i-1][j-1] + 1;            dp[i][j] = max1(dp[i][j], dp[i-1][j], dp[i][j-1]);        }    }    printf ("%d", dp[n][m]);        return 0;    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="01-背包"><a href="#01-背包" class="headerlink" title="01 背包"></a>01 背包</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>已知条件有第 i 个物品的重量 w[i]，价值 v[i]，以及背包的总容量 W。</p><h3 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h3><p>有多样物品</p><ul><li>每样物品只有一件</li><li>每件物品只有 <code>取</code> 或 <code>不取</code> 两种状态</li></ul><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>dp[i][j]：在只能取前 i 件物品的情况下，容量为 j 的背包能取的最大价值</p><p>假设当前已经处理好了前 i - 1 个物品的所有状态，那么对于第 i 个物品，有取或不取两种选择</p><ul><li>当其不放入背包时，背包的剩余容量不变，背包中物品的总价值也不变，故这种情况的最大价值为 f[i-1][j]</li><li>当其放入背包时，背包的剩余容量会减小 ，背包中物品的总价值会增大 ，故这种情况的最大价值为 f[i-1][j-w[i]] + v[i]。</li></ul><p>动态转移方程：<code>dp[i][j] = max(dp[i-1][j], dp[i-1][j - w[i]] + v[i])</code></p><h3 id="模板-2"><a href="#模板-2" class="headerlink" title="模板"></a>模板</h3><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">for (int i = 1; i &lt;= n; i++)  for (int j = w[i]; j &lt;= W; j++)    dp[i][j] = max(dp[i-1][j], dp[i-1][j - w[i]] + v[i]);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>可以发现，第 i 次循环时的 dp 数组只受第 i - 1 层的影响，因此可以去掉第一维</p><p>但是若 j 从前往后便利，则会在同一层将之后需要用到的数据覆盖掉，相当于可以多次将物品 i 多次放入背包（这就是完全背包的解法），因此要从后往前遍历。</p><p>动态转移方程：<code>dp[j] = max(dp[j], dp[j - w[i]] + v[i])</code></p><h3 id="模板-3"><a href="#模板-3" class="headerlink" title="模板"></a>模板</h3><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">for (int i = 1; i &lt;= n; i++)  for (int j = W; j &gt;= w[i]; j--)    dp[j] = max(dp[j], dp[j - w[i]] + v[i]);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>已知条件有第 i 个物品的重量 w[i]，价值 v[i]，以及背包的总容量 W。</p><h3 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a>特点</h3><p>有多样物品</p><ul><li>每样物品有无数件</li><li>每件物品只有 <code>取</code> 或 <code>不取</code> 两种状态</li></ul><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>dp[i][j]：在只能取前 i 件物品的情况下，容量为 j 的背包能取的最大价值</p><p>遍历时对于 <code>取</code> 的状态，在同一层中计算，因此 j 将遍历到第 i 件物品的倍数，相当于对这件物品多次取</p><p>若 j 从后往前遍历，会出现同一层中需要用到的数据还未计算的情况，因此需从前往后遍历。</p><p>动态转移方程：<code>dp[i][j] = max(dp[i-1][j], dp[i][j - w[i]] + v[i])</code></p><h3 id="模板-4"><a href="#模板-4" class="headerlink" title="模板"></a>模板</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">dpor (int i = 1; i &lt;= n; i++)  dpor (int j = w[i]; j &lt;= W; j++)    dp[i][j] = max(dp[i-1][j], dp[i][j - w[i]] + v[i]);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="优化-1"><a href="#优化-1" class="headerlink" title="优化"></a>优化</h3><p>跟 01 背包的优化思路一样，可以去除一层数组</p><p><code>dp[j] = max(dp[j], dp[j - w[i]] + v[i])</code></p><h3 id="模板-5"><a href="#模板-5" class="headerlink" title="模板"></a>模板</h3><pre class="line-numbers language-none"><code class="language-none">dpor (int i = 1; i &lt;= n; i++)  dpor (int j = w[i]; j &lt;= W; j++)    dp[j] = max(dp[j], dp[j - w[i]] + v[i])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h2><h3 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h3><p>已知条件有第 i 个物品的重量 w[i]，价值 v[i]，以及背包的总容量 W。</p><h3 id="特点-4"><a href="#特点-4" class="headerlink" title="特点"></a>特点</h3><p>有多样物品</p><ul><li>每样物品有 <code>1 件</code> 或 <code>k 件</code></li><li>每件物品只有 <code>取</code> 或 <code>不取</code> 两种状态</li></ul><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>把 “每种物品有 k<sub>i</sub> 件” 等价转换为 “有 k<sub>i</sub> 个相同的物品，每个物品只有一件”。这样就转换成了一个 01 背包模型，套用上文所述的方法就可已解决。</p><h3 id="优化-2"><a href="#优化-2" class="headerlink" title="优化"></a>优化</h3><h4 id="二进制分组优化"><a href="#二进制分组优化" class="headerlink" title="二进制分组优化"></a>二进制分组优化</h4><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int index = 0;for (int i = 1; i &lt;= m; i++){int c = 1, p, h, k;  scanf ("%d%d%d", &amp;p, &amp;h, &amp;k);  while (k - c &gt; 0)  {    k -= c;    list[++index].w = c * p;    list[index].v = c * h;    c *= 2;  }  list[++index].w = p * k;  list[index].v = h * k;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="混合背包"><a href="#混合背包" class="headerlink" title="混合背包"></a>混合背包</h2><h3 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h3><p>已知条件有第 i 个物品的重量 w[i]，价值 v[i]，以及背包的总容量 W。</p><h3 id="特点-5"><a href="#特点-5" class="headerlink" title="特点"></a>特点</h3><p>有多样物品</p><ul><li>每样物品有 <code>1 件</code> / <code>k 件</code> 或 <code>无数件</code></li><li>每件物品只有 <code>取</code> 或 <code>不取</code> 两种状态</li></ul><h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p>将每一类背包问题分别求解</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">for (循环物品种类){  if (是 01 背包)    套用 01 背包代码;  else if (是完全背包)    套用完全背包代码;  else if (是多重背包)    套用多重背包代码;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="二维费用背包"><a href="#二维费用背包" class="headerlink" title="二维费用背包"></a>二维费用背包</h2><h3 id="简介-4"><a href="#简介-4" class="headerlink" title="简介"></a>简介</h3><p>已知条件有第 i 个物品的重量 w[i]，耗时 t[i]，价值 v[i]，以及背包的总容量 W。</p><h3 id="特点-6"><a href="#特点-6" class="headerlink" title="特点"></a>特点</h3><p>有多样物品</p><ul><li>每样物品只有 <code>1 件</code></li><li>每件物品只有 <code>取</code> 或 <code>不取</code> 两种状态</li></ul><h3 id="模板-6"><a href="#模板-6" class="headerlink" title="模板"></a>模板</h3><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">for (int k = 1; k &lt;= n; k++)//对物品进行枚举  for (int i = m; i &gt;= mi; i--)// 对经费进行一层枚举    for (int j = t; j &gt;= ti; j--)// 对时间进行一层枚举      dp[i][j] = max(dp[i][j], dp[i - mi][j - ti] + 1);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="分组背包"><a href="#分组背包" class="headerlink" title="分组背包"></a>分组背包</h2><h3 id="简介-5"><a href="#简介-5" class="headerlink" title="简介"></a>简介</h3><p>所谓分组背包，就是将物品分组，每组的物品 <strong>相互冲突</strong> ，最多只能选一个物品放进去。</p><h3 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h3><p>从「在所有物品中选择一件」变成了「从当前组中选择一件」，于是就对每一组进行一次 01 背包就可以了。</p><p>可以将 t[k][i] 表示第 k 组的第 i 件物品的编号是多少，再用 cnt[k] 表示第 k 组物品有多少个。</p><h3 id="模板-7"><a href="#模板-7" class="headerlink" title="模板"></a>模板</h3><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">for (int k = 1; k &lt;= ts; k++)          // 循环每一组  for (int i = m; i &gt;= 0; i--)         // 循环背包容量    for (int j = 1; j &lt;= cnt[k]; j++)  // 循环该组的每一个物品      if (i &gt;= w[t[k][j]])        dp[i] = max(dp[i], dp[i - w[t[k][j]]] + c[t[k][j]]);  // 像0-1背包一样状态转移<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意循环顺序</strong></p><h2 id="有依赖的背包"><a href="#有依赖的背包" class="headerlink" title="有依赖的背包"></a>有依赖的背包</h2><h3 id="简介-6"><a href="#简介-6" class="headerlink" title="简介"></a>简介</h3><p>如果选第 i 件物品，就必须选第 j 件物品，保证不会循环引用，一部分题目甚至会出现多叉树的引用形式。为了方便，就称不依赖于别的物品的物品称为「主件」，依赖于某主件的物品称为「附件」。</p><h3 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h3><p>对于包含一个主件和若干个附件的集合有以下可能性：仅选择主件，选择主件后再选择一个附件，选择主件后再选择两个附件……需要将以上可能性的容量和价值转换成一件件物品。因为这几种可能性只能选一种，所以可以将这看成分组背包。</p><p>如果是多叉树的集合，则要先算子节点的集合，最后算父节点的集合。</p><h2 id="区间DP"><a href="#区间DP" class="headerlink" title="区间DP"></a>区间DP</h2><h3 id="简介-7"><a href="#简介-7" class="headerlink" title="简介"></a>简介</h3><p>区间类动态规划是线性动态规划的扩展，它在分阶段地划分问题时，与阶段中元素出现的顺序和由前一阶段的哪些元素合并而来有很大的关系。令状态 f(i, j) 表示将下标位置 i 到 j 的所有元素合并能获得的价值的最大值，那么 <code>f(i, j) = max { f(i, k) + f(k + 1, j) + cost }</code>，cost 为将这两组元素合并起来的代价。</p><h3 id="特点-7"><a href="#特点-7" class="headerlink" title="特点"></a>特点</h3><ul><li><strong>合并</strong>：即将两个或多个部分进行整合，当然也可以反过来；</li><li><strong>特征</strong>：能将问题分解为能两两合并的形式；</li><li><strong>求解</strong>：对整个问题设最优值，枚举合并点，将问题分解为左右两个部分，最后合并两个部分的最优值得到原问题的最优值。</li></ul><h3 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h3><p>既然让我求解在一个区间上的最优解，那么我把这个区间分割成一个个小区间，求解每个小区间的最优解，再合并小区间得到大区间即可。所以在代码实现上，我可以枚举区间长度 len 为每次分割成的小区间长度（由短到长不断合并），内层枚举该长度下可以的起点，自然终点也就明了了。然后在这个起点终点之间枚举分割点，求解这段小区间在某个分割点下的最优解。</p><h3 id="模板-8"><a href="#模板-8" class="headerlink" title="模板"></a>模板</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">for(int len = 1; len&lt;=n; len++)//枚举长度{for(int j = 1; j + len &lt;= n + 1; j++)//枚举起点，ends &lt;= n{int ends = j + len - 1;for(int i = j; i &lt; ends; i++)//枚举分割点，更新小区间最优解{dp[j][ends] = min(dp[j][ends], dp[j][i] + dp[i+1][ends] + something);}}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="朴素区间-DP-O-n3"><a href="#朴素区间-DP-O-n3" class="headerlink" title="朴素区间 DP O(n3)"></a>朴素区间 DP O(n<sup>3</sup>)</h3><h4 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h4><p>N  堆石子摆成一条线。现要将石子有次序地合并成一堆。规定每次只能选相邻的 2 堆石子合并成新的一堆，并将新的一堆石子数记为该次合并的代价。计算将 N 堆石子合并成一堆的最小代价。</p><h4 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h4><p>数据的第 1 行是正整数 N，表示有 N 堆石子。第 2 行有 N 个整数，第 i 个整数 a<sub>i</sub> 表示第 i 堆石子的个数。</p><h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><p>输出共 1 行：最小得分。</p><h4 id="Example-Input"><a href="#Example-Input" class="headerlink" title="Example Input"></a>Example Input</h4><pre class="line-numbers language-none"><code class="language-none">41 2 3 4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="Example-Output"><a href="#Example-Output" class="headerlink" title="Example Output"></a>Example Output</h4><pre class="line-numbers language-none"><code class="language-none">19<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h4><p>1 2 3 4 (0) -&gt; 3 3 4 (3) -&gt; 6 4 (9) -&gt; 10 (19)</p><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><p>f[x][y]：从 x 到 y 的最小得分</p><p>w[x][y]：从 x 到 y 的重量和</p><p>转移方程：<code>f[i][j] = min(f[i][j], f[i][k] + f[k + 1][j] + w[i][ends]);</code></p><p>其中 w[x][y] 可以用前缀和数组 sum[] 代替，w[x][y] = sum[y] - sum[x - 1]</p><h4 id="Accepted-Code"><a href="#Accepted-Code" class="headerlink" title="Accepted Code"></a>Accepted Code</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define _CRTSECURE_NOWARNINGS#pragma warning(disable:4996)#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;cmath&gt;#include&lt;cctype&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;vector&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;list&gt;using namespace std;#define INF 0x7fffffffint n, a[101], arr[101];int f[101][101];int main(){    scanf ("%d", &amp;n);    for (int i = 1; i &lt;= n; i++)    {        scanf ("%d", &amp;a[i]);        arr[i] = arr[i-1] + a[i];    }        for (int p = 1; p &lt; n; p++)    {        for (int i = 1, j = i + p; i &lt; n &amp;&amp; j &lt;= n; i++, j = i + p)        {            f[i][j] = INF;            for (int k = i; k &lt; j; k++)            {                f[i][j] = min(f[i][j], f[i][k] + f[k+1][j] + arr[j] - arr[i-1]);            }        }    }        printf ("%d", f[1][n]);        return 0;  }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="线性变环状"><a href="#线性变环状" class="headerlink" title="线性变环状"></a>线性变环状</h3><h4 id="NOI-1995-石子合并"><a href="#NOI-1995-石子合并" class="headerlink" title="NOI 1995 石子合并"></a><a href="https://www.luogu.com.cn/problem/P1880">NOI 1995 石子合并</a></h4><h4 id="Description-1"><a href="#Description-1" class="headerlink" title="Description"></a>Description</h4><p>在一个圆形操场的四周摆放 N 堆石子，现要将石子有次序地合并成一堆。规定每次只能选相邻的 2 堆合并成新的一堆，并将新的一堆的石子数，记为该次合并的得分。试设计出一个算法，计算出将 N 堆石子合并成 1 堆的最小得分和最大得分。</p><h4 id="Input-1"><a href="#Input-1" class="headerlink" title="Input"></a>Input</h4><p>数据的第 1 行是正整数 N，表示有 N 堆石子。第 2 行有 N 个整数，第 i 个整数 a<sub>i</sub> 表示第 i 堆石子的个数。</p><h4 id="Output-1"><a href="#Output-1" class="headerlink" title="Output"></a>Output</h4><p>输出共 2 行，第 1 行为最小得分，第 2 行为最大得分。</p><h4 id="Example-Input-1"><a href="#Example-Input-1" class="headerlink" title="Example Input"></a>Example Input</h4><pre class="line-numbers language-none"><code class="language-none">44 5 9 4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="Example-Output-1"><a href="#Example-Output-1" class="headerlink" title="Example Output"></a>Example Output</h4><pre class="line-numbers language-none"><code class="language-none">4354<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="Hint-1"><a href="#Hint-1" class="headerlink" title="Hint"></a>Hint</h4><p>1 ≤ N ≤ 100，0 ≤ a<sub>i</sub> ≤ 200 ≤ a<sub>i</sub> ≤ 20。</p><h4 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h4><p>f1[x][y]：从 x 到 y 的最小得分</p><p>w[x][y]：从 x 到 y 的重量和</p><p>转移方程：<code>f1[i][j] = min(f1[i][j], f1[i][k] + f1[k + 1][j] + w[i][ends]);</code></p><p>其中 w[x][y] 可以用前缀和数组 sum[] 代替，w[x][y] = sum[y] - sum[x - 1]</p><h4 id="Accepted-Code-1"><a href="#Accepted-Code-1" class="headerlink" title="Accepted Code"></a>Accepted Code</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define _CRTSECURE_NOWARNINGS#pragma warning(disable:4996)#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;cmath&gt;#include&lt;cctype&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;vector&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;list&gt;using namespace std;#define INF 0x7fffffffint n, minl, maxl, f1[300][300], f2[300][300], num[300];int s[300];int d(int i,int j)  //转移方程：f[i][j] = max(f[i][k]+f[k+1][j]+d[i][j];{    return s[j] - s[i - 1];    }int main(){    scanf("%d", &amp;n);    for(int i = 1; i &lt;= n + n; i++) //因为是一个环，所以需要开到两倍再枚举分界线，最后肯定是最大的    {        scanf("%d", &amp;num[i]);        num[i + n] = num[i];        s[i] = s[i - 1] + num[i];    }    for(int p = 1; p &lt; n; p++)    {        for(int i = 1,j = i + p; (j &lt; n + n) &amp;&amp; (i &lt; n + n); i++, j = i + p)        {            f2[i][j] = INF;            for(int k = i; k &lt; j; k++)            {                f1[i][j] = max(f1[i][j], f1[i][k] + f1[k + 1][j] + d(i, j));                f2[i][j] = min(f2[i][j], f2[i][k] + f2[k + 1][j] + d(i, j));            }        }    }    minl = INF;    for(int i = 1; i &lt;= n; i++)    {        maxl = max(maxl, f1[i][i + n - 1]);        minl = min(minl, f2[i][i + n - 1]);    }        printf("%d\n%d", minl, maxl);    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="四边形优化-O-n2"><a href="#四边形优化-O-n2" class="headerlink" title="四边形优化 O(n2)"></a>四边形优化 O(n<sup>2</sup>)</h3><h4 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h4><p>在查找最优分割点的时候，我们浪费了大量时间。那么我们可以把最优分割点保存下来，在查找的时候利用保存的最优分割点来优化查找过程。</p><h4 id="四边形不等式优化"><a href="#四边形不等式优化" class="headerlink" title="四边形不等式优化"></a>四边形不等式优化</h4><ol><li>功能：用来寻找，s[i][j] （i ~ j 的最优分割点）与其他分割点的关系</li><li>不等式内容：如果某东西满足 a &lt; b &lt;= c &lt; d 且f[a][c] + f[b][d] &lt;= f[a][d] + f[b][c]，则说这个东西满足四边形不等式。简而言之：交叉小于包含！</li><li>结论关系：s[i][j-1] &lt;= s[i][j] &lt;= s[i+1][j] </li><li>证明过程：<ol><li>证明 w 满足四边形不等式，这里 w 是 m 的附属量，形如 m[i, j] = opt{ m[i, k] + m[k, j] + w[i, j] }，此时大多要先证明 w 满足条件才能进一步证明 m 满足条件</li><li>证明 m 满足四边形不等式</li><li>证明 s[i, j-1] ≤ s[i, j] ≤ s[i+1, j]</li></ol></li></ol><h4 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define _CRTSECURE_NOWARNINGS#pragma warning(disable:4996)#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;cmath&gt;#include&lt;cctype&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;vector&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;list&gt;using namespace std;#define INF 0x7fffffffint n;int dp[2005][2005];int sum[2005];int relation[2005][2005];int num[2005];int main(){    scanf("%d", &amp;n);    memset(sum, 0, sizeof(sum));    memset(dp, INF, sizeof(dp));    for(int i = 1; i &lt;= n; i++)    {        scanf("%d", &amp;num[i]);        dp[i][i] = 0;        relation[i][i] = i;        sum[i] = sum[i-1] + num[i];    }    for(int i = 1; i &lt;= n; i++)    {        sum[i+n] = sum[i+n-1] + num[i];        relation[i+n][i+n] = i + n; //分割点初始化        dp[i+n][i+n] = 0;    }    for(int len = 1; len &lt;= n; len++)    {        for(int j = 1; j + len &lt;= 2 * n; j++)        {            int ends = j + len - 1;            for(int k = relation[j][ends-1]; k &lt;= relation[j+1][ends]; k++) //k的范围            {                if(dp[j][ends] &gt; dp[j][k] + dp[k+1][ends] + sum[ends] - sum[j-1])                {                    dp[j][ends] = dp[j][k] + dp[k+1][ends] + sum[ends] - sum[j-1];                    relation[j][ends] = k;                }            }        }    }    int ans = INF;    for(int i = 1; i &lt;= n; i++)    {        ans = min(ans, dp[i][i+n-1]);    }    printf("%d\n", ans);        return 0;    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="POJ-2955-Brackets-括号匹配"><a href="#POJ-2955-Brackets-括号匹配" class="headerlink" title="POJ 2955 Brackets 括号匹配"></a><a href="http://poj.org/problem?id=2955">POJ 2955 Brackets 括号匹配</a></h3><h4 id="Description-2"><a href="#Description-2" class="headerlink" title="Description"></a>Description</h4><p>We give the following inductive definition of a “regular brackets” sequence:the empty sequence is a regular brackets sequence,if s is a regular brackets sequence, then (s) and [s] are regular brackets sequences, andif a and b are regular brackets sequences, then ab is a regular brackets sequence.no other sequence is a regular brackets sequenceFor instance, all of the following character sequences are regular brackets sequences: <code>()</code>, <code>[]</code>, <code>(())</code>, <code>()[]</code>, <code>()[()]</code> while the following character sequences are not: <code>(</code>, <code>]</code>, <code>)(</code>, <code>([)]</code>, <code>([(]</code> Given a brackets sequence of characters a<sub>1</sub>a<sub>2</sub> … a<sub>n</sub>, your goal is to find the length of the longest regular brackets sequence that is a subsequence of s. That is, you wish to find the largest m such that for indices i<sub>1</sub>, i<sub>2</sub>, …, im where 1 ≤ i<sub>1</sub> &lt; i<sub>2</sub> &lt; … &lt; i<sub>m</sub> ≤ n, a<sub>i1</sub>a<sub>i2</sub> … a<sub>im</sub> is a regular brackets sequence.Given the initial sequence <code>([([]])]</code>, the longest regular brackets subsequence is <code>[([])]</code>.</p><h4 id="Input-2"><a href="#Input-2" class="headerlink" title="Input"></a>Input</h4><p>The input test file will contain multiple test cases. Each input test case consists of a single line containing only the characters (, ), [, and ]; each input test will have length between 1 and 100, inclusive. The end-of-file is marked by a line containing the word “end” and should not be processed.</p><h4 id="Output-2"><a href="#Output-2" class="headerlink" title="Output"></a>Output</h4><p>For each input case, the program should print the length of the longest possible regular brackets subsequence on a single line.</p><h4 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h4><pre class="line-numbers language-none"><code class="language-none">((()))()()()([]]))[)(([][][)end<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h4><pre class="line-numbers language-none"><code class="language-none">66406<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h4><p>题意：给出一个的只有 ‘(‘, ‘)’, ‘[‘, ‘]’ 四种括号组成的字符串，求最多有多少个括号满足题目里所描述的完全匹配。</p><p>动态转移方程：如果 s[i] 与 s[j] 匹配：<code>dp[i][j] = dp[i+1][j-1] + 2</code></p><p>再遍历中间节点：<code>dp[i][j] = max(dp[i][j], dp[i][k] + dp[k+1][j])</code></p><h4 id="Accpted-Code"><a href="#Accpted-Code" class="headerlink" title="Accpted Code"></a>Accpted Code</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define _CRTSECURE_NOWARNINGS#pragma warning(disable:4996)#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;cmath&gt;#include&lt;cctype&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;vector&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;list&gt;using namespace std;#define INF 0x7fffffffchar s[110];int f[110][110];int main(){    while (1)    {        memset (s, 0, sizeof (s));        memset (f, 0, sizeof (f));        scanf ("%s", s + 1);        if (s[1] == 'e') return 0;        s[0] = 1;        int l = strlen (s+1);        for (int p = 2; p &lt;= l; p++)    //区间大小：2 ~ l        {            for (int i = 1, j = i + p - 1; j &lt;= l; i++, j = i + p - 1)  //区间：i ~ j            {                if ((s[i] == '(' &amp;&amp; s[j] == ')') || (s[i] == '[' &amp;&amp; s[j] == ']'))                    f[i][j] = f[i+1][j-1] + 2;                for (int k = i; k &lt; j; k++)                {                    f[i][j] = max(f[i][j], f[i][k] + f[k+1][j]);                }            }        }                printf ("%d\n", f[1][l]);            }            return 0;    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="POJ-1651-Multiplication-Puzzle-抽卡片"><a href="#POJ-1651-Multiplication-Puzzle-抽卡片" class="headerlink" title="POJ 1651 Multiplication Puzzle 抽卡片"></a><a href="http://poj.org/problem?id=1651">POJ 1651 Multiplication Puzzle 抽卡片</a></h3><h4 id="Description-3"><a href="#Description-3" class="headerlink" title="Description"></a>Description</h4><p>The multiplication puzzle is played with a row of cards, each containing a single positive integer. During the move player takes one card out of the row and scores the number of points equal to the product of the number on the card taken and the numbers on the cards on the left and on the right of it. It is not allowed to take out the first and the last card in the row. After the final move, only two cards are left in the row. </p><p>The goal is to take cards in such order as to minimize the total number of scored points. </p><p>For example, if cards in the row contain numbers 10 1 50 20 5, player might take a card with 1, then 20 and 50, scoring<br>10 * 1 * 50 + 50 * 20 * 5 + 10 * 50 * 5 = 500 + 5000 + 2500 = 8000<br>If he would take the cards in the opposite order, i.e. 50, then 20, then 1, the score would be<br>1 * 50 * 20 + 1 * 20 * 5 + 10 * 1 * 5 = 1000 + 100 + 50 = 1150.</p><h4 id="Input-3"><a href="#Input-3" class="headerlink" title="Input"></a>Input</h4><p>The first line of the input contains the number of cards N (3 &lt;= N &lt;= 100). The second line contains N integers in the range from 1 to 100, separated by spaces.</p><h4 id="Output-3"><a href="#Output-3" class="headerlink" title="Output"></a>Output</h4><p>Output must contain a single integer - the minimal score.</p><h4 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input"></a>Sample Input</h4><pre class="line-numbers language-none"><code class="language-none">610 1 50 50 20 5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output"></a>Sample Output</h4><pre class="line-numbers language-none"><code class="language-none">3650<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h4><p>题意：给出 n 个数字，要求不能删除两端点的数字，然后删除其他数字的代价是该数字和左右相邻数字的乘积，问把数字（除端点）删完后的最小总代价。</p><p>dp[i][j]：抽出 i ~ (j - 1) 卡片的最小值</p><p>动态转移方程：<code>dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j] + a[i-1] * a[k] * a[j])</code></p><h4 id="Accepted-Code-2"><a href="#Accepted-Code-2" class="headerlink" title="Accepted Code"></a>Accepted Code</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define _CRTSECURE_NOWARNINGS#pragma warning(disable:4996)#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;cmath&gt;#include&lt;cctype&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;vector&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;list&gt;using namespace std;#define INF 0x7fffffffint n;int a[101];int dp[101][101];int main(){    scanf ("%d", &amp;n);    for (int i = 1; i &lt;= n; i++)    {        scanf ("%d", &amp;a[i]);    }        for (int p = 1; p &lt; n; p++)    {        for (int i = 2, j = i + p; j &lt;= n; i++, j = i + p)        {            dp[i][j] = INF;            for (int k = i; k &lt; j; k++)            {                dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j] + a[i-1] * a[k] * a[j]);            }        }    }        printf ("%d", dp[2][n]);            return 0;    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="HDU-4632-Palindrome-subsequence-最长回文子串"><a href="#HDU-4632-Palindrome-subsequence-最长回文子串" class="headerlink" title="HDU 4632 Palindrome subsequence 最长回文子串"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=4632">HDU 4632 Palindrome subsequence 最长回文子串</a></h3><h4 id="Description-4"><a href="#Description-4" class="headerlink" title="Description"></a>Description</h4><p>In mathematics, a subsequence is a sequence that can be derived from another sequence by deleting some elements without changing the order of the remaining elements. For example, the sequence &lt;A, B, D&gt; is a subsequence of &lt;A, B, C, D, E, F&gt;.<br><a href="http://en.wikipedia.org/wiki/Subsequence">http://en.wikipedia.org/wiki/Subsequence</a></p><p>Given a string S, your task is to find out how many different subsequence of S is palindrome. Note that for any two subsequence X = &lt;S<sub>x1</sub>, S<sub>x2</sub>, …, S<sub>xk</sub>&gt; and Y = &lt;S<sub>y1</sub>, S<sub>y2</sub>, …, S<sub>yk</sub>&gt; , if there exist an integer i (1 &lt;= i &lt;= k) such that xi != yi, the subsequence X and Y should be consider different even if S<sub>xi</sub> = S<sub>yi</sub>. Also two subsequences with different length should be considered different.</p><h4 id="Input-4"><a href="#Input-4" class="headerlink" title="Input"></a>Input</h4><p>The first line contains only one integer T (T &lt;= 50), which is the number of test cases. Each test case contains a string S, the length of S is not greater than 1000 and only contains lowercase letters.</p><h4 id="Output-4"><a href="#Output-4" class="headerlink" title="Output"></a>Output</h4><p>For each test case, output the case number first, then output the number of different subsequence of the given string, the answer should be module 10007.</p><h4 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input"></a>Sample Input</h4><pre class="line-numbers language-none"><code class="language-none">4aaaaaagoodafternooneveryonewelcometoooxxourproblems<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output"></a>Sample Output</h4><pre class="line-numbers language-none"><code class="language-none">Case 1: 1Case 2: 31Case 3: 421Case 4: 960<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Solution-4"><a href="#Solution-4" class="headerlink" title="Solution"></a>Solution</h4><p>题意：给出一个字符串，求出其最多的可构成的回文字串（不要求连续），注：这里不同的回文字串只要求位置不同即可视为不同，如：aaaaa 的最多回文子串数目是 31.</p><p>dp[i][j]：i ~ j 构成的最多回文串个数</p><p>动态转移方程：</p><ul><li>根据容斥定理：dp[i+1][j] 并 dp[i][j-1] = dp[i+1][j] + dp[i][j-1] - dp[i+1][j-1]</li><li>如果 s[i] == s[j]<ul><li>两端单独可以构成回文子序列 + 1</li><li>与dp[i+1][j], dp[i][j-1], dp[i+1][j-1] 中的每个回文序列可以构成新的回文序列 + dp[i+1][j-1]</li></ul></li></ul><p>注：这里因为容斥时有减法，所以要先加上模再取模，否则会出现负数</p><p><code>dp[i][j] = (dp[i+1][j] + dp[i][j-1] - dp[i+1][j-1] + 10007) % 10007;</code></p><p><code>if (s[i] == s[j]) dp[i][j] = (dp[i][j] + dp[i+1][j-1] + 1) % 10007;</code></p><h4 id="Accepted-Code-3"><a href="#Accepted-Code-3" class="headerlink" title="Accepted Code"></a>Accepted Code</h4><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#define _CRTSECURE_NOWARNINGS#pragma warning(disable:4996)#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;cmath&gt;#include&lt;cctype&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;vector&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;list&gt;using namespace std;#define INF 0x7fffffffint T;char s[1010];int dp[1010][1010];int main(){    scanf ("%d", &amp;T);    for (int t = 1; t &lt;= T; t++)    {        memset(s, 0, sizeof (s));        memset(dp, 0, sizeof (dp));        scanf ("%s", s + 1);        int l = strlen(s + 1);        for (int i = 1; i &lt;= l; i++) dp[i][i] = 1;  //自己单独构成一个回文        for (int p = 1; p &lt;= l; p++)        {            for (int i = 1, j = i + p - 1; j &lt;= l; i++, j = i + p - 1)            {                dp[i][j] = (dp[i+1][j] + dp[i][j-1] - dp[i+1][j-1] + 10007) % 10007;                if (s[i] == s[j]) dp[i][j] = (dp[i][j] + dp[i+1][j-1] + 1) % 10007; //如果两端相等，dp[i][j] = 原来的 + 两端与中间每一个回文也可以构成回文（dp[i+1][j-1]) + 两端单独构成一个回文（1）            }        }        printf ("Case %d: %d\n", t, dp[1][l]);    }        return 0;    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="DAG-上的-DP"><a href="#DAG-上的-DP" class="headerlink" title="DAG 上的 DP"></a>DAG 上的 DP</h1><h3 id="简介-8"><a href="#简介-8" class="headerlink" title="简介"></a>简介</h3><p>DAG 即 <strong>有向无环图</strong>，一些实际问题中的二元关系都可使用 DAG 来建模，如转化为 DAG 上的最长路、最短路和路径计数问题。</p><h3 id="The-Tower-of-Babylon"><a href="#The-Tower-of-Babylon" class="headerlink" title="The Tower of Babylon"></a><a href="https://www.luogu.com.cn/problem/UVA437">The Tower of Babylon</a></h3><h4 id="Descrpition"><a href="#Descrpition" class="headerlink" title="Descrpition"></a>Descrpition</h4><p>Perhaps you have heard of the legend of the Tower of Babylon. Nowadays many details of this tale have been forgotten. So now, in line with the educational nature of this contest, we will tell you the whole story:</p><p>The babylonians had n types of blocks, and an unlimited supply of blocks of each type. Each type-i block was a rectangular solid with linear dimensions (xi,yi,zi). A block could be reoriented so that any two of its three dimensions determined the dimensions of the base and the other dimension was the height.</p><p>They wanted to construct the tallest tower possible by stacking blocks. The problem was that, in building a tower, one block could only be placed on top of another block as long as the two base dimensions of the upper block were both strictly smaller than the corresponding base dimensions of the lower block. This meant, for example, that blocks oriented to have equal-sized bases couldn’t be stacked.</p><p>Your job is to write a program that determines the height of the tallest tower the babylonians can build with a given set of blocks.</p><h4 id="Input-5"><a href="#Input-5" class="headerlink" title="Input"></a>Input</h4><p>The input file will contain one or more test cases. The first line of each test case contains an integer n, representing the number of different blocks in the following data set. The maximum value for n is 30.</p><p>Each of the next n lines contains three integers representing the values xi, yi and zi. Input is terminated by a value of zero (0) for n.</p><h4 id="Output-5"><a href="#Output-5" class="headerlink" title="Output"></a>Output</h4><p>For each test case, print one line containing the case number (they are numbered sequentially starting from 1) and the height of the tallest possible tower in the format</p><p>‘Case case: maximum height = height’</p><h4 id="Sample-Input-3"><a href="#Sample-Input-3" class="headerlink" title="Sample Input"></a>Sample Input</h4><pre class="line-numbers language-none"><code class="language-none">110 20 3026 8 105 5 571 1 12 2 23 3 34 4 45 5 56 6 67 7 7531 41 5926 53 5897 93 2384 62 6433 83 270<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Sample-Output-3"><a href="#Sample-Output-3" class="headerlink" title="Sample Output"></a>Sample Output</h4><pre class="line-numbers language-none"><code class="language-none">Case 1: maximum height = 40Case 2: maximum height = 21Case 3: maximum height = 28Case 4: maximum height = 342<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Solution-5"><a href="#Solution-5" class="headerlink" title="Solution"></a>Solution</h4><ul><li><p>建立 DAG</p><p>由于每个砖块的底面长宽分别严格小于它下方砖块的底面长宽，因此不难将这样一种关系作为建图的依据，而本题也就转化为最长路问题。</p><p>也就是说如果砖块 j 能放在砖块 i 上，那么 i 和 j 之间存在一条边 (i, j)，且边权就是砖块 j 所选取的高。</p><p>本题的另一个问题在于每个砖块的高有三种选法，怎样建图更合适呢？</p><p>不妨将每个砖块拆解为三种堆叠方式，即将一个砖块分解为三个砖块，每一个拆解得到的砖块都选取不同的高。</p><p>初始的起点是大地，大地的底面是无穷大的，则大地可达任意砖块，当然我们写程序时不必特意写上无穷大。</p><p>假设有两个砖块，三条边分别为 31, 41, 59 和 33, 83, 27，那么整张 DAG 应该如下图所示。</p></li></ul><p>  <img src="https://cdn.jsdelivr.net/gh/OwlllOvO/Hexo-image/20210509235622.png" alt="DAG"></p><p>  图中蓝实框所表示的是一个砖块拆解得到的一组砖块，之所以用 {} 表示底面边长，是因为砖块一旦选取了高，底面边长就是无序的。</p><p>  图中黄虚框表示的是重复计算部分，为下文做铺垫。</p><ul><li><p>转移</p><p>题目要求的是塔的最大高度，已经转化为最长路问题，其起点上文已指出是大地，那么终点呢？</p><p>显然终点已经自然确定，那就是某砖块上不能再搭别的砖块的时候。</p><p>之前在图上标记的黄虚框表明有重复计算，下面我们开始考虑转移方程。</p><p>显然，砖块一旦选取了高，那么这块砖块上最大能放的高度是确定的。</p><p>某个砖块 i 有三种堆叠方式分别记为 0, 1, 2，那么对于砖块 i 和其堆叠方式 r 来说则有如下转移方程 <code>d(i, r) = max(d(j, r') + h')</code></p><p>其中 j 是所有那些在砖块 i 以 r 方式堆叠时可放上的砖块，r’ 对应 j 此时的摆放方式，也就确定了此时唯一的高度 h’。</p><p>在实际编写时，将所有 d(i, r) 都初始化为 -1，表示未计算过。</p><p>在试图计算前，如果发现已经计算过，直接返回保存的值；否则就按步计算，并保存。</p><p>最终答案是所有 d(i, r) 的最大值。</p></li></ul><h4 id="Accepted-Code-4"><a href="#Accepted-Code-4" class="headerlink" title="Accepted Code"></a>Accepted Code</h4><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#define _CRTSECURE_NOWARNINGS#pragma warning(disable:4996)#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;cmath&gt;#include&lt;cctype&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;vector&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;list&gt;using namespace std;#define MAXN 35#define MAXV 505int t;int d[MAXN][3];int x[MAXN], y[MAXN], z[MAXN];int babylon_sub(int c, int rot, int n){    if (d[c][rot] != -1)    {        return d[c][rot];    }    d[c][rot] = 0;    int base1 = 0, base2 = 0;    if (rot == 0)    {        base1 = x[c];        base2 = y[c];    }    if (rot == 1)    {        base1 = y[c];        base2 = z[c];    }    if (rot == 2)    {        base1 = x[c];        base2 = z[c];    }    for (int i = 0; i &lt; n; i++)    {        if ((x[i] &lt; base1 &amp;&amp; y[i] &lt; base2) || (y[i] &lt; base1 &amp;&amp; x[i] &lt; base2))            d[c][rot] = max(d[c][rot], babylon_sub(i, 0, n) + z[i]);        if ((y[i] &lt; base1 &amp;&amp; z[i] &lt; base2) || (z[i] &lt; base1 &amp;&amp; y[i] &lt; base2))            d[c][rot] = max(d[c][rot], babylon_sub(i, 1, n) + x[i]);        if ((x[i] &lt; base1 &amp;&amp; z[i] &lt; base2) || (z[i] &lt; base1 &amp;&amp; x[i] &lt; base2))            d[c][rot] = max(d[c][rot], babylon_sub(i, 2, n) + y[i]);    }        return d[c][rot];}int babylon(int n){    for (int i = 0; i &lt; n; i++)    {        d[i][0] = -1;        d[i][1] = -1;        d[i][2] = -1;    }    int r = 0;    for (int i = 0; i &lt; n; i++)    {        r = max(r, babylon_sub(i, 0, n) + z[i]);        r = max(r, babylon_sub(i, 1, n) + x[i]);        r = max(r, babylon_sub(i, 2, n) + y[i]);    }        return r;}int main(){    while (1)    {        int n;        scanf ("%d", &amp;n);        if (!n) return 0;        for (int i = 0; i &lt; n; i++)        {            scanf ("%d%d%d", &amp;x[i], &amp;y[i], &amp;z[i]);        }        printf ("Case %d: maximum height = %d\n", ++t, babylon(n));    }        return 0;    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="树形-DP"><a href="#树形-DP" class="headerlink" title="树形 DP"></a>树形 DP</h2><h3 id="简介-9"><a href="#简介-9" class="headerlink" title="简介"></a>简介</h3><p>树形 DP，即在树上进行的 DP。由于树固有的递归性质，树形 DP 一般都是递归进行的。</p><h3 id="特点-8"><a href="#特点-8" class="headerlink" title="特点"></a>特点</h3><ul><li>不存在环</li><li>具有明显而又严格的层数关系</li></ul><h3 id="建树"><a href="#建树" class="headerlink" title="建树"></a>建树</h3><p>如果节点数小于 5000，那么我们可以用邻接矩阵存储，如果更大可以用邻接表来存储（注意边要开到 2 * n，因为是双向的）。如果是二叉树或者是需要多叉转二叉，那么我们可以用两个一维数组 brother[], child[] 来存储</p><h3 id="树形-DP-方程"><a href="#树形-DP-方程" class="headerlink" title="树形 DP 方程"></a>树形 DP 方程</h3><p>通过观察孩子和父亲之间的关系建立方程。我们通常认为，树形DP的写法有两种：</p><ol><li>根到叶子，不过这种动态规划在实际的问题中运用的不多。</li><li>叶子到根：即根的子节点传递有用的信息给根，完后根得出最优解的过程。这类的习题比较的多。</li></ol><p>注：这两种写法一般情况下是不能相互转化的。但是有时可以同时使用</p><h3 id="加分二叉树"><a href="#加分二叉树" class="headerlink" title="加分二叉树"></a><a href="https://www.luogu.com.cn/problem/P1040">加分二叉树</a></h3><h4 id="Description-5"><a href="#Description-5" class="headerlink" title="Description"></a>Description</h4><p>设一个 n<em>n</em> 个节点的二叉树 tree 的中序遍历为 (1, 2, 3, …, n)，其中数字 1, 2, 3, …, n 为节点编号。每个节点都有一个分数（均为正整数），记第 i 个节点的分数为 d<sub>i</sub>，tree 及它的每个子树都有一个加分，任一棵子树 subtree（也包含 tree 本身）的加分计算方法如下：</p><p>subtree 的左子树的加分 × subtree 的右子树的加分 + subtree 的根的分数。</p><p>若某个子树为空，规定其加分为 1，叶子的加分就是叶节点本身的分数。不考虑它的空子树。</p><p>试求一棵符合中序遍历为 (1, 2, 3, …, n) 且加分最高的二叉树 tree。要求输出tree 的最高加分。tree 的前序遍历。</p><h4 id="Input-6"><a href="#Input-6" class="headerlink" title="Input"></a>Input</h4><p>第 1 行 1 个整数 n，为节点个数。</p><p>第 2 行 n 个用空格隔开的整数，为每个节点的分数</p><h4 id="Output-6"><a href="#Output-6" class="headerlink" title="Output"></a>Output</h4><p>第 1 行 1 个整数，为最高加分（ans ≤ 4,000,000,000）。</p><p>第 2 行 n 个用空格隔开的整数，为该树的前序遍历。</p><h4 id="Sample-Input-4"><a href="#Sample-Input-4" class="headerlink" title="Sample Input"></a>Sample Input</h4><pre class="line-numbers language-none"><code class="language-none">55 7 1 2 10<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="Sample-Output-4"><a href="#Sample-Output-4" class="headerlink" title="Sample Output"></a>Sample Output</h4><pre class="line-numbers language-none"><code class="language-none">1453 1 2 4 5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="Hint-2"><a href="#Hint-2" class="headerlink" title="Hint"></a>Hint</h4><p>n &lt; 30</p><p>分数 &lt; 100</p><h4 id="Solution-6"><a href="#Solution-6" class="headerlink" title="Solution"></a>Solution</h4><p>看到这个问题，我们首先应该想到的是这道题是否属于动态规划，而这里我们发现，结合问题，如果整棵树的权值最大，必然有左子树的权值最大，右子树的权值也最大，符合最优性原理。所以是动态规划。</p><p>而却不是一道树规的题目。因为我们可以用区间动规的模型解决掉：直接定义一个 f[i][j] 表示从 i 到 j 的最大值，则 <code>f[i][j] = max(f[i][k-1] * f[k+1][j] + f[k][k])</code>，枚举 k 即可。接下来是如何建树的问题，只有把树建好了，才能输出其前序遍历。于是，我们看到了两个关键词：二叉树，中序遍历。有了这两个关键词，加上区间动规，这棵树就能建起来了。根据二叉树的特性来建树。所以这颗树的前序遍历，只需要边动规边记录下 root[i][j] = k 表示 i 到 j 的根为 k 即可确定树的构造。</p><h4 id="Accepted-Code-5"><a href="#Accepted-Code-5" class="headerlink" title="Accepted Code"></a>Accepted Code</h4><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#define _CRTSECURE_NOWARNINGS#pragma warning(disable:4996)#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;cmath&gt;#include&lt;cctype&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;vector&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;list&gt;using namespace std;const int MAXN = 50;long long n;long long f[MAXN][MAXN], root[MAXN][MAXN];void print(long long l, long long r){    if (l &gt; r)return;    printf("%lld ", root[l][r]);    if (l == r)return;    print(l, root[l][r] - 1);    print(root[l][r]+1,r);}int main(){    scanf("%lld", &amp;n);    for (int i = 1; i &lt;= n; i++)    {        scanf("%lld", &amp;f[i][i]);        f[i][i-1] = 1;        root[i][i] = i;    }    for (int len = 1; len &lt; n; ++len)    {        for (int i = 1; i + len &lt;= n; ++i)        {            int j = i + len;            f[i][j] = f[i + 1][j] + f[i][i];    //默认它的左子树为空，如果有的话，这肯定不是最优解            root[i][j] = i; //默认从起点选根            for (int k = i + 1; k &lt; j; ++k)            {                if (f[i][j] &lt; f[i][k - 1] * f[k + 1][j] + f[k][k])                {                    f[i][j] = f[i][k - 1] * f[k + 1][j] + f[k][k];                    root[i][j] = k;                }            }        }    }        cout &lt;&lt; f[1][n] &lt;&lt; endl;    print(1, n);            return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="树上背包-·-选课"><a href="#树上背包-·-选课" class="headerlink" title="树上背包 · 选课"></a><a href="https://www.luogu.com.cn/problem/P2014">树上背包 · 选课</a></h3><h4 id="Description-6"><a href="#Description-6" class="headerlink" title="Description"></a>Description</h4><p>在大学里每个学生，为了达到一定的学分，必须从很多课程里选择一些课程来学习，在课程里有些课程必须在某些课程之前学习，如高等数学总是在其它课程之前学习。现在有 N 门功课，每门课有个学分，每门课有一门或没有直接先修课（若课程 a 是课程 b 的先修课即只有学完了课程 a，才能学习课程 b）。一个学生要从这些课程里选择 M 门课程学习，问他能获得的最大学分是多少？</p><h4 id="Input-7"><a href="#Input-7" class="headerlink" title="Input"></a>Input</h4><p>第一行有两个整数 N , M 用空格隔开。(1 ≤ N ≤ 300, 1 ≤ M ≤ 300) 接下来的 N 行,第 I + 1 行包含两个整数 k<sub>i</sub> 和 s<sub>i</sub>, k<sub>i</sub> 表示第I门课的直接先修课，s<sub>i</sub> 表示第 I 门课的学分。若 k<sub>i</sub> = 0 表示没有直接先修课（1 ≤ k<sub>i</sub> ≤ N, 1 ≤ s<sub>i</sub> ≤ 20）。</p><h4 id="Output-7"><a href="#Output-7" class="headerlink" title="Output"></a>Output</h4><p>只有一行，选 M 门课程的最大得分。</p><h4 id="Sample-Input-5"><a href="#Sample-Input-5" class="headerlink" title="Sample Input"></a>Sample Input</h4><pre class="line-numbers language-none"><code class="language-none">7  42  20  10  42  17  17  62  2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Sample-Output-5"><a href="#Sample-Output-5" class="headerlink" title="Sample Output"></a>Sample Output</h4><pre class="line-numbers language-none"><code class="language-none">13<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="Solution-7"><a href="#Solution-7" class="headerlink" title="Solution"></a>Solution</h4><p>这道题的意思是每本书要想选择一门课，必须要先学会它的必修课，所以这就形成了一种依赖行为，即选择一门课必须要选择必修课。那么他又说要选择的价值最大，这就要用到树形背包的知识了。</p><p>树形背包的基本代码形式（即上面的树形背包类）</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">/*设dp[i][j]表示选择以i为根的子树中j个节点。u代表当前根节点，tot代表其选择的节点的总额。*/void dfs(int u,int tot){for(int i = head[x]; i; i = e[i].next){int v = e[i].to;for(int k = 0; k &lt; tot; k++)//这里k从o开始到tot-1，因为v的子树可以选择的节点是u的子树的节点数减一dp[v][k] = dp[u][k] + val[u];dfs(v, tot - 1);for(int k = 1; k &lt;= tot; k++)dp[u][k] = max(dp[u][k], dp[v][k-1]);//这里是把子树的值赋给了根节点，因为u选择k个点v只能选择k-1个点。}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Accepted-Code-6"><a href="#Accepted-Code-6" class="headerlink" title="Accepted Code"></a>Accepted Code</h4><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#define _CRTSECURE_NOWARNINGS#pragma warning(disable:4996)#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;cmath&gt;#include&lt;cctype&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;vector&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;list&gt;using namespace std;int n,m;struct edge{    int next,to;}e[1000];int rt, head[1000], tot, val[1000], dp[1000][1000];void add(int x,int y){    e[++tot].next=head[x];    head[x] = tot;    e[tot].to = y;}void dfs(int u, int t){    if (t &lt;= 0) return;    for (int i = head[u]; i; i = e[i].next)    {        int v = e[i].to;        for (int k = 0; k &lt; t; ++k)            dp[v][k] = dp[u][k] + val[v];        dfs(v, t - 1);        for (int k = 1; k &lt;= t; ++k)            dp[u][k] = max(dp[u][k], dp[v][k-1]);    }}int main(){    scanf("%d%d", &amp;n, &amp;m);    for(int i = 1; i &lt;= n; i++)    {        int a;        scanf("%d%d", &amp;a, &amp;val[i]);        if(a)  add(a, i);        if(!a) add(0, i);    }        dfs(0, m);        printf("%d", dp[0][m]);        return 0;    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="状压-DP"><a href="#状压-DP" class="headerlink" title="状压 DP"></a>状压 DP</h2><h3 id="简介-10"><a href="#简介-10" class="headerlink" title="简介"></a>简介</h3><p>状压 dp 是动态规划的一种，通过将状态压缩为整数来达到优化转移的目的。</p><h3 id="互不侵犯"><a href="#互不侵犯" class="headerlink" title="互不侵犯"></a><a href="https://www.luogu.com.cn/problem/P1896">互不侵犯</a></h3><h4 id="Descrpition-1"><a href="#Descrpition-1" class="headerlink" title="Descrpition"></a>Descrpition</h4><p>在 N × N 的棋盘里面放 K 个国王，使他们互不攻击，共有多少种摆放方案。国王能攻击到它上下左右，以及左上左下右上右下八个方向上附近的各一个格子，共 8 个格子。</p><h4 id="Input-8"><a href="#Input-8" class="headerlink" title="Input"></a>Input</h4><p>只有一行，包含两个数 N，K (1 &lt;= N &lt;=9, 0 &lt;= K &lt;= N * N)</p><h4 id="Output-8"><a href="#Output-8" class="headerlink" title="Output"></a>Output</h4><p>所得的方案数</p><h4 id="Sample-Input-6"><a href="#Sample-Input-6" class="headerlink" title="Sample Input"></a>Sample Input</h4><pre class="line-numbers language-none"><code class="language-none">3 2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="Sample-Output-6"><a href="#Sample-Output-6" class="headerlink" title="Sample Output"></a>Sample Output</h4><pre class="line-numbers language-none"><code class="language-none">16<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="Solution-8"><a href="#Solution-8" class="headerlink" title="Solution"></a>Solution</h4><p>首先，看到这一题，就知道如果不是搜索，就是 DP。当然搜索是过不了的，所以就应该尝试想出一个 DP 的解法。</p><p>DP 的前提之一当然是要找出一个可以互相递推的状态。显然，目前已使用的国王个数当然必须是状态中的一个部分，因为这是一个限制条件。那么除此之外另外的部分是什么呢？</p><p>我们考虑到每行每列之间都有互相的约束关系。因此，我们可以用行和列作为另一个状态的部分（矩阵状压 DP 常用行作为状态，一下的论述中也用行作为状态）。</p><p>又看到数据范围： 1 &lt;= N &lt;= 9。这里我们就可以用一个新的方法表示行和列的状态：数字。考虑任何一个十进制数都可以转化成一个二进制数，而一行的状态就可以表示成这样——例如：</p><p>1010 (2 进制)</p><p>就表示：这一行的第一个格子没有国王，第二个格子放了国王，第三个格子没有放国王，第四个格子放了国王（注意，格子从左到右的顺序是与二进制从左到右的顺序相反的，因为真正在程序进行处理的时候就像是这样的）。而这个二进制下的数就可以转化成十进制：</p><p>10 (10)</p><p>于是，我们的三个状态就有了：第几行（用 i 表示）、此行放什么状态（用 j 表示）、包括这一行已经使用了的国王数（用 s 表示）。</p><p>考虑状态转移方程。我们预先处理出每一个状态（sit[x]）其中包含二进制下 1 的个数，及此状态下这一行放的国王个数（gs[x]），于是就有：</p><p><code>f[i][j][s] = sum(f[i−1][k][s−gs[j]])</code>，f[i][j][s] 就表示在只考虑前 i 行时，在前 i 行（包括第 i 行）有且仅有 s 个国王，且第 i 行国王的情况是编号为 j 的状态时情况的总数。而 k 就代表第 i - 1 行的国王情况的状态编号</p><p>其中 k 在 1 到 n 之间，j 与 k 都表示状态的编号，且 k 与 j 必须满足两行之间国王要满足的关系。（对于这一点的处理我们待会儿再说）</p><p>这个状态转移方程也十分好理解。其实就是上一行所有能够与这一行要使用的状态切合的状态都计入状态统计的加和当中。其中 i, j, s, k 都要枚举。</p><p>再考虑国王之间的关系该如何处理呢？在同一行国王之间的关系我们可以直接在预处理状态时舍去那些不符合题意的状态，而相邻行之间的关系我们就可以用到一个高端的东西：位运算。由于状态已经用数字表示了，因此我们可以用与（∧）运算来判断两个状态在同一个或者相邻位置是否都有国王——如果：</p><p>sit[j] &amp; sit[k] (及上下有重复的king)</p><p>(sit[j] &lt;&lt; 1) &amp; sit[k] (及左上右下有重复king)</p><p>sit[j] &amp; (sit[k]&lt;&lt;1) (及右上左下有重复king)</p><p>这样就可以处理掉那些不符合题意的状态了。</p><p>总结一下。其实状压 DP 不过就是将一个状态转化成一个数，然后用位运算进行状态的处理。理解了这一点，其实就跟普通的 DP 没有什么两样了。</p><h4 id="Accepted-Code-7"><a href="#Accepted-Code-7" class="headerlink" title="Accepted Code"></a>Accepted Code</h4><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#define _CRTSECURE_NOWARNINGS#pragma warning(disable:4996)#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;cmath&gt;#include&lt;cctype&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;vector&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;list&gt;using namespace std;int sit[2000], gs[2000];int cnt = 0;int n, yong;long long f[10][2000][100], ans;void dfs(int he, int sum, int node) //预处理出每一个状态{    if(node &gt;= n)   //如果已经处理完毕（注意是大于等于）    {        sit[++cnt] = he;        gs[cnt] = sum;        return; //新建一个状态    }        dfs(he, sum, node + 1); //不用第node个    dfs(he + (1 &lt;&lt; node), sum + 1, node + 2);   //用第node个，此时node要加2，及跳过下一个格子}int main(){    scanf("%d%d", &amp;n, &amp;yong);    dfs(0, 0, 0);    for(int i = 1; i &lt;= cnt; i++) f[1][i][gs[i]] = 1;   //第一层的所有状态均是有1种情况的    for(int i = 2; i &lt;= n; i++)        for(int j = 1; j &lt;= cnt; j++)            for(int k = 1; k &lt;= cnt; k++)   //枚举i、j、k            {                if(sit[j] &amp; sit[k]) continue;                if((sit[j] &lt;&lt; 1) &amp; sit[k]) continue;                if(sit[j] &amp; (sit[k] &lt;&lt; 1)) continue;    //排除不合法国王情况                for(int s = yong; s &gt;= gs[j]; s--)  //枚举s，计算f[i][j][s]                    f[i][j][s] += f[i-1][k][s-gs[j]];            }        for(int i = 1; i &lt;= cnt; i++)        ans += f[n][i][yong];   //统计最终答案，记得用long long    printf("%lld", ans);        return 0;    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="数位-DP"><a href="#数位-DP" class="headerlink" title="数位 DP"></a>数位 DP</h2><h3 id="简介-11"><a href="#简介-11" class="headerlink" title="简介"></a>简介</h3><p>数位 DP 问题往往都是这样的题型，给定一个闭区间 [l, r]，让你求这个区间中满足 <strong>某种条件</strong> 的数的总数。 </p><h3 id="数字计数"><a href="#数字计数" class="headerlink" title="数字计数"></a><a href="https://www.luogu.com.cn/problem/P2602">数字计数</a></h3><h4 id="Description-7"><a href="#Description-7" class="headerlink" title="Description"></a>Description</h4><p>给定两个正整数 a<em>a</em> 和 b<em>b</em>，求在 [a,b][<em>a</em>,<em>b</em>] 中的所有整数中，每个数码(digit)各出现了多少次。</p><h4 id="Input-9"><a href="#Input-9" class="headerlink" title="Input"></a>Input</h4><p>仅包含一行两个整数 a,b<em>a</em>,<em>b</em>，含义如上所述。</p><h4 id="Output-9"><a href="#Output-9" class="headerlink" title="Output"></a>Output</h4><p>包含一行十个整数，分别表示 0∼90∼9 在 [a,b][<em>a</em>,<em>b</em>] 中出现了多少次。</p><h4 id="Sample-Input-7"><a href="#Sample-Input-7" class="headerlink" title="Sample Input"></a>Sample Input</h4><pre class="line-numbers language-none"><code class="language-none">1 99<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="Sample-Output-7"><a href="#Sample-Output-7" class="headerlink" title="Sample Output"></a>Sample Output</h4><pre class="line-numbers language-none"><code class="language-none">9 20 20 20 20 20 20 20 20 20<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="Hint-3"><a href="#Hint-3" class="headerlink" title="Hint"></a>Hint</h4><ul><li>对于 30% 的数据，保证 a ≤ b ≤ 10<sup>6</sup>；</li><li>对于 100% 的数据，保证 1 ≤ a ≤ b ≤ 10<sup>12</sup>。</li></ul><h4 id="Solution-9"><a href="#Solution-9" class="headerlink" title="Solution"></a>Solution</h4><p>f[i] 代表在有i位数字的情况下，每个数字有多少个。如果不考虑前导 0，你会发现对于每一个数，它的数量都是相等的，也就是 f[i] = f[i-1] * 10 + 10<sup>i - 1</sup>;</p><p>我们先设数字为 ABCD</p><p>看 A000，如果我们要求出它所有数位之和，我们会怎么求？</p><p>鉴于我们其实已经求出了 0 ~ 9, 0 ~ 99, 0 ~ 999… 上所有数字个数（f[i], 且没有考虑前导 0）我们何不把这个 A000 看成 0000 ~ 1000 ~ 2000… A000 对于不考虑首位每一个式子的数字的出现个数为 A * f[3]。加上首位出现也就是小于 A 每一个数都出现了 10<sup>3</sup> 次，再加上，我们就把 A000 处理完了。</p><p>这样你以为就把第一位处理完了？不不不，首位 A 还出现了 BCD + 1 次呢，也就是从 A000 ~ ABCD，这个 A 还出现了 BCD + 1 次，所以再加上这些才行呢。那么你发现，我们成功把首位代表的所有数字个数求出来了，剩下的求解与 A 完全没有任何关系，只是 BCD 的求解，于是我们发现我们已经把一个大问题，化成了一个个小问题，也即是，对于一个这样 n 位的数，把他一位位的分离开来。</p><p>当然你还需要处理前导 0 你会发现前导 0 一定是 0001, 0002, …, 0012, 0013, …, 0101, 0102, …, 0999 这样的数，一共出现了 10 *(i - 1) + 10 * (i - 2) + … 10 (i 表示数字位数），让 0 的统计减去这个值，那么恭喜你这道题做完了。</p><p>总结 对于 DP 这个东西，最重要的其实只有一点，推状态，状态又是什么？是大问题的子问题，对于这种题最重要的特点是，无后效性，问题可拆分，并且答案的求解具有一定的规律，这样的题应该就可以用 DP 做，数位 DP 最重要的就是把一整个数字拆分成一位一位的单独来看，那么对于数位 DP，它的子问题也就一般是每一位上对于答案的求解，层层递进的这么一个思路。</p><h4 id="Accepted-Code-8"><a href="#Accepted-Code-8" class="headerlink" title="Accepted Code"></a>Accepted Code</h4><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#define _CRTSECURE_NOWARNINGS#pragma warning(disable:4996)#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;cmath&gt;#include&lt;cctype&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;vector&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;list&gt;using namespace std;long long a,b;long long ten[20],f[20];long long cnta[20],cntb[20];void solve(long long x,long long *cnt){    long long num[20]={0};    int len=0;    while(x)    {        num[++len]=x%10;        x=x/10;    }    for(int i=len;i&gt;=1;i--)    {        for(int j=0;j&lt;=9;j++)        cnt[j]+=f[i-1]*num[i];        for(int j=0;j&lt;num[i];j++)        cnt[j]+=ten[i-1];        long long num2=0;        for(int j=i-1;j&gt;=1;j--)        {            num2=num2*10+num[j];        }        cnt[num[i]]+=num2+1;        cnt[0]-=ten[i-1];    }}int main(){    scanf("%lld %lld",&amp;a,&amp;b);    ten[0]=1;    for(int i=1;i&lt;=15;i++)    {        f[i]=f[i-1]*10+ten[i-1];        ten[i]=10*ten[i-1];    }    solve(a-1,cnta);    solve(b,cntb);    for(int i=0;i&lt;=9;i++)    printf("%lld ",cntb[i]-cnta[i]);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> DP </tag>
            
            <tag> 区间DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vim</title>
      <link href="2021/04/27/2021-4-27-vim/"/>
      <url>2021/04/27/2021-4-27-vim/</url>
      
        <content type="html"><![CDATA[<h1 id="Vim"><a href="#Vim" class="headerlink" title="Vim"></a>Vim</h1><h2 id="What-is-Vim"><a href="#What-is-Vim" class="headerlink" title="What is Vim?"></a>What is Vim?</h2><blockquote><p>Vim is a greatly improved version of the good old UNIX editor Vi. Many new features have been added: multi-level undo, syntax highlighting, command line history, on-line help, spell checking, filename completion, block operations, script language, etc. There is also a Graphical User Interface (GUI) available. Still, Vi compatibility is maintained, those who have Vi “in the fingers” will feel at home. See runtime/doc/vi_diff.txt for differences with Vi.</p><p>This editor is very useful for editing programs and other plain text files. All commands are given with normal keyboard characters, so those who can type with ten fingers can work very fast. Additionally, function keys can be mapped to commands by the user, and the mouse can be used.</p><p>Vim runs under MS-Windows (XP, Vista, 7, 8, 10), macOS, Haiku, VMS and almost all flavours of UNIX. Porting to other systems should not be very difficult. Older versions of Vim run on MS-DOS, MS-Windows 95/98/Me/NT/2000, Amiga DOS, Atari MiNT, BeOS, RISC OS and OS/2. These are no longer maintained.</p><p>——Github/Vim</p></blockquote><h2 id="How-to-use-Vim"><a href="#How-to-use-Vim" class="headerlink" title="How to use Vim?"></a>How to use Vim?</h2><p>In Terminal</p><ul><li><p><code>vim</code> : Open Vim</p></li><li><p><code>vim [filename]</code> : Open [filename] in Vim </p></li></ul><h2 id="Modes"><a href="#Modes" class="headerlink" title="Modes"></a>Modes</h2><p>In Vim, there are three modes of operation: Normal, Insert, and Visual.</p><h3 id="Normal-mode"><a href="#Normal-mode" class="headerlink" title="Normal mode"></a>Normal mode</h3><p>Normal mode is the initial mode of the Vim editor. When you open a new file edit an existing one, it starts in normal mode by default. In normal mode, you cannot insert any character. Normal mode is also known as command mode because all the keystrokes you perform are interpreted as commands.</p><p><strong>To access normal mode from other modes, press <code>Esc</code> key.</strong></p><h3 id="Insert-mode"><a href="#Insert-mode" class="headerlink" title="Insert mode"></a>Insert mode</h3><p>Insert mode is where you can insert your text in the file. This mode inserts every character you type at the current cursor location.</p><h3 id="Visual-mode"><a href="#Visual-mode" class="headerlink" title="Visual mode"></a>Visual mode</h3><p>Visual mode allows you to select text so that you may perform certain operations (cut, copy, delete) on it.</p><h3 id="Changing-the-modes"><a href="#Changing-the-modes" class="headerlink" title="Changing the modes"></a>Changing the modes</h3><ul><li>When creating or opening a file in vim, it first opens in Normal mode.</li><li>Switch to Insert mode from Normal mode: <code>i</code> or <code>I</code>, <code>o</code>, <code>O</code>, <code>a</code>, <code>A</code>.</li><li>Switch to Visual mode from Normal mode: <code>v</code> or <code>V</code></li><li>Switch between Inset mode and Visual mode: shift to Normal mode first.</li></ul><h2 id="Commands-in-Normal-mode"><a href="#Commands-in-Normal-mode" class="headerlink" title="Commands (in Normal mode)"></a>Commands (in Normal mode)</h2><h3 id="File-related-commands"><a href="#File-related-commands" class="headerlink" title="File related commands"></a>File related commands</h3><table><thead><tr><th align="left">Key</th><th align="left">Command</th></tr></thead><tbody><tr><td align="left"><code>:w</code></td><td align="left">Write the file to the disk</td></tr><tr><td align="left"><code>:w [filename]</code></td><td align="left">Save the file as <em>[filename]</em></td></tr><tr><td align="left"><code>:q</code></td><td align="left">Quit vi without saving the file</td></tr><tr><td align="left"><code>:wq</code></td><td align="left">Write the file to disk and quit vim</td></tr><tr><td align="left"><code>:wq [filename]</code></td><td align="left">Quit and save the file as [filename]</td></tr><tr><td align="left"><code>:q!</code></td><td align="left">Ignore the warning and discard the change</td></tr></tbody></table><h3 id="Moving-the-cursor"><a href="#Moving-the-cursor" class="headerlink" title="Moving the cursor"></a>Moving the cursor</h3><table><thead><tr><th>Key</th><th>Command</th></tr></thead><tbody><tr><td><code>h</code> / <code>Left</code></td><td>Move the cursor <strong>left</strong> one <strong>character</strong></td></tr><tr><td><code>j</code> / <code>Down</code></td><td>Move the cursor <strong>down</strong> one <strong>line</strong></td></tr><tr><td><code>k</code> / <code>Up</code></td><td>Move the cursor <strong>up</strong> one <strong>line</strong></td></tr><tr><td><code>l</code> / <code>Right</code></td><td>Move the cursor <strong>right</strong> one <strong>character</strong></td></tr><tr><td><code>w</code></td><td>Move the cursor <strong>forward</strong> one <strong>word</strong></td></tr><tr><td><code>b</code></td><td>Move the cursor <strong>backward</strong> one <strong>word</strong></td></tr><tr><td><code>Control</code> <code>f</code> / <code>Page Down</code></td><td>Move the cursor <strong>forward</strong> one <strong>page</strong></td></tr><tr><td><code>Control</code> <code>b</code> / <code>Page Up</code></td><td>Move the cursor <strong>backward</strong> one <strong>page</strong></td></tr><tr><td><code>[number]gg</code></td><td>Move the cursor to line [number]</td></tr><tr><td><code>[number]j</code></td><td>Move the cursor <strong>down</strong> [number] lines</td></tr><tr><td><code>[number]k</code></td><td>Move the cursor <strong>up</strong> [number] lines</td></tr></tbody></table><h3 id="Finding-text"><a href="#Finding-text" class="headerlink" title="Finding text"></a>Finding text</h3><table><thead><tr><th>Key</th><th>Command</th></tr></thead><tbody><tr><td><code>/[text]</code></td><td>Find all [text]</td></tr><tr><td><code>n</code></td><td>Move to next [text]</td></tr><tr><td><code>Shift</code> <code>n</code></td><td>Move to previous [text]</td></tr></tbody></table><h3 id="Inserting-text"><a href="#Inserting-text" class="headerlink" title="Inserting text"></a>Inserting text</h3><table><thead><tr><th>Key</th><th>Command</th></tr></thead><tbody><tr><td><code>I</code></td><td>Insert text at the beginning of the line</td></tr><tr><td><code>i</code></td><td>Insert text before the current cursor location</td></tr><tr><td><code>a</code></td><td>Insert text after the current cursor location</td></tr><tr><td><code>o</code></td><td>Create a new line for the text below the current cursor location</td></tr><tr><td><code>O</code></td><td>Create a new line for text above the current cursor location</td></tr></tbody></table><h3 id="Changing-text"><a href="#Changing-text" class="headerlink" title="Changing text"></a>Changing text</h3><table><thead><tr><th>Key</th><th>Command</th></tr></thead><tbody><tr><td><code>cc</code></td><td>Remove the whole line and start Insert mode</td></tr><tr><td><code>c[number]c</code></td><td>Remove the whole [number] lines and start Insert mode</td></tr><tr><td><code>s</code></td><td>Remove the character under the cursor and start Insert mode</td></tr><tr><td><code>r</code></td><td>Replace the character under the cursor</td></tr></tbody></table><h3 id="Copying-amp-Pasting"><a href="#Copying-amp-Pasting" class="headerlink" title="Copying &amp; Pasting"></a>Copying &amp; Pasting</h3><table><thead><tr><th>Key</th><th>Command</th></tr></thead><tbody><tr><td><code>y</code></td><td>Copy the selected text to clipboard</td></tr><tr><td><code>yy</code></td><td>Copy current line</td></tr><tr><td><code>P</code></td><td>insert the text <strong>before</strong> the cursor</td></tr><tr><td><code>p</code></td><td>Insert the text at the point after the cursor</td></tr></tbody></table><h3 id="Deleting-text"><a href="#Deleting-text" class="headerlink" title="Deleting text"></a>Deleting text</h3><table><thead><tr><th>Key</th><th>Command</th></tr></thead><tbody><tr><td><code>X</code></td><td>Delete the character before the current location</td></tr><tr><td><code>x</code></td><td>Delete the character under the current location</td></tr><tr><td><code>D</code></td><td>Cut to the end of line</td></tr><tr><td><code>dd</code></td><td>Cut current line</td></tr></tbody></table><h3 id="Undo-amp-Redo"><a href="#Undo-amp-Redo" class="headerlink" title="Undo &amp; Redo"></a>Undo &amp; Redo</h3><table><thead><tr><th>Key</th><th>Command</th></tr></thead><tbody><tr><td><code>u</code></td><td>Undo last change</td></tr><tr><td><code>Control</code> <code>r</code></td><td>Redo last change</td></tr></tbody></table><h2 id="Customize-Vim"><a href="#Customize-Vim" class="headerlink" title="Customize Vim"></a>Customize Vim</h2><p>Enter <code>vim ~/.vimrc</code> in Terminal</p><ul><li><code>syntax on</code> : Code highlighting</li><li><code>set number</code> : Line number</li></ul>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>KMP</title>
      <link href="2021/04/12/2021-4-12-kmp/"/>
      <url>2021/04/12/2021-4-12-kmp/</url>
      
        <content type="html"><![CDATA[<h1 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h1><h2 id="问题引入"><a href="#问题引入" class="headerlink" title="问题引入"></a>问题引入</h2><p>给定 2 个字符串 text 和 pattern，在 text 中寻找是否存在 pattern 这个子串（连续）</p><h3 id="传统方法-•-暴力"><a href="#传统方法-•-暴力" class="headerlink" title="传统方法 • 暴力"></a>传统方法 • 暴力</h3><h4 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h4><p>从第一位开始，对两个字符串进行逐位比对， 不相等则从下一位开始逐位比对</p><h4 id="复杂度-•-O-mn"><a href="#复杂度-•-O-mn" class="headerlink" title="复杂度 • O(mn)"></a>复杂度 • O(mn)</h4><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p>KMP 算法是一种改进的字符串匹配算法，由 D.E.Knuth，J.H.Morris 和 V.R.Pratt 提出的，因此人们称它为克努特—莫里斯—普拉特操作（简称 KMP 算法）。KMP 算法的核心是利用匹配失败后的信息，尽量减少模式串与主串的匹配次数以达到快速匹配的目的。具体实现就是通过一个 next() 函数实现，函数本身包含了模式串的局部匹配信息。</p><p>KMP 算法是三位学者在 Brute-Force 算法的基础上同时提出的模式匹配的改进算法。Brute- Force 算法在模式串中有多个字符和主串中的若干个连续字符比较都相等，但最后一个字符比较不相等时，主串的比较位置需要回退。KMP 算法在上述情况下，主串位置不需要回退，从而可以大大提高效率</p></blockquote><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>不难发现，暴力的方法进行了大量的无效比对。如以下这个例子：text: “aaaaaaaaab”, pattern: “aaaab”<br>每次都对比到第 n 位才发现不相等，后移一 位后又从第一位开始比对，因此可以创造 一种算法，先对 pattern 字符串进行预处理，标记上前缀与后缀相等的长度，之后再进行比对时，当比对到不相等的位置时，由于已知前缀与后缀相等的长度，因此可以跳过这一段，比对之后的串即可。</p><p>例子中， 当比对第 1 位时，</p><table><thead><tr><th>pos</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th></tr></thead><tbody><tr><td>text</td><td>a</td><td>a</td><td>a</td><td>a</td><td>a</td><td>a</td><td>a</td><td>a</td><td>a</td><td>b</td></tr><tr><td>pattern</td><td>a</td><td>a</td><td>a</td><td>a</td><td>b</td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>前 4 位都相等，到了第 5 位时不相等，而对 pattern 串，除去不相等的第 5 位，前 4 位中的前缀与后缀的相等长度为 2（1, 2与 3, 4相等），而经过比比对，3, 4 位已经与 text 对应相等，因此可以把第 1, 2 位直接移到此位置即可，减少无效比对。</p><table><thead><tr><th>pos</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th></tr></thead><tbody><tr><td>text</td><td>a</td><td>a</td><td>a</td><td>a</td><td>a</td><td>a</td><td>a</td><td>a</td><td>a</td><td>b</td></tr><tr><td>pattern</td><td></td><td></td><td>a</td><td>a</td><td>a</td><td>a</td><td>b</td><td></td><td></td><td></td></tr></tbody></table><h2 id="做法-1"><a href="#做法-1" class="headerlink" title="做法"></a>做法</h2><ol><li><p>对 pattern 进行预处理得到 pattern 的前缀表 prefix table</p><p>逐位判断前后缀相等长度，保存在 prefix 数组</p><p>将 prefix 数组整体后移 1 位，prefix[0] = -1</p></li><li><p>KMP<br>两串相等继续；不相等则将 pattern 的指针 j 指向 pattern[j]</p></li></ol><h2 id="复杂度-•-O-m-n"><a href="#复杂度-•-O-m-n" class="headerlink" title="复杂度 • O(m + n)"></a>复杂度 • O(m + n)</h2><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define _CRTSECURE_NOWARNINGS#pragma warning(disable:4996)#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;cmath&gt;#include&lt;cctype&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;vector&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;list&gt;using namespace std;const int MAX_LEN = 10000017;int lenpattern, lentext;char pattern[MAX_LEN];char text[MAX_LEN];int prefix[MAX_LEN];void prefix_table(){prefix[0] = 0;int len = 0;int i = 1;while (i &lt; lenpattern){if (pattern[i] == pattern[len]){len++;prefix[i] = len;i++;}else{if (len &gt; 0) len = prefix[len - 1];else{prefix[i] = len;i++;}}}}void move_prefix_table(){for (int i = lenpattern - 1; i &gt; 0; i--) prefix[i] = prefix[i - 1];prefix[0] = -1;}void kmp_search(){prefix_table();move_prefix_table();int i = 0, j = 0;while (i &lt; lentext){if (j == lenpattern - 1 &amp;&amp; text[i] == pattern[j]){printf("Found pattern at %d\n", i - j);j = prefix[j];if (j == -1){i++;j++;}}else{if (text[i] == pattern[j]){i++;j++;}else{j = prefix[j];if (j == -1){i++;j++;}}}}}int main(){scanf("%s", text);scanf("%s", pattern);lentext = strlen(text);lenpattern = strlen(pattern);kmp_search();return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>text: 目标字符串</p><p>pattern: 匹配字符串</p><h2 id="101466E-•-Text-Editor"><a href="#101466E-•-Text-Editor" class="headerlink" title="101466E • Text Editor"></a><a href="https://codeforces.com/gym/101466/problem/E">101466E • Text Editor</a></h2><p>time limit per test: 1 second</p><p>memory limit per test: 512 megabytes</p><p>input: standard input</p><p>output: standard output</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>One of the most useful tools nowadays are text editors, their use is so important that the Unique Natural Advanced Language (UNAL) organization has studied many of the benefits working with them.</p><p>They are interested specifically in the feature “find”, that option looks when a pattern occurs in a text, furthermore, it counts the number of times the pattern occurs in a text. The tool is so well designed that while writing each character of the pattern it updates the number of times that the corresponding prefix of the total pattern appears on the text.</p><p>Now the UNAL is working with the editor, finding patterns in some texts, however, they realize that many of the patterns appear just very few times in the corresponding texts, as they really want to see more number of appearances of the patterns in the texts, they put a lower bound on the minimum number of times the pattern should be found in the text and use only prefixes of the original pattern. On the other hand, the UNAL is very picky about language, so they will just use the largest non-empty prefix of the original pattern that fit into the bound.</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The first line contains the text <em>A</em> (1 ≤ |<em>A</em>| ≤  10<sup>5</sup>) The second line contains the original pattern <em>B</em> (1 ≤ |<em>B</em>| ≤  |<em>A</em>|) The third line contains an integer <em>n</em> (1 ≤ <em>n</em> ≤  |<em>A</em>|) - the minimum number of times a pattern should be found on the text.</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>A single line, with the prefix of the original pattern used by the UNAL, if there is no such prefix then print “IMPOSSIBLE” (without the quotes)</p><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h3><h4 id="Input-1"><a href="#Input-1" class="headerlink" title="Input 1"></a>Input 1</h4><pre class="line-numbers language-none"><code class="language-none">aaaaaaaa4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="Output-1"><a href="#Output-1" class="headerlink" title="Output 1"></a>Output 1</h4><pre class="line-numbers language-none"><code class="language-none">aa<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="Input-2"><a href="#Input-2" class="headerlink" title="Input 2"></a>Input 2</h4><pre class="line-numbers language-none"><code class="language-none">programmingunal1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="Output-2"><a href="#Output-2" class="headerlink" title="Output 2"></a>Output 2</h4><pre class="line-numbers language-none"><code class="language-none">IMPOSSIBLE<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="Input-3"><a href="#Input-3" class="headerlink" title="Input 3"></a>Input 3</h4><pre class="line-numbers language-none"><code class="language-none">abracadabraabra1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="Output-3"><a href="#Output-3" class="headerlink" title="Output 3"></a>Output 3</h4><pre class="line-numbers language-none"><code class="language-none">abra<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="Input-4"><a href="#Input-4" class="headerlink" title="Input 4"></a>Input 4</h4><pre class="line-numbers language-none"><code class="language-none">Hello World!H W5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="Output-4"><a href="#Output-4" class="headerlink" title="Output 4"></a>Output 4</h4><pre class="line-numbers language-none"><code class="language-none">IMPOSSIBLE<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>把 B 字符串对 A 字符串进行 KMP。</p><p>但是如果单纯的从长到短 KMP 的话复杂度为 O(n<sup>2</sup>)，因此要对长度进行二分。</p><h3 id="Accepted-Code"><a href="#Accepted-Code" class="headerlink" title="Accepted Code"></a>Accepted Code</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define _CRTSECURE_NOWARNINGS#pragma warning(disable:4996)#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;cmath&gt;#include&lt;cctype&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;vector&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;list&gt;using namespace std;const int MAX_LEN = 10000017;int n;int lenpattern, lentext;char pattern[MAX_LEN];char text[MAX_LEN];int prefix[MAX_LEN];void prefix_table(){prefix[0] = 0;int len = 0;int i = 1;while (i &lt; lenpattern){if (pattern[i] == pattern[len]){len++;prefix[i] = len;i++;}else{if (len &gt; 0) len = prefix[len - 1];else{prefix[i] = len;i++;}}}}void move_prefix_table(){for (int i = lenpattern; i &gt; 0; i--) prefix[i] = prefix[i - 1];prefix[0] = -1;}int kmp_search(int x){int cnt = 0;int i = 0, j = 0;while (i &lt; lentext){if (j == x - 1 &amp;&amp; text[i] == pattern[j]){cnt++;j = prefix[j];if (j == -1){i++;j++;}}else{if (text[i] == pattern[j]){i++;j++;}else{j = prefix[j];if (j == -1){i++;j++;}}}}return cnt;}int main(){freopen("in.txt", "r", stdin);gets_s(text);gets_s(pattern);scanf("%d", &amp;n);lenpattern = strlen(pattern);lentext = strlen(text);prefix_table();move_prefix_table();int l = 0, r = lenpattern, mid, ans = 0;while (l &lt;= r){int mid = (l + r) / 2;if (kmp_search(mid) &gt;= n){ans = mid;l = mid + 1;}else r = mid - 1;}if (ans){for (int i = 0; i &lt; ans; i++) printf("%c", pattern[i]);}else printf("IMPOSSIBLE");        return 0;    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> KMP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qualified for ZJCPC 2021</title>
      <link href="2021/04/02/2021-4-2-qualified-for-zjcpc-2021/"/>
      <url>2021/04/02/2021-4-2-qualified-for-zjcpc-2021/</url>
      
        <content type="html"><![CDATA[<h1 id="Qualified-for-ZJCPC-2021"><a href="#Qualified-for-ZJCPC-2021" class="headerlink" title="Qualified for ZJCPC 2021"></a>Qualified for ZJCPC 2021</h1><p>2021.3.31，我们实验室举行了2021年浙江省赛的选拔赛，我们学校总共有8支队伍的名额。虽然最终我们 Accepted-Graph 队获得了省赛的资格，但是一路可谓是跌宕起伏，幸好最后是有惊无险</p><h2 id="The-Qualification-Trial"><a href="#The-Qualification-Trial" class="headerlink" title="The Qualification Trial"></a>The Qualification Trial</h2><p>这次比赛学长说题目很简单，但是由于我们的的能力问题，总共只 AC 了四道题：A, H, I, J. 其中 A, H, J 是签到题……</p><h3 id="A-•-Array-Permutation"><a href="#A-•-Array-Permutation" class="headerlink" title="A • Array Permutation"></a>A • Array Permutation</h3><h4 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h4><blockquote><p>Little H is so boring that he wants to generate an array of length n.</p><p>Little H uses the following method to generate the array.</p><ul><li>Suppose the current array length is m(m &lt; n). Then he will randomly generate a number x from [1, n − m]. Then he will follow the ordered permutation of [1, x](such as x = 3, the ordered permutation is [1, 2, 3]) after the array.</li><li>If the length of the array after the append operation is completed is n，then finish the entire process, otherwise repeat the above steps.</li></ul><p>Now little H want to know how many different arrays there are for a certain n。</p><p>Due to the limited ability of counting little H, you just need to output the answer modulo 10<sup>9</sup> + 7.</p></blockquote><h4 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h4><blockquote><p>There are several test cases.</p><p>The first line contains a single integer T(1 ≤ T ≤ 10<sup>3</sup>), denoting the number of test cases. Then follow all the test cases.</p><p>For each test case, only one line which contains a single integer n(1 ≤ n ≤ 10<sup>6</sup>), denoting the length of the array little H wants to generate.</p></blockquote><h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><blockquote><p>For each test case, print a integer in one line which denoting the answer.</p></blockquote><h4 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h4><pre class="line-numbers language-none"><code class="language-none">311001000000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h4><pre class="line-numbers language-none"><code class="language-none">1988185646617521033<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><p>理解题意，我们要按照规则生成一个长度为 n 的数列：已生成数列长度为 m，在 [1, n - m] 之间随机取一个数字 x，然后将 x 长度的数列添加到已生成的数列中，问有多少种可能性。</p><p>从长度为 1 开始找规律</p><p>n = 1 时，只有一种可能性</p><p>n = 2 时，第一次生成的 x 可能为 1 or 2</p><p>​    若 x = 1，则剩余长度为 1，只有 1 种可能性</p><p>​    若 x = 2，则剩余长度为 0，此时为 1 种可能性</p><p>​    因此 n = 2 时有两种可能性</p><p>n = 3 时，第一次生成的 x 可能为 1, 2 or 3</p><p>​    若 x = 1，则剩余长度为 2，根据之前推到结果，有 2 种可能性</p><p>​    若 x = 2，则剩余长度为 1，根据之前推到结果，有 1 种可能性</p><p>​    若 x = 3，则剩余长度为 0，此时为 1 种可能性</p><p>​    因此 n = 3 时有 4 种可能性</p><p>……</p><p>易得，答案为 2<sup>n-1</sup>.</p><p>只需按快速幂的方法，求出 2<sup>n-1</sup> % (10<sup>9</sup> + 7) 即可</p><h4 id="Accepted-Code"><a href="#Accepted-Code" class="headerlink" title="Accepted Code"></a>Accepted Code</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define _CRTSECURE_NOWARNINGS#pragma warning(disable:4996)#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;cmath&gt;#include&lt;cctype&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;vector&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;list&gt;using namespace std;const int mod = 1e9 + 7;int t, n;long long qpow(int x){if (!x) return 1;else if (x &amp; 1) return (qpow(x - 1) &lt;&lt; 1) % mod;else{long long temp = (qpow(x &gt;&gt; 1)) % mod;return temp * temp % mod;}}int main(){scanf("%d", &amp;t);while (t--){scanf("%d", &amp;n);printf("%lld\n", qpow(n - 1));}return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="H-•-Hsueh-And-Treasure"><a href="#H-•-Hsueh-And-Treasure" class="headerlink" title="H • Hsueh- And Treasure"></a>H • Hsueh- And Treasure</h3><h4 id="Description-1"><a href="#Description-1" class="headerlink" title="Description"></a>Description</h4><blockquote><p>Hsueh- Dreaming one night, dreaming that he was in a vast ocean.</p><p>In a faraway place, there is an island. It is said that there are some precious treasures on it. There are treasures left by the King of Sailing Kwords to give to the world.</p><p>So Hsueh- wants to find the treasure left by Kwords。</p><p>We assume that the sea is a two-dimensional plane, Hsueh- is currently at (0, 0), and the location of the treasure is at (x, y).</p><p>Next, due to the influence of the cosmic background radiation wave, Hsueh- can only take exactly i steps at the i-th moment, and each step can only walk one square in four directions, up, down, left, and right. The initial moment is 0.</p><p>Hsueh- is too anxious to find the last treasure, so he asks you, can you help him plan the shortest route to the destination (x, y). And please output this route.</p><p>Note that there may be multiple routes, and you can output any route.</p></blockquote><h4 id="Input-1"><a href="#Input-1" class="headerlink" title="Input"></a>Input</h4><blockquote><p>The first line contains a single integer T(1 ≤ T ≤ 10), denoting the number of test cases.</p><p>For next T lines, each line contains two integers x, y(|x|,|y| ≤ 10<sup>9</sup>), representing the location of the treasure.</p></blockquote><h4 id="Output-1"><a href="#Output-1" class="headerlink" title="Output"></a>Output</h4><blockquote><p>For each test case,the output format must meet the following requirements.</p><p>The first line you need to print “Case #i:”(without quotation marks), representing the current number of test cases.</p><p>The second line you need to print a single integer t, which indicates the final moment at which it can reach (xi, yi).</p><p>Next t lines, each line contains two integers separated by a space, denoting the location of the j-th moment.</p></blockquote><h4 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input"></a>Sample Input</h4><pre class="line-numbers language-none"><code class="language-none">21 02 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output"></a>Sample Output</h4><pre class="line-numbers language-none"><code class="language-none">Case #1:11 0Case #2:31 01 22 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h4><p>比赛时审了好几次题，每次审题都有新发现（英语差是原罪</p><p>第一次审题，把题目审难了：没看到 <code>each step can only walk one square in four directions</code>，以为是第 i 次可以走 i 步，但是这 i 步都是要朝同一方向，那就还得考虑越后面能走得越多，会产生朝一个方向的浪费的问题了</p><p>第二次审题，把题目审简单了：没看到 <code>exactly i steps at the i-th moment</code>，以为是第 i 次可以走 i 步，每一步任意方向，只要走到就可以了。那很简单啊，先按左右方向，然后上下方向走完就可以了。甚至还自信地 Submit 了三次，都直接 WA 在了 test1，这才意识到一定是题目读错了，重新审了一次题</p><p>（这里必须 diss 江宇杰，写完代码只测样例就敢 Submit，都不自己造数据测试、、连负数都没考虑到！）</p><p>第三次审题，终于读对题目了，第 i 次一定要走完 i 步。因此，前期还是跟上一次的想法一样，先左右走，走到了以后再向上下走。如果已经到了目的地就左右横跳。如果剩余步数为奇数就走到相邻的一格，如果是偶数就在原地。</p><p>第三次审题，终于读对题目了，第 i 次一定要走完 i 步。因此，前期还是跟上一次的想法一样，先左右走，走到了以后再向上下走</p><h4 id="Accepted-Code-1"><a href="#Accepted-Code-1" class="headerlink" title="Accepted Code"></a>Accepted Code</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define _CRTSECURE_NOWARNINGS#pragma warning(disable:4996)#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;cmath&gt;#include&lt;cctype&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;vector&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;list&gt;using namespace std;int T;long long sx, sy;//当前的坐标long long fx, fy;//目的地坐标int negx = 1, negy = 1;//用于标记目的地的方向是正方向还是负方向bool flag, FLAG;//flag:是否到达过目的地; FLAG:是否恰好到达了目的地int res;//每一次剩余的步数int px[100015], py[100015], cnt;bool arrive(){if (sx == fx &amp;&amp; sy == fy) return 1;return 0;}int LeftRight(int x){if (x &lt; fx - sx){sx += x;x = 0;}else{x -= fx - sx;sx = fx;}return x;}int UpDown(int y){if (y &lt; fy - sy){sy += y;y = 0;}else{y -= fy - sy;sy = fy;}return y;}void init(){negx = fx &gt; 0 ? 1 : -1;negy = fy &gt; 0 ? 1 : -1;fx = abs(fx);fy = abs(fy);sx = 0;sy = 0;flag = 0;FLAG = 0;    memset (px, 0, sizeof (px));    memset (py, 0, sizeof (py));return;}int main(){scanf("%d", &amp;T);for (int t = 1; t &lt;= T; t++){scanf("%lld%lld", &amp;fx, &amp;fy);printf("Case #%d:\n", t);if (!fx &amp;&amp; !fy)//如果目的地为原点，应该输出共 0 步，并且输出 0 行坐标{printf("0\n");continue;}init();for (cnt = 1; !FLAG; cnt++){res = cnt;if (!flag){res = LeftRight(res);res = UpDown(res);if (arrive()) flag = 1;}if (flag){if (res % 2){if (arrive()) sx++;else sx--;}res = 0;if (arrive()) FLAG = 1;}px[cnt] = sx * negx;py[cnt] = sy * negy;}cnt--;printf("%d\n", cnt);for (int i = 1; i &lt;= cnt; i++) printf("%d %d\n", px[i], py[i]);}return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="I-•-Iaom-and-Chicken-feet"><a href="#I-•-Iaom-and-Chicken-feet" class="headerlink" title="I • Iaom and Chicken feet"></a>I • Iaom and Chicken feet</h3><h4 id="Description-2"><a href="#Description-2" class="headerlink" title="Description"></a>Description</h4><blockquote><p>Baom likes chicken very much.</p><p>One day ,while he was thinking a problem on tree he found it looks like chicken’s feet.</p><p><img src="https://cdn.jsdelivr.net/gh/OwlllOvO/Hexo-image/20210402224246.png"></p><p>He fall into thinking,how much chicken feet are there on the tree.</p><p>The “chicken feet” is a subgraph of given tree which shapes like the picture above</p><p>Baom wonder the number of “chicken feet” all over the tree.Two “feet”s are consider the same iff the set of edges of “chicken feet”s are the same.</p></blockquote><h4 id="Input-2"><a href="#Input-2" class="headerlink" title="Input"></a>Input</h4><blockquote><p>The first line contains one integer n(1 ≤ n ≤ 5 ⋅ 10<sup>5</sup>) —The number of nodes each of next n − 1 line contains a description of an edge: two integers u and v(1 ≤ u, v ≤ n, u ≠ v) The given edges form a tree.</p></blockquote><h4 id="Output-2"><a href="#Output-2" class="headerlink" title="Output"></a>Output</h4><blockquote><p>Print a single integer — the number of “chicken feet” modulo 998244353.</p></blockquote><h4 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input"></a>Sample Input</h4><pre class="line-numbers language-none"><code class="language-none">71 22 32 45 46 47 4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output"></a>Sample Output</h4><pre class="line-numbers language-none"><code class="language-none">1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h4><p>将 4 号点提起，枚举 2 号点，令 sz[x] 表示与点 x 相连的点的个数，答案为 C<sup>3</sup><sub>sz[4]−1</sub> · C<sup>2</sup><sub>sz[2]−1</sub> 之和</p><p>（这里再次 diss 江宇杰，莫名其妙喜欢用 cin/cout，导致 TLE… scanf/printf 它不香吗？？？</p><h4 id="Accepted-Code-2"><a href="#Accepted-Code-2" class="headerlink" title="Accepted Code"></a>Accepted Code</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define _CRTSECURE_NOWARNINGS#pragma warning(disable:4996)#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;cmath&gt;#include&lt;cctype&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;vector&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;list&gt;using namespace std;const int maxn = 5e5 + 10;const int mod = 998244353;int t;int u, v;long long sum = 0;long long num[maxn];vector&lt;int&gt; q[maxn];int main(){scanf("%d", &amp;t);for (int i = 1; i &lt;= t - 1; i++)//建立边{scanf("%d%d", &amp;u, &amp;v);q[u].push_back(v);q[v].push_back(u);num[u]++;num[v]++;}for (int i = 1; i &lt;= t; i++){if (num[i] &gt;= 3){for (int j = 0; j &lt; num[i]; j++){if (num[q[i][j]] &gt;= 4){sum += (((num[i] - 1) * (num[i] - 2)) &gt;&gt; 1) * ((num[q[i][j]] - 1) * (num[q[i][j]] - 2) * (num[q[i][j]] - 3) / 6) % mod;sum %= mod;}}}}printf("%lld\n", sum);return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="J-•-Jew-Sorting"><a href="#J-•-Jew-Sorting" class="headerlink" title="J • Jew Sorting"></a>J • Jew Sorting</h3><h4 id="Description-3"><a href="#Description-3" class="headerlink" title="Description"></a>Description</h4><blockquote><p>Hello, guys, I am the King of boredom.</p><p>I have a array of length 2<sup>k</sup>(0 ≤ k ≤ 20). You can delete the first half or the second half of each operation.</p><p>So, you need to tell me the minimum number of operations required can make this sequence non-decreasing.</p></blockquote><h4 id="Input-3"><a href="#Input-3" class="headerlink" title="Input"></a>Input</h4><blockquote><p>The first line contains a single integer k(0 ≤ k ≤ 20), denoting the length of the array is 2<sup>k</sup>.</p><p>The second line contains 2<sup>k</sup> integers, the ii-th integer is ai(1 ≤ ai ≤ 10<sup>9</sup>) representing the array.</p></blockquote><h4 id="Output-3"><a href="#Output-3" class="headerlink" title="Output"></a>Output</h4><blockquote><p>Print a single integer, denoting the answer.</p></blockquote><h4 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input 1"></a>Sample Input 1</h4><pre class="line-numbers language-none"><code class="language-none">21 3 2 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="Sample-Output1"><a href="#Sample-Output1" class="headerlink" title="Sample Output1"></a>Sample Output1</h4><pre class="line-numbers language-none"><code class="language-none">1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input 2"></a>Sample Input 2</h4><pre class="line-numbers language-none"><code class="language-none">21 2 3 4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output 2"></a>Sample Output 2</h4><pre class="line-numbers language-none"><code class="language-none">0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h4><p>按照题目模拟</p><h4 id="Accepted-Code-3"><a href="#Accepted-Code-3" class="headerlink" title="Accepted Code"></a>Accepted Code</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define _CRTSECURE_NOWARNINGS#pragma warning(disable:4996)#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;cmath&gt;#include&lt;cctype&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;vector&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;list&gt;using namespace std;int k, start = 1, num = 1, minans = INT_MAX, times;int a[2000006];int head[2000006];long long maxnum;void init(int x, int n, int halfsize){if (n != k + 1){head[x] = n;init(x + halfsize / 2, n + 1, halfsize / 2);init(x - halfsize / 2, n + 1, halfsize / 2);}}int main(){scanf("%d", &amp;k);maxnum = pow(2, k);init(1 + maxnum / 2, 1, maxnum / 2);scanf("%d", &amp;a[1]);for (int i = 2; i &lt;= maxnum; i++){scanf("%d", &amp;a[i]);if (a[i] &gt;= a[i - 1] &amp;&amp; i != maxnum) num += 1;else{times = 0;int temp = maxnum;if (i == maxnum &amp;&amp; a[i] &gt;= a[i - 1]) num++;while (num &lt; temp){temp /= 2;times++;}times = max(times, head[start]);if (times &lt; minans) minans = times;start = i;num = 1;}}printf("%d\n", minans);return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="After-Trial"><a href="#After-Trial" class="headerlink" title="After Trial"></a>After Trial</h2><p>这段的故事就比较跌宕起伏了……</p><p>首先是在比赛中我们队伍排名第十</p><p>但是有三个队伍是打星队伍，不参加排名，所以我们又排名第 7.</p><p>然而，有两个队伍是不用参加选拔赛的，我们又排名第 9 了 :)</p><p>就在今天，队长又突然通知我，有一个队伍放弃参赛，于是名额就轮到我们了，听到这个消息那是真的激动啊！</p><p>作为唯一一支大一的队伍参赛，既是兴奋，又有忐忑……</p><p>清明节也留校参加实验室的训练了，这几天一定要认真训练，巩固基础知识，多学习算法，再刷点往年的省赛题目，争取在省赛中取得好的名次（虽然只是第一次参赛）</p><h1 id="End"><a href="#End" class="headerlink" title="End"></a>End</h1><p>特别鸣谢：江宇杰、王梓仰</p>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ZJCPC 2021 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ETH</title>
      <link href="2021/03/20/2021-3-20-eth/"/>
      <url>2021/03/20/2021-3-20-eth/</url>
      
        <content type="html"><![CDATA[<h1 id="ETH"><a href="#ETH" class="headerlink" title="ETH"></a>ETH</h1><h2 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h2><h3 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h3><p>很早就看到网络虚拟货币的消息，近两年突然又火了起来，各种虚拟货币币值直线上升。我对此一直抱着怀疑的态度，毕竟它没有任何的实际作用，也就没有尝试自己挖矿，一直都觉得挖矿离自己很遥远，都是矿主们在大规模地挖矿。直到昨天，看到了关注的 UP 主 <a href="https://space.bilibili.com/4401694?spm_id_from=333.788.b_765f7570696e666f.2"><strong>林亦LYi</strong></a> 发布了自己尝试挖矿的视频 <a href="https://www.bilibili.com/video/BV1nN411X7wB">唠唠GPU挖矿的暴富密码：你知道显卡都去哪了吗？</a>，才想起来自己电脑就是 RTX2070，算力也还算挺高，为什么不在闲置的时候也顺便挖一挖矿，还能赚一点钱呢？于是我开始了尝试挖矿。</p><h2 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h2><h3 id="创建钱包"><a href="#创建钱包" class="headerlink" title="创建钱包"></a>创建钱包</h3><p>进入网站 <a href="https://metamask.io/">METAMASK</a>，点击 <code>Download</code>，推荐选择 Chrome 插件，比 iOS / Android 手机端更加方便。浏览器选择 Chrome (需科学上网) 或者 Edge 皆可。插件安装成功后，按照提示注册账号 <strong>！保存好密码、密钥信息！</strong> 然后就可以在插件里获取自己钱包的地址信息。</p><h3 id="挖矿平台"><a href="#挖矿平台" class="headerlink" title="挖矿平台"></a>挖矿平台</h3><p>进入网站 <a href="https://ethermine.org/">ETHERMINE</a>，点击右上角 <code>Start Mining</code>，这里可以看到挖矿相关的数据。然后向下拉选择自己的平台。比如我是 Windows 系统，NVIDIA RTX 2070 的显卡，就选择 Windows - NVIDIA。可以看到第一项是 <code>T-Rex</code>。这时不用在这里打开，转到 <a href="https://github.com/">Github</a>，搜索 <code>T-Rex</code>，点击 <a href="https://github.com/trexminer/T-Rex">trexminer/T-Rex</a> ，右边 <code>Releases</code> 中下载最新版的 zip，解压缩。</p><p>新建文件，重命名为 <code>start.bat</code>，编辑这个文件。可以在 Github 的说明中找到挖矿的命令为</p><pre class="line-numbers language-none"><code class="language-none">t-rex -a ethash -o stratum+tcp://eu1.ethermine.org:4444 -u 0x1f75eccd8fbddf057495b96669ac15f8e296c2cd -p x -w rig0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>。将这一行命令粘贴到文件中，然后根据 <a href="https://ethermine.org/start">Start Mining</a> 的数据进行如下编辑：</p><ul><li>将模式 <code>tcp</code> 修改为 <code>ssl</code></li><li>将地区 <code>eu</code> 欧洲修改为 <code>asia</code> 亚洲</li><li>将 SSL Port <code>4444</code> 修改为 <code>5555</code></li><li><strong>将作者钱包地址 <code>0x1f75eccd8fbddf057495b96669ac15f8e296c2cd</code> 修改为自己的钱包地址（METAMASK 插件中查看）</strong><ul><li>一定要记得改，否则挖矿成果都进了别人的钱包！</li></ul></li><li>将机器名 <code>rig0</code> 修改为自己喜欢的名字</li></ul><p>我的修改结果：</p><pre class="line-numbers language-none"><code class="language-none">t-rex -a ethash -o stratum+ssl://asia1.ethermine.org:5555 -u 0xDD96344e7AaA420Db97c67168E70b841C49a466D -p x -w OwlllOvO1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="开始挖矿"><a href="#开始挖矿" class="headerlink" title="开始挖矿"></a>开始挖矿</h3><p>双击 <code>start.bat</code> 即可开始挖矿。</p><p>此时打开 <a href="https://ethermine.org/">ETHERMINE</a>，中间的输入框中输入自己的钱包地址，即可进入自己的控制面板（Dashboard），查看挖矿的相关信息：已获得的 ETH 数量（金额）、预计 ETH 获得数量（金额）（每 日/周/月）、当前算力 等。</p><p><img src="https://cdn.jsdelivr.net/gh/OwlllOvO/Hexo-image/20210320220855.png" alt="Dashboard"></p><p>然后点击 <code>Settings</code> 填写自己的邮箱地址、最低提现额（建议0.1）、IP地址（可以用 <a href="https://www.whatismyip.org/">What Is My IP</a> 查询），点击 <code>Submit</code> 保存。</p><h3 id="优化效率"><a href="#优化效率" class="headerlink" title="优化效率"></a>优化效率</h3><p>下载软件 <a href="https://cn.msi.com/Landing/afterburner/">msi AfterBurner</a> <strong>此软件用于超频，可能会对显卡造成损害，谨慎使用</strong></p><p>安装打开后点击齿轮图标，勾选 <code>解锁电压调整控制</code> 和 <code>解锁电压监控制</code>，重启软件后， 进行如下调节：</p><ul><li><code>Power Limit</code> 拉到最低</li><li><code>Temp. Limit</code> 拉到最低</li><li><code>Core Clock</code> 拉到最低</li><li><code>Memory Clock</code> 调至 700 ~ 1300<ul><li>调的越高效率越高</li><li>此项操作有风险，害怕显卡烧坏就少调一点或者保持为 0</li></ul></li><li><code>Fan Speed</code> 保持自动或者手动调低以降低噪声<ul><li>尽量不要手动拉低，否则显卡容易过热</li></ul></li></ul><h3 id="停止挖矿"><a href="#停止挖矿" class="headerlink" title="停止挖矿"></a>停止挖矿</h3><p>将 <code>start.bat</code> 关闭即可</p>]]></content>
      
      
      
        <tags>
            
            <tag> ETH </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算几何</title>
      <link href="2021/02/21/2021-2-21-ji-suan-ji-he/"/>
      <url>2021/02/21/2021-2-21-ji-suan-ji-he/</url>
      
        <content type="html"><![CDATA[<h1 id="计算几何"><a href="#计算几何" class="headerlink" title="计算几何"></a>计算几何</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="高精度圆周率"><a href="#高精度圆周率" class="headerlink" title="高精度圆周率"></a>高精度圆周率</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">const double pi = acos(-1.0);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="偏差值"><a href="#偏差值" class="headerlink" title="偏差值"></a>偏差值</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">const double eps = 1e-8;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="sgn"><a href="#sgn" class="headerlink" title="sgn"></a>sgn</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int sgn(double x)// 判断x是否等于0{if (fabs(x) &lt; eps) return 0;else return x &lt; 0 ? -1 : 1;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="dcmp"><a href="#dcmp" class="headerlink" title="dcmp"></a>dcmp</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int dcmp(double x, double y)// 比较两个浮点数，0为相等，-1为小于，1为大于{if (fabs(x - y) &lt; eps) return 0;else return x &lt; y ? -1 : 1;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="点和向量"><a href="#点和向量" class="headerlink" title="点和向量"></a>点和向量</h2><h3 id="点"><a href="#点" class="headerlink" title="点"></a>点</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">struct Point{double x, y;Point() {}Point(double x, double y) : x(x), y(y) {}};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="两点间距离"><a href="#两点间距离" class="headerlink" title="两点间距离"></a>两点间距离</h3><ol><li><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">double Dist(Point A, Point B){return hypot(A.x - B.x, A.y - B.y);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">double Dist(Point A, Point B){return sqrt((A.x - B.x) * (A.x - B.x) + (A.y - B.y) * (A.y - B.y));}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">typedef Point Vector;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="向量的运算"><a href="#向量的运算" class="headerlink" title="向量的运算"></a>向量的运算</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">struct Point{double x, y;Point() {}Point(double x, double y) : x(x), y(y) {}Point operator+(Point B) { return Point(x + B.x, y + B.y); }// 加Point operator-(Point B) { return Point(x - B.x, y - B.y); }// 减Point operator*(double k) { return Point(x * k, y * k); }// 乘Point operator/(double k) { return Point(x / k, y / k); }// 除bool operator==(Point B) { return sgn(x - B.x) == 0 &amp;&amp; sgn(y - B.y) == 0; }// 等于};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="点积"><a href="#点积" class="headerlink" title="点积"></a>点积</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p><code>A • B = |A||B|cosθ</code></p><h3 id="几何定义"><a href="#几何定义" class="headerlink" title="几何定义"></a>几何定义</h3><p>θ: 表示向量 b 与向量 a 的夹角</p><p>向量 b 在向量 a 上的投影长度乘以向量 a 的模长</p><h3 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h3><p><code>A • B = A.x * B.x + A.y * B.y</code></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">double Dot(Vector A, Vector B){return A.x * B.x + A.y * B.y;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><ol><li><p>判断向量 A 与向量 B 的夹角是钝角还是锐角</p><ul><li>若 Dot(A, B) &gt; 0: 向量 A 与向量 B 的夹角为锐角</li><li>若 Dot(A, B) &lt; 0: 向量 A 与向量 B 的夹角为顿角</li><li>若 Dot(A, B) = 0: 向量 A 与向量 B 的夹角为直角</li></ul></li><li><p>求向量 A 的模长</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">double Len(Vector A){return sqrt(Dot(A, A));}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>求向量 A 与向量 B 的夹角大小</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">double Angle(Vector A, Vector B){return acos(Dot(A, B) / Len(A) / Len(B));}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="叉积"><a href="#叉积" class="headerlink" title="叉积"></a>叉积</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p><code>A × B = |A||B|sinθ</code></p><h3 id="几何意义"><a href="#几何意义" class="headerlink" title="几何意义"></a>几何意义</h3><p>θ: 向量 A 旋转到向量 B 所经过的夹角</p><p>|A × B| 在数值上等于由向量和向量构成的平行四边形的面积</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">double Cross(Vector A, Vector B){return A.x * B.y - A.y * B.x;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h3><ol><li><p>判断向量与向量的方向关系</p><ul><li>若 A × B &gt; 0，B 在 A 的逆时针方向</li><li>若 A × B &lt; 0，B 在 A 的顺时针方向</li><li>若 A × B = 0，B 与 A 共线，可能是同方向，也可能是反方向</li></ul></li><li><p>计算两向量构成的平行四边形的有向面积</p><p>3 个点 A, B, C 以 A 为公共点，得到两个向量 B - A, C - A 它们构成的平行四边形的面积如下</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">double Area2(Point A, Point B, Point C){return Cross(B - A, C - A);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>同理 Area2(A, B, C) / 2 就是计算以 A, B, C 三点构成三角形的面积</p></li><li><p>向量旋转</p><p>向量 A 逆时针旋转的角度为 rad</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">Vector Rotate(Vector A, double rad){return Vector(A.x * cos(rad) - A.y * sin(rad), A.x * sin(rad) + A.y * cos(rad));}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>有时需要求单位法向量，即逆时针旋转 90°，然后取单位值</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">Vector Normal(Vector A){return Vector(-A.y / Len(A), A.x / Len(A));}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>用叉积检查两个向量是否平行或重合</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">bool Parallel(Vector A, Vector B){return sgn(Cross(A, B)) == 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="点和线"><a href="#点和线" class="headerlink" title="点和线"></a>点和线</h2><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">struct Line// 直线{Point p1, p2;// 线上的两个点Line() {}// 直接用两个点来构造直线Line(Point p1, Point p2) : p1(p1), p2(p2) {}// 根据一个点和倾斜角angle确定直线，0≤angle≤piLine(Point p, double angle){p1 = p;if (sgn(angle - pi / 2) == 0)p2 = (p1 + Point(0, 1));elsep2 = (p1 + Point(1, tan(angle)));}// ax + by + c = 0Line(double a, double b, double c){if (sgn(a) == 0){p1 = Point(0, -c / b);p2 = Point(1, -c / b);}else if (sgn(b) == 0){p1 = Point(-c / a, 0);p2 = Point(-c / a, 1);}else{p1 = Point(0, -c / b);p2 = Point(1, (-c - a) / b);}}};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="线段的表示"><a href="#线段的表示" class="headerlink" title="线段的表示"></a>线段的表示</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">typedef Line Segment;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="点和直线的位置关系"><a href="#点和直线的位置关系" class="headerlink" title="点和直线的位置关系"></a>点和直线的位置关系</h3><p>用直线 v 上的两点 p1 和 p2 与点 p 构成两个向量，用叉积的正负判断方向，得到相对的位置关系点</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int Point_line_relation(Point p, Line v){int c = sgn(Cross(p - v.p1, v.p2 - v.p1));if (c &lt; 0) // 1：p在v的左边return 1;if (c &gt; 0) // 2：p在v的右边return 2;return 0; // 0：p在v上}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="点和线段的位置关系"><a href="#点和线段的位置关系" class="headerlink" title="点和线段的位置关系"></a>点和线段的位置关系</h3><p>判断点 p 是否在线段 v 上，先用叉积判断是否共线，然后用点积看 p 和 v 的两个端点产生的角是否为钝角</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">bool Point_on_seg(Point p, Line v)// 0为点不在线段v上；1为点在线段v上{return sgn(Cross(p - v.p1, v.p2 - v.p1)) == 0 &amp;&amp; sgn(Dot(p - v.p1, p - v.p2)) &lt;= 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="点到直线的距离"><a href="#点到直线的距离" class="headerlink" title="点到直线的距离"></a>点到直线的距离</h3><p>已知点 p 和直线 v(p1, p2)，求 p 到 v 的距离。首先用叉积求 p, p1, p2 构成的平行四边形的面积，然后用面积除以平行四边形的底边长，也就是线段 (p1, p2) 的长度，就得到了平行四边形的高，即点 p 到直线 v 的距离</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">double Dis_point_line(Point p, Line v){return fabs(Cross(p - v.p1, v.p2 - v.p1)) / Dist(v.p1, v.p2);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="点在直线上的投影"><a href="#点在直线上的投影" class="headerlink" title="点在直线上的投影"></a>点在直线上的投影</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">Point Point_line_proj(Point p, Line v)// 点p在直线v上的投影{double k = Dot(v.p2 - v.p1, p - v.p1) / Len2(v.p2 - v.p1);return v.p1 + (v.p2 - v.p1) * k;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="点关于直线的对称点"><a href="#点关于直线的对称点" class="headerlink" title="点关于直线的对称点"></a>点关于直线的对称点</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">Point Point_line_symmetry(Point p, Line v)// 点p关于直线v的对称点{Point q = Point_line_proj(p, v);return Point(2 * q.x - p.x, 2 * q.y - p.y);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="点到线段的距离"><a href="#点到线段的距离" class="headerlink" title="点到线段的距离"></a>点到线段的距离</h3><p>对于点 p 到线段 v(p1, p2) 的距离，在以下 3 个距离中取最小值：从 p 出发对线段 v 做垂线，如果交点在 v 上，这个距离就是最小值；p 到 p1 的距离，p 到 p2 的距离</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">double Dis_point_seg(Point p, Segment v){if (sgn(Dot(p - v.p1, v.p2 - v.p1)) &lt; 0 || sgn(Dot(p - v.p2, v.p1 - v.p2)) &lt; 0)return min(Dist(p, v.p1), Dist(p, v.p2));return Dis_point_line(p, v);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="两条直线的位置关系"><a href="#两条直线的位置关系" class="headerlink" title="两条直线的位置关系"></a>两条直线的位置关系</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int Line_relation(Line v1, Line v2){if (sgn(Cross(v1.p2 - v1.p1, v2.p2 - v2.p1)) == 0){if (Point_line_relation(v1.p1, v2) == 0)return 1; // 1：重合elsereturn 0; // 0：平行}return 2; // 2：相交}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="求两条直线的交点"><a href="#求两条直线的交点" class="headerlink" title="求两条直线的交点"></a>求两条直线的交点</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">Point Cross_point(Point a, Point b, Point c, Point d)// Line: ab, Line: cd{double s1 = Cross(b - a, c - a);double s2 = Cross(b - a, d - a);return Point(c.x * s2 - d.x * s1, c.y * s2 - d.y * s1) / (s2 - s1);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="判断两个线段是否规范相交"><a href="#判断两个线段是否规范相交" class="headerlink" title="判断两个线段是否规范相交"></a>判断两个线段是否规范相交</h3><p>这里利用叉积有正负的特点。如果一条线段的两端在另一条线段的两侧，那么两个端点与另一线段产生的两个叉积的正负相反，也就是说两个叉积相乘为负。如果两条线段互相满足这一点，那么就是规范相交的。</p><p>规范相交：交点在线段内部</p><p>非规范相交：交点在某条线段的端点</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">bool Cross_segment(Point a, Point b, Point c, Point d){// 规范相交double c1 = Cross(b - a, c - a), c2 = Cross(b - a, d - a);double d1 = Cross(d - c, a - c), d2 = Cross(d - c, b - c);return sgn(c1) * sgn(c2) &lt; 0 &amp;&amp; sgn(d1) * sgn(d2) &lt; 0; // 1: 相交，0: 不相交// 非规范相交return max(a.x, b.x) &gt;= min(c.x, d.x) &amp;&amp; max(c.x, d.x) &gt;= min(a.x, b.x) &amp;&amp; max(a.y, b.y) &gt;= min(c.y, d.y) &amp;&amp; max(c.y, d.y) &gt;= min(a.y, b.y) &amp;&amp; sgn(Cross(b - a, c - a)) * sgn(Cross(b - a, d - a)) &lt;= 0 &amp;&amp; sgn(Cross(d - c, a - c)) * sgn(Cross(d - c, b - c)) &lt;= 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="多边形"><a href="#多边形" class="headerlink" title="多边形"></a>多边形</h2><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">Point p[N];<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="应用-2"><a href="#应用-2" class="headerlink" title="应用"></a>应用</h3><ol><li><p>判断点是否在多边形内部</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int Point_in_polygon(Point pt, Point* p, int n)// 点pt，多边形Point* p{for (int i = 0; i &lt; n; ++i)if (p[i] == pt)return 3;// 3: 点在多边形的顶点上for (int i = 0; i &lt; n; ++i){Line v = Line(p[i], p[(i + 1) % n]);if (Point_on_seg(pt, v))return 2;// 2: 点在多边形的边上}int num = 0;for (int i = 0; i &lt; n; ++i){int j = (i + 1) % n;int c = sgn(Cross(pt - p[j], p[i] - p[j]));int u = sgn(p[i].y - pt.y);int v = sgn(p[j].y - pt.y);if (c &gt; 0 &amp;&amp; u &lt; 0 &amp;&amp; v &gt;= 0)++num;if (c &lt; 0 &amp;&amp; u &gt;= 0 &amp;&amp; v &lt; 0)--num;}return num != 0;// 1: 点在内部；0: 点在外部}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>多边形的面积</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">double Polygon_area(Point* p, int n){double area = 0;for (int i = 0; i &lt; n; ++i)area += Cross(p[i], p[(i + 1) % n]);return area / 2;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>求多边形的重心</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">Point Polygon_center(Point* p, int n){Point ans(0, 0);if (Polygon_area(p, n) == 0)return ans;for (int i = 0; i &lt; n; ++i)ans = ans + (p[i] + p[(i + 1) % n]) * Cross(p[i], p[(i + 1) % n]);return ans / Polygon_area(p, n) / 6;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 计算几何 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博弈论</title>
      <link href="2021/02/20/2021-2-20-bo-yi-lun/"/>
      <url>2021/02/20/2021-2-20-bo-yi-lun/</url>
      
        <content type="html"><![CDATA[<h1 id="博弈论"><a href="#博弈论" class="headerlink" title="博弈论"></a>博弈论</h1><h2 id="巴什博弈"><a href="#巴什博弈" class="headerlink" title="巴什博弈"></a>巴什博弈</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>一堆物品有 n 个，两个人轮流从这堆物品中取物，规定每次可以取走 1 ~ m 个，最后取光者得胜。</p><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>显然，如果 n = m + 1，那么由于一次最多只能取 m 个，所以，无论先取者拿走多少个，后取者都能够一次拿走剩余的物品，后者取胜。因此我们发现了如何取胜的法则：如果 n = (m + 1) r + s，（r 为任意自然数，s ≤ m），那么先取者要拿走 s 个物品，如果后取者拿走 k(≤ m) 个，那么先取者再拿走 m + 1 - k 个，结果剩下 (m + 1)(r - 1) 个，以后保持这样的取法，那么先取者肯定获胜。总之，要保持给对手留下 (m + 1) 的倍数，就能最后获胜。</p><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#define _CRTSECURE_NOWARNINGS#pragma warning(disable:4996)#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;cmath&gt;#include&lt;cctype&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;vector&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;list&gt;using namespace std;int C, n, m;int main(){    scanf("%d%d", &amp;n, &amp;m);    if (n % (m + 1)) printf("first\n");//先手胜    else printf("second\n");//后手胜        return 0;    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Brave-Game"><a href="#Brave-Game" class="headerlink" title="Brave Game"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1846">Brave Game</a></h3><p>巴什博弈模板题</p><h3 id="Good-Luck-in-CET-4-Everybody"><a href="#Good-Luck-in-CET-4-Everybody" class="headerlink" title="Good Luck in CET-4 Everybody!"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1847">Good Luck in CET-4 Everybody!</a></h3><h4 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h4><p>大学英语四级考试就要来临了，你是不是在紧张的复习？也许紧张得连短学期的 ACM 都没工夫练习了，反正我知道的 Kiki 和 Cici 都是如此。当然，作为在考场浸润了十几载的当代大学生，Kiki 和 Cici 更懂得考前的放松，所谓“张弛有道”就是这个意思。这不，Kiki 和 Cici 在每天晚上休息之前都要玩一会儿扑克牌以放松神经。</p><p>“升级”？“双扣”？“红五”？还是“斗地主”？</p><p>当然都不是！那多俗啊~</p><p>作为计算机学院的学生，Kiki 和 Cici 打牌的时候可没忘记专业，她们打牌的规则是这样的：</p><ol><li>总共n张牌;</li><li>双方轮流抓牌；</li><li>每人每次抓牌的个数只能是2的幂次（即：1，2，4，8，16…）</li><li>抓完牌，胜负结果也出来了：最后抓完牌的人为胜者；</li></ol><p>假设 Kiki 和 Cici 都是足够聪明（其实不用假设，哪有不聪明的学生~），并且每次都是 Kiki 先抓牌，请问谁能赢呢？</p><p>当然，打牌无论谁赢都问题不大，重要的是马上到来的 CET-4 能有好的状态。</p><p>Good luck in CET-4 everybody!</p><h4 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h4><p>输入数据包含多个测试用例，每个测试用例占一行，包含一个整数 n（1&lt;=n&lt;=1000）。 </p><h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><p>如果 Kiki 能赢的话，请输出 “Kiki”，否则请输出 “Cici”，每个实例的输出占一行。 </p><h4 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h4><pre class="line-numbers language-none"><code class="language-none">13 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h4><pre class="line-numbers language-none"><code class="language-none">KikiCici<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><p>如果你是先手，那么请考虑你的必胜点。由于规定只能去 2 的幂次，那么只要你留给对手的牌数为 3 的倍数时，那么你就必赢，因为留下 3 的倍数时，对手有两种情况：</p><ol><li>要么取剩下 1，给你胜利</li><li>要么对手取了一点点儿，轮到你时，你就又可以构造一个 3 的倍数了嘛。</li></ol><p>所以无论哪种情况，当你留给对手为 3N 的时候，你是必胜的。好吧，题目说你就是 Kiki，那么当牌数为 3 的倍数时，Kiki 就输了。因为一出来，上帝就留给了 Kiki 一个 3 的倍数。没办法，但是如果一开始上帝留给 Kiki 的不是 3 的倍数，那么 Kiki 肯定能够用先手的优势构造出 3 的倍数，那么 Kiki 就必胜。所以代码是异常的简单啊。</p><h4 id="Accepted-Code"><a href="#Accepted-Code" class="headerlink" title="Accepted Code"></a>Accepted Code</h4><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#define _CRTSECURE_NOWARNINGS#pragma warning(disable:4996)#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;cmath&gt;#include&lt;cctype&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;vector&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;list&gt;using namespace std;int n;int main(){while (scanf("%d", &amp;n) != EOF){if (!(n % 3)) printf("Cici\n");else printf("Kiki\n");}    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 博弈论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021.2.20</title>
      <link href="2021/02/20/2021-2-20/"/>
      <url>2021/02/20/2021-2-20/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 博弈论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LCA</title>
      <link href="2021/02/04/2021-2-4-lca/"/>
      <url>2021/02/04/2021-2-4-lca/</url>
      
        <content type="html"><![CDATA[<h1 id="LCA"><a href="#LCA" class="headerlink" title="LCA"></a>LCA</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote><p>对于有根树 T 的两个结点 u、v，最近公共祖先 LCA(T, u, v) 表示一个结点 x，满足 x 是 u 和 v 的祖先且 x 的深度尽可能大。在这里，一个节点也可以是它自己的祖先。</p><p>——百度百科</p></blockquote><p>记某点集 $S \ = \ v_{1}, \ v_{2}, \ \cdots, \ v_{n}$ 的最近公共祖先为 $LCA(v_{1}, \ v_{2}, \ \cdots, \ v_{n})$ 或 $LCA(S)$</p><h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><ol><li>$LCA (u) \ = \ u$；</li><li>u 是 v 的祖先，当且仅当 $LCA(u, \ v) \ = \ u$；</li><li>如果 u 不为 v 的祖先并且 v 不为 u 的祖先，那么 u, v 分别处于 $LCA(u, \ v)$ 的两棵不同子树中；</li><li>前序遍历中，$LCA(S)$ 出现在所有 S 中元素之前，后序遍历中 LCA(S) 则出现在所有 S 中元素之后；</li><li>两点集并的最近公共祖先为两点集分别的最近公共祖先的最近公共祖先，即 $LCA(A \ \cup \ B) \ = \ LCA(LCA(A), \ LCA(B))$；</li><li>两点的最近公共祖先必定处在树上两点间的最短路上；</li><li>$d(u, \ v) \ = \ h(u) \ + \ h(v) \ - \ 2h(LCA(u, \ v))$，其中 d 是树上两点间的距离，h 代表某点到树根的距离。</li></ol><h2 id="求法"><a href="#求法" class="headerlink" title="求法"></a>求法</h2><h3 id="朴素算法"><a href="#朴素算法" class="headerlink" title="朴素算法"></a>朴素算法</h3><p>可以每次找深度比较大的那个点，让它向上跳。显然在树上，这两个点最后一定会相遇，相遇的位置就是想要求的 LCA。 或者先向上调整深度较大的点，令他们深度相同，然后再共同向上跳转，最后也一定会相遇。</p><p>朴素算法预处理时需要 dfs 整棵树，时间复杂度为 $O(n)$，单次查询时间复杂度为 $O(n)$。但由于随机树高为 $O(\log n)$，所以朴素算法在随机树上的单次查询时间复杂度为 $O(\log n)$。</p><h3 id="倍增算法"><a href="#倍增算法" class="headerlink" title="倍增算法"></a>倍增算法</h3><p>倍增算法是最经典的 LCA 求法，他是朴素算法的改进算法。通过预处理 数组，游标可以快速移动，大幅减少了游标跳转次数。 表示点 的第 个祖先。 数组可以通过 dfs 预处理出来。</p><p>现在我们看看如何优化这些跳转： 在调整游标的第一阶段中，我们要将 两点跳转到同一深度。我们可以计算出 两点的深度之差，设其为 。通过将 进行二进制拆分，我们将 次游标跳转优化为「 的二进制表示所含 <code>1</code> 的个数」次游标跳转。 在第二阶段中，我们从最大的 开始循环尝试，一直尝试到 （包括 ），如果 ，则 ，那么最后的 LCA 为 。</p><p>倍增算法的预处理时间复杂度为 ，单次查询时间复杂度为 。 另外倍增算法可以通过交换 <code>fa</code> 数组的两维使较小维放在前面。这样可以减少 cache miss 次数，提高程序效率。</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#define MXN 50007using namespace std;std::vector&lt;int&gt; v[MXN];std::vector&lt;int&gt; w[MXN];int fa[MXN][31], cost[MXN][31], dep[MXN];int n, m;int a, b, c;void dfs(int root, int fno) {  fa[root][0] = fno;  dep[root] = dep[fa[root][0]] + 1;  for (int i = 1; i &lt; 31; ++i) {    fa[root][i] = fa[fa[root][i - 1]][i - 1];    cost[root][i] = cost[fa[root][i - 1]][i - 1] + cost[root][i - 1];  }  int sz = v[root].size();  for (int i = 0; i &lt; sz; ++i) {    if (v[root][i] == fno) continue;    cost[v[root][i]][0] = w[root][i];    dfs(v[root][i], root);  }}int lca(int x, int y) {  if (dep[x] &gt; dep[y]) swap(x, y);  int tmp = dep[y] - dep[x], ans = 0;  for (int j = 0; tmp; ++j, tmp &gt;&gt;= 1)    if (tmp &amp; 1) ans += cost[y][j], y = fa[y][j];  if (y == x) return ans;  for (int j = 30; j &gt;= 0 &amp;&amp; y != x; --j) {    if (fa[x][j] != fa[y][j]) {      ans += cost[x][j] + cost[y][j];      x = fa[x][j];      y = fa[y][j];    }  }  ans += cost[x][0] + cost[y][0];  return ans;}int main() {  memset(fa, 0, sizeof(fa));  memset(cost, 0, sizeof(cost));  memset(dep, 0, sizeof(dep));  scanf("%d", &amp;n);  for (int i = 1; i &lt; n; ++i) {    scanf("%d %d %d", &amp;a, &amp;b, &amp;c);    ++a, ++b;    v[a].push_back(b);    v[b].push_back(a);    w[a].push_back(c);    w[b].push_back(c);  }  dfs(1, 0);  scanf("%d", &amp;m);  for (int i = 0; i &lt; m; ++i) {    scanf("%d %d", &amp;a, &amp;b);    ++a, ++b;    printf("%d\n", lca(a, b));  }  return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Tarjan-•-离线"><a href="#Tarjan-•-离线" class="headerlink" title="Tarjan • 离线"></a>Tarjan • 离线</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p><code>Tarjan 算法</code> 是一种 <code>离线算法</code>，需要使用 <code>并查集</code> 记录某个结点的祖先结点。做法如下：</p><ol><li>首先接受输入（邻接链表）、查询（存储在另一个邻接链表内）。查询边其实是虚拟加上去的边，为了方便，每次输入查询边的时候，将这个边及其反向边都加入到 <code>queryEdge</code> 数组里。</li><li>然后对其进行一次 DFS 遍历，同时使用 <code>visited</code> 数组进行记录某个结点是否被访问过、<code>parent</code> 记录当前结点的父亲结点。</li><li>其中涉及到了 <code>回溯思想</code>，我们每次遍历到某个结点的时候，认为这个结点的根结点就是它本身。让以这个结点为根节点的 DFS 全部遍历完毕了以后，再将 <code>这个结点的根节点</code> 设置为 <code>这个结点的父一级结点</code>。</li><li>回溯的时候，如果以该节点为起点，<code>queryEdge</code> 查询边的另一个结点也恰好访问过了，则直接更新查询边的 LCA 结果。</li><li>最后输出结果。</li></ol><p>Tarjan 算法需要初始化并查集，所以预处理的时间复杂度为 $O(n)$，Tarjan 算法处理所有 m 次询问的时间复杂度为 $O(m \ + \ n)$。但是 Tarjan 算法的常数比倍增算法大。</p><p>需要注意的是，Tarjan 算法中使用的并查集性质比较特殊，在仅使用路径压缩优化的情况下，单次调用 <code>find()</code> 函数的时间复杂度为均摊 $O(1)$，而不是 $O(\log n)$。</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;algorithm&gt;#include &lt;iostream&gt;using namespace std;class Edge{ public:  int toVertex, fromVertex;  int next;  int LCA;  Edge() : toVertex(-1), fromVertex(-1), next(-1), LCA(-1){};  Edge(int u, int v, int n) : fromVertex(u), toVertex(v), next(n), LCA(-1){};};const int MAX = 100;int head[MAX], queryHead[MAX];Edge edge[MAX], queryEdge[MAX];int parent[MAX], visited[MAX];int vertexCount, edgeCount, queryCount;void init(){  for (int i = 0; i &lt;= vertexCount; i++)  {    parent[i] = i;  }}int find(int x) {  if (parent[x] == x) {    return x;  } else {    return find(parent[x]);  }}void tarjan(int u) {  parent[u] = u;  visited[u] = 1;  for (int i = head[u]; i != -1; i = edge[i].next) {    Edge&amp; e = edge[i];    if (!visited[e.toVertex]) {      tarjan(e.toVertex);      parent[e.toVertex] = u;    }  }  for (int i = queryHead[u]; i != -1; i = queryEdge[i].next) {    Edge&amp; e = queryEdge[i];    if (visited[e.toVertex]) {      queryEdge[i ^ 1].LCA = e.LCA = find(e.toVertex);    }  }}int main() {  memset(head, 0xff, sizeof(head));  memset(queryHead, 0xff, sizeof(queryHead));  cin &gt;&gt; vertexCount &gt;&gt; edgeCount &gt;&gt; queryCount;  int count = 0;  for (int i = 0; i &lt; edgeCount; i++) {    int start = 0, end = 0;    cin &gt;&gt; start &gt;&gt; end;    edge[count] = Edge(start, end, head[start]);    head[start] = count;    count++;    edge[count] = Edge(end, start, head[end]);    head[end] = count;    count++;  }  count = 0;  for (int i = 0; i &lt; queryCount; i++) {    int start = 0, end = 0;    cin &gt;&gt; start &gt;&gt; end;    queryEdge[count] = Edge(start, end, queryHead[start]);    queryHead[start] = count;    count++;    queryEdge[count] = Edge(end, start, queryHead[end]);    queryHead[end] = count;    count++;  }  init();  tarjan(1);  for (int i = 0; i &lt; queryCount; i++) {    Edge&amp; e = queryEdge[i * 2];    cout &lt;&lt; "(" &lt;&lt; e.fromVertex &lt;&lt; "," &lt;&lt; e.toVertex &lt;&lt; ") " &lt;&lt; e.LCA &lt;&lt; endl;  }  return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="在线倍增"><a href="#在线倍增" class="headerlink" title="在线倍增"></a>在线倍增</h3><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 5e5 + 10;int n, m, s;struct lca {int cnt, head[maxn];struct edge { int to, next; } e[maxn &lt;&lt; 1];void add (int u, int v) {e[++cnt] = {v, head[u]}; head[u] = cnt;e[++cnt] = {u, head[v]}; head[v] = cnt;}int dep[maxn];int lg[maxn];int fa[maxn][22];void init () {for (int i = 1; i &lt;= n; ++i){lg[i] = lg[i - 1] + (1 &lt;&lt; lg[i - 1] == i);//cout &lt;&lt; i &lt;&lt; " -&gt; " &lt;&lt; lg[i] &lt;&lt; endl;}}void dfs (int now, int pre) {fa[now][0] = pre; dep[now] = dep[pre] + 1;for (int i = 1; i &lt;= lg[dep[now]]; ++i)fa[now][i] = fa[fa[now][i - 1]][i - 1];for (int i = head[now]; i; i = e[i].next) if (e[i].to != pre) dfs(e[i].to, now);}int LCA (int x, int y) {if (dep[x] &lt; dep[y]) swap(x, y);while (dep[x] &gt; dep[y]) x = fa[x][lg[dep[x] - dep[y]] - 1];if (x == y) return x;for (int k = lg[dep[x]] - 1; k &gt;= 0; --k) if (fa[x][k] != fa[y][k])x = fa[x][k], y = fa[y][k];return fa[x][0];}} Lca;int main () {scanf("%d%d%d", &amp;n, &amp;m, &amp;s);for (int i = 1; i &lt; n; ++i) {int x, y;scanf("%d%d", &amp;x, &amp;y);Lca.add(x, y);}Lca.init();Lca.dfs(s, 0);for (int i = 1; i &lt;= m; ++i) {int x, y;scanf("%d%d", &amp;x, &amp;y);printf("%d\n", Lca.LCA(x, y));}return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Tarjan"><a href="#Tarjan" class="headerlink" title="Tarjan"></a>Tarjan</h3><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 5e5 + 10;int n, m, r;int ans[maxn];struct LCA {int vis[maxn];int s[maxn];void init () { for (int i = 1; i &lt;= n; ++i) s[i] = i;}int find (int x) { return s[x] == x ? x : s[x] = find(s[x]); }int tot, first[maxn];struct query { int to, next; } q[maxn &lt;&lt; 1];void insert (int x, int y) {q[++tot] = {y, first[x]}; first[x] = tot;q[++tot] = {x, first[y]}; first[y] = tot;}int cnt, head[maxn];struct edge { int to, next; } e[maxn &lt;&lt; 1];void add (int u, int v) {e[++cnt] = {v, head[u]}; head[u] = cnt;e[++cnt] = {u, head[v]}; head[v] = cnt;}void Tarjan (int u, int fa) {for (int i = head[u]; i; i = e[i].next) {if (e[i].to == fa) continue;Tarjan(e[i].to, u);s[e[i].to] = u;}for (int i = first[u]; i; i = q[i].next) {if (!vis[q[i].to]) continue;ans[(i + 1) / 2] = find(q[i].to);}vis[u] = 1;}} Lca;int main () {scanf("%d%d%d", &amp;n, &amp;m, &amp;r);Lca.init();for (int i = 1; i &lt; n; ++i) {int x, y;scanf("%d%d", &amp;x, &amp;y);Lca.add(x, y);}for (int i = 1; i &lt;= m; ++i) {int x, y;scanf("%d%d", &amp;x, &amp;y);Lca.insert(x, y);}Lca.Tarjan(r, -1);for (int i = 1; i &lt;= m; ++i) printf("%d\n", ans[i]);return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> LCA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021.2.4</title>
      <link href="2021/02/04/2021-2-4/"/>
      <url>2021/02/04/2021-2-4/</url>
      
        <content type="html"><![CDATA[<h1 id="2021-2-4"><a href="#2021-2-4" class="headerlink" title="2021.2.4"></a>2021.2.4</h1><h2 id="LCA"><a href="#LCA" class="headerlink" title="LCA"></a>LCA</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><blockquote><p>对于有根树 T 的两个结点 u、v，最近公共祖先 LCA(T, u, v) 表示一个结点 x，满足 x 是 u 和 v 的祖先且 x 的深度尽可能大。在这里，一个节点也可以是它自己的祖先。</p><p>——百度百科</p></blockquote><h3 id="Tarjan-•-离线"><a href="#Tarjan-•-离线" class="headerlink" title="Tarjan • 离线"></a>Tarjan • 离线</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><blockquote><p>利用并查集优越的时空复杂度，我们可以实现 LCA 问题的 O(n + Q) 算法，这里 Q 表示询问的次数。</p></blockquote><ul><li>Tarjan 算法基于深度优先搜索的框架，对于新搜索到的一个结点，首先创建由这个结点构成的集合，再对当前结点的每一个子树进行搜索，每搜索完一棵子树，则可确定子树内的 LCA 询问都已解决。其他的 LCA 询问的结果必然在这个子树之外，这时把子树所形成的集合与当前结点的集合合并，并将当前结点设为这个集合的祖先。</li><li>之后继续搜索下一棵子树，直到当前结点的所 有子树搜索完。这时把当前结点也设为已被检查过的，同时可以处理有关当前结点的 LCA 询问，如果有一个从当前结点到结点 v 的询问，且 v 已被检查过，则由于进行的是深度优先搜索，当前结点与 v 的最近公共祖先一定还没有被检查，而这个最近公共祖先的包涵 v 的子树一定已经搜索过了，那么这个最近公共祖先一定是 v 所在集合的祖先。</li></ul>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> LCA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021.2.3</title>
      <link href="2021/02/03/2021-2-3-shu-lun/"/>
      <url>2021/02/03/2021-2-3-shu-lun/</url>
      
        <content type="html"><![CDATA[<h1 id="数论"><a href="#数论" class="headerlink" title="数论"></a>数论</h1><h2 id="素数"><a href="#素数" class="headerlink" title="素数"></a>素数</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>一个大于 1 的自然数，除了 1 和它自身外，不能被其他自然数整除的数叫做素数；否则称为合数</p><ul><li>1既不是质数也不是合数</li></ul><h3 id="判断方法"><a href="#判断方法" class="headerlink" title="判断方法"></a>判断方法</h3><h4 id="暴力-·-O-frac-n-2"><a href="#暴力-·-O-frac-n-2" class="headerlink" title="暴力 · $O(\frac{n}{2})$"></a>暴力 · $O(\frac{n}{2})$</h4><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">bool isPrime(a){  if (a &lt; 2) return 0;  for (int i = 2; i * i &lt; a; ++i)    if (!(a % i)) return 0;  return 1;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Miller-Rabin-素性测试-·-O-k-log-3-n"><a href="#Miller-Rabin-素性测试-·-O-k-log-3-n" class="headerlink" title="Miller-Rabin 素性测试 · $ O(k \ log^{3}n)$"></a>Miller-Rabin 素性测试 · $ O(k \ log^{3}n)$</h4><h5 id="Fermat-素性测试"><a href="#Fermat-素性测试" class="headerlink" title="Fermat 素性测试"></a>Fermat 素性测试</h5><p>我们可以根据费马小定理得出一种检验素数的思路：</p><p>它的基本思想是不断地选取在 [2, n - 1] 中的基 a，并检验是否每次都有 $a^{n - 1} \ \equiv \ 1 \ (mod \ n)$</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">bool millerRabin(int n) {  if (n &lt; 3) return n == 2;  // test_time 为测试次数,建议设为不小于 8  // 的整数以保证正确率,但也不宜过大,否则会影响效率  for (int i = 1; i &lt;= test_time; ++i)   {    int a = rand() % (n - 2) + 2;    if (quickPow(a, n - 1, n) != 1) return 0;  }  return 1;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>很遗憾，费马小定理的逆定理并不成立，换言之，满足了 $a^{n - 1} \ \equiv \ 1 \ (mod \ n)$，a 也不一定是素数。</p><h5 id="卡迈克尔数"><a href="#卡迈克尔数" class="headerlink" title="卡迈克尔数"></a>卡迈克尔数</h5><p>上面的做法中随机地选择 a，很大程度地降低了犯错的概率。但是仍有一类数，上面的做法并不能准确地判断。</p><p>对于合数 n，如果对于所有正整数 a，a 和 n 互素，都有同余式 $a^{n - 1} \ \equiv \ 1 \ (mod \ n)$ 成立，则合数 n 为卡迈克尔数（Carmichael Number），又称为费马伪素数。</p><p>比如，561 = 3 x 11 x 17 就是一个卡迈克尔数。</p><p>而且我们知道，若 n 为卡迈克尔数，则 m = 2<sup>n</sup> - 1 也是一个卡迈克尔数，从而卡迈克尔数的个数是无穷的。</p><h5 id="二次探测定理"><a href="#二次探测定理" class="headerlink" title="二次探测定理"></a>二次探测定理</h5><p>如果 p 是奇素数，则 $x^{2} \ \equiv \ 1 \ (mod \ p)$ 的解为 $x \ \equiv \ 1 \ (mod \ p)$  或者 $x \ \equiv \ p-1 \ (mod \ p)$ 。</p><p>要证明该定理，只需将上面的方程移项，再使用平方差公式，得到 $(x + 1)(x - 1) \ \equiv \ 0 \ (mod \ p)$，即可得出上面的结论。</p><h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><p>根据卡迈克尔数的性质，可知其一定不是 p<sup>e</sup>。</p><p>不妨将费马小定理和二次探测定理结合起来使用：</p><p>将 $a^{n - 1} \ \equiv \ 1 \ (mod \ n)$ 中的指数 n - 1 分解为 $n \ - \ 1 \ = \ u \ \times \ 2^{t}$，在每轮测试中对随机出来的 a 先求出 $a^{u} \ (mod \ n)$，之后对这个值执行最多 t 次平方操作，若发现非平凡平方根时即可判断出其不是素数，否则通过此轮测试。</p><h5 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h5><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">bool millerRabbin(int n){  if (n &lt; 3) return n == 2;  int a = n - 1, b = 0;  while (!(a % 2))  {    a /= 2;    ++b;  }  // test_time 为测试次数,建议设为不小于 8 的整数以保证正确率,但也不宜过大,否则会影响效率  for (int i = 1, j; i &lt;= test_time; ++i)  {    int x = rand() % (n - 2) + 2, v = quickPow(x, a, n);    if (v == 1 || v == n - 1) continue;    for (j = 0; j &lt; b; ++j)    {      v = (long long)v * v % n;      if (v == n - 1) break;    }    if (j &gt;= b) return 0;  }  return 1;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="最大公约数-·-GCD"><a href="#最大公约数-·-GCD" class="headerlink" title="最大公约数 · GCD"></a>最大公约数 · GCD</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>最大公约数即为 Greatest Common Divisor，常缩写为 gcd。</p><p>在素数一节中，我们已经介绍了约数的概念。</p><p>一组数的公约数，是指同时是这组数中每一个数的约数的数。而最大公约数，则是指所有公约数里面最大的一个。</p><h3 id="求法"><a href="#求法" class="headerlink" title="求法"></a>求法</h3><h4 id="欧几里得算法-·-O-log-n"><a href="#欧几里得算法-·-O-log-n" class="headerlink" title="欧几里得算法 · $O(\log n)$"></a>欧几里得算法 · $O(\log n)$</h4><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int gcd(int a, int b){  if (!b) return a;  return gcd(b, a % b);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="多个数的最大公约数"><a href="#多个数的最大公约数" class="headerlink" title="多个数的最大公约数"></a>多个数的最大公约数</h3><p>答案一定是每个数的约数，那么也一定是每相邻两个数的约数。我们采用归纳法，可以证明，每次取出两个数求出答案后再放回去，不会对所需要的答案造成影响。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int a[MAXN];int multi_gcd(int n){  int tmp1, tmp2;  tmp1 = a[1];  for (int i = 2; i &lt;= n; i++)  {    tmp2 = a[i];    a[i] = gcd(tmp1, tmp2);    tmp1 = a[i];  }    return a[n];}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="最小公倍数-·-LCM"><a href="#最小公倍数-·-LCM" class="headerlink" title="最小公倍数 · LCM"></a>最小公倍数 · LCM</h2><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int lcm(int a, int b){return a * b / gcd(a, b);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="多个数的最小公倍数"><a href="#多个数的最小公倍数" class="headerlink" title="多个数的最小公倍数"></a>多个数的最小公倍数</h3><p>可以发现，当我们求出两个数的 gcd 时，求最小公倍数是 $O(1)$ 的复杂度。那么对于多个数，我们其实没有必要求一个共同的最大公约数再去处理，最直接的方法就是，当我们算出两个数的 gcd，或许在求多个数的 gcd 时候，我们将它放入序列对后面的数继续求解，那么，我们转换一下，直接将最小公倍数放入序列即可。</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int a[MAXN];int multi_lcm(int n){  int tmp1, tmp2;  tmp1 = a[1];  for (int i = 2; i &lt;= n; i++)  {    tmp2 = a[i];    a[i] = lcm(tmp1, tmp2);    tmp1 = a[i];  }    return a[n];}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>欧拉函数（Euler’s totient function），即 $\phi(n)$，表示的是小于等于 n 和 n 互质的数的个数。</p><p>比如说 $\phi(1) = 1$。</p><p>当 n 是质数的时候，显然有 $\phi(n) = n - 1$。</p><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><ul><li><p>欧拉函数是积性函数。</p><p>积性是什么意思呢？如果有 $gcd(a, \ b) \ = \ 1$，那么 $\phi(a \times b) = \phi(a) \times \phi(b)$。</p><p>特别地，当 n 是奇数时 $\phi(2n) = \phi(n)$。</p></li><li><p>$n = \sum_{d|n} \phi(d)$</p></li><li><p>若 n = p<sup>k</sup>，其中 p 是质数，那么 $\phi(n) = p^{k} - p^{k-1}$。 </p></li><li><p>由唯一分解定理，设 $n = \Pi_{i=1}^{n}p_{i}^{k_{i}}$，其中 $p_{i}$是质数，有 $\phi(n) = n \times \Pi_{i=1}^{s} \frac{p_{i} - 1}{p_{i}}$。</p></li></ul><h3 id="求欧拉函数值"><a href="#求欧拉函数值" class="headerlink" title="求欧拉函数值"></a>求欧拉函数值</h3><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int euler_phi(int n){  int m = int(sqrt(n + 0.5));  int ans = n;  for (int i = 2; i &lt;= m; i++)    if (n % i == 0)    {      ans = ans / i * (i - 1);      while (n % i == 0) n /= i;    }  if (n &gt; 1) ans = ans / n * (n - 1);  return ans;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果将上面的程序改成如下形式，会提升一点效率：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int euler_phi(int n){  int ans = n;  for (int i = 2; i * i &lt;= n; i++)    if (n % i == 0)    {      ans = ans / i * (i - 1);      while (n % i == 0) n /= i;    }  if (n &gt; 1) ans = ans / n * (n - 1);  return ans;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="欧拉定理"><a href="#欧拉定理" class="headerlink" title="欧拉定理"></a>欧拉定理</h3><p>若 $gcd(a, \ m) \ = \ 1$ 则 $a^{\phi(m)} \equiv 1 (mod m)$</p><h3 id="扩展欧拉定理"><a href="#扩展欧拉定理" class="headerlink" title="扩展欧拉定理"></a>扩展欧拉定理</h3><p>$$<br>a^{b} \equiv \left{<br>\begin{aligned}<br>a^{b \ mod \ \phi(p)} &amp; , &amp; gcd(a, \ p) \ = \ 1 \<br>a^{b} &amp; , &amp; gcd(a, \ p) \ \neq \ 1 &amp; , \ b \ &lt; \ \phi(p) \ (mod \ p)\<br>a^{b \ mod \ \phi(p)+\phi(p)} &amp; , &amp; gcd(a, \ b) \ \neq \ 1 &amp; , \ b \ \geq \ \phi(p)<br>\end{aligned}<br>\right.<br>$$</p><h2 id="筛法"><a href="#筛法" class="headerlink" title="筛法"></a>筛法</h2><h3 id="素数筛法"><a href="#素数筛法" class="headerlink" title="素数筛法"></a>素数筛法</h3><p>如果我们想要知道小于等于 n 有多少个素数呢？</p><p>一个自然的想法是对于小于等于 n 的每个数进行一次质数检验。这种暴力的做法显然不能达到最优复杂度。</p><h4 id="埃拉托斯特尼（Eratosthenes）筛法-·-O-n-log-log-n"><a href="#埃拉托斯特尼（Eratosthenes）筛法-·-O-n-log-log-n" class="headerlink" title="埃拉托斯特尼（Eratosthenes）筛法 · $O(n\log\log n)$"></a>埃拉托斯特尼（Eratosthenes）筛法 · $O(n\log\log n)$</h4><p>如果 x 是合数，那么 x 的倍数也一定是合数。利用这个结论，我们可以避免很多次不必要的检测。</p><p>如果我们从小到大考虑每个数，然后同时把当前这个数的所有（比自己大的）倍数记为合数，那么运行结束的时候没有被标记的数就是素数了。</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int Eratosthenes(int n){  int p = 0;  for (int i = 0; i &lt;= n; ++i) is_prime[i] = 1;  is_prime[0] = is_prime[1] = 0;  for (int i = 2; i &lt;= n; ++i)  {    if (is_prime[i])    {      prime[p++] = i;  // prime[p]是i,后置自增运算代表当前素数数量      if ((long long)i * i &lt;= n)        for (int j = i * i; j &lt;= n; j += i)          // 因为从 2 到 i - 1 的倍数我们之前筛过了，这里直接从 i          // 的倍数开始，提高了运行速度          is_prime[j] = 0;  // 是i的倍数的均不是素数    }  }  return p;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="筛至平方根-amp-amp-只筛奇数"><a href="#筛至平方根-amp-amp-只筛奇数" class="headerlink" title="筛至平方根 &amp;&amp; 只筛奇数"></a>筛至平方根 &amp;&amp; 只筛奇数</h5><p>显然，要找到直到 n 为止的所有素数，仅对不超过 $\sqrt{n}$ 的素数进行筛选就足够了。</p><p>因为除 2 以外的偶数都是合数，所以我们可以直接跳过它们，只用关心奇数就好。</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int n;vector&lt;char&gt; is_prime(n + 1, true);is_prime[0] = is_prime[1] = false;for (int i = 2; i * i &lt;= n; i++){  if (!(i % 2)) continue;  if (is_prime[i])  {    for (int j = i * i; j &lt;= n; j += i) is_prime[j] = false;  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="线性筛法"><a href="#线性筛法" class="headerlink" title="线性筛法"></a>线性筛法</h4><p>埃氏筛法仍有优化空间，它会将一个合数重复多次标记。有没有什么办法省掉无意义的步骤呢？答案是肯定的。</p><p>如果能让每个合数都只被标记一次，那么时间复杂度就可以降到 $O(n)$ 了</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void init(){  phi[1] = 1;  for (int i = 2; i &lt; MAXN; ++i)  {    if (!vis[i])    {      phi[i] = i - 1;      pri[cnt++] = i;    }    for (int j = 0; j &lt; cnt; ++j)    {      if (1ll * i * pri[j] &gt;= MAXN) break;      vis[i * pri[j]] = 1;      if (i % pri[j])      {        phi[i * pri[j]] = phi[i] * (pri[j] - 1);      }      else      {        // i % pri[j] == 0        // 换言之，i 之前被 pri[j] 筛过了        // 由于 pri 里面质数是从小到大的，所以 i 乘上其他的质数的结果一定也是        // pri[j] 的倍数 它们都被筛过了，就不需要再筛了，所以这里直接 break        // 掉就好了        phi[i * pri[j]] = phi[i] * pri[j];        break;      }    }  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>pri[i]: 第 i 个素数</li><li>phi[i]: 1 ~ i 中与 i 互质的数的个数</li></ul><h3 id="筛法求欧拉函数"><a href="#筛法求欧拉函数" class="headerlink" title="筛法求欧拉函数"></a>筛法求欧拉函数</h3><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void phi_table(int n, int* phi){  for (int i = 2; i &lt;= n; i++) phi[i] = 0;  phi[1] = 1;  for (int i = 2; i &lt;= n; i++)    if (!phi[i])      for (int j = i; j &lt;= n; j += i)      {        if (!phi[j]) phi[j] = j;        phi[j] = phi[j] / i * (i - 1);      }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="筛法求约数个数"><a href="#筛法求约数个数" class="headerlink" title="筛法求约数个数"></a>筛法求约数个数</h3><p>d[i]: i 的约数个数</p><p>num[i]: i 的最小质因子出现次数</p><p>定理：若 $n \ = \ \prod_{i=1}^{m} p_{i}^{c_{i}}$ 则 $d_{i} \ = \ \prod_{i=1}^{m}c_{i} \ + \ 1$</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void pre(){  d[1] = 1;  for (int i = 2; i &lt;= n; ++i)  {    if (!v[i]) v[i] = 1, p[++tot] = i, d[i] = 2, num[i] = 1;    for (int j = 1; j &lt;= tot &amp;&amp; i &lt;= n / p[j]; ++j)    {      v[p[j] * i] = 1;      if (i % p[j] == 0)      {        num[i * p[j]] = num[i] + 1;        d[i * p[j]] = d[i] / num[i * p[j]] * (num[i * p[j]] + 1);        break;      }        else      {        num[i * p[j]] = 1;        d[i * p[j]] = d[i] * 2;      }    }  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="筛法求约数和"><a href="#筛法求约数和" class="headerlink" title="筛法求约数和"></a>筛法求约数和</h3><p>f[i]: i 的约数和</p><p>g[i]: i 的最小质因子的 $p \ + \ p^{1} \ + \ p^{2} \ + \ \cdots \ + \ p^{k}$</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void pre(){  g[1] = f[1] = 1;  for (int i = 2; i &lt;= n; ++i)  {    if (!v[i]) v[i] = 1, p[++tot] = i, g[i] = i + 1, f[i] = i + 1;    for (int j = 1; j &lt;= tot &amp;&amp; i &lt;= n / p[j]; ++j)    {      v[p[j] * i] = 1;      if (i % p[j] == 0)      {        g[i * p[j]] = g[i] * p[j] + 1;        f[i * p[j]] = f[i] / g[i] * g[i * p[j]];        break;      }      else      {        f[i * p[j]] = f[i] * f[p[j]];        g[i * p[j]] = 1 + p[j];      }    }  }  for (int i = 1; i &lt;= n; ++i) f[i] = (f[i - 1] + f[i]) % Mod;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="乘法逆元"><a href="#乘法逆元" class="headerlink" title="乘法逆元"></a>乘法逆元</h2><h3 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h3><p>如果一个线性同余方程 $ax \ \equiv \ 1 \ (mod \ b)$ ，则 x 称为 a mod b 的逆元，记作 $a^{-1}$。</p><h3 id="如何求逆元"><a href="#如何求逆元" class="headerlink" title="如何求逆元"></a>如何求逆元</h3><h4 id="扩展欧几里得法"><a href="#扩展欧几里得法" class="headerlink" title="扩展欧几里得法"></a>扩展欧几里得法</h4><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void exgcd(int a, int b, int&amp; x, int&amp; y){  if (!b)  {    x = 1;    y = 0;    return;  }  exgcd(b, a % b, y, x);  y -= a / b * x;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="快速幂法"><a href="#快速幂法" class="headerlink" title="快速幂法"></a>快速幂法</h4><p>因为 $ax \ \equiv \ 1 \ (mod \ b)$；</p><p>所以 $ax \ \equiv \ a^{b-1} \ (mod \ b)$（根据费马小定理）；</p><p>所以 $x \ \equiv \ a^{b-2} \ (mod \ b)$。</p><p>然后我们就可以用快速幂来求了。</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">inline int qpow(long long a, int b){  int ans = 1;  a = (a % p + p) % p;  for (; b; b &gt;&gt;= 1)  {    if (b &amp; 1) ans = (a * ans) % p;    a = (a * a) % p;  }  return ans;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>使用费马小定理需要限制 b 是一个素数，而扩展欧几里得算法只要求 $\gcd(a, \ p) \ = \ 1$。</li></ul><h4 id="线性求逆元"><a href="#线性求逆元" class="headerlink" title="线性求逆元"></a>线性求逆元</h4><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">inv[1] = 1;for (int i = 2; i &lt;= n; ++i){  inv[i] = (long long)(p - p / i) * inv[p % i] % p;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="线性求任意-n-个数的逆元"><a href="#线性求任意-n-个数的逆元" class="headerlink" title="线性求任意 n 个数的逆元"></a>线性求任意 n 个数的逆元</h4><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">s[0] = 1;for (int i = 1; i &lt;= n; ++i) s[i] = s[i - 1] * a[i] % p;sv[n] = qpow(s[n], p - 2);// 当然这里也可以用 exgcd 来求逆元,视个人喜好而定.for (int i = n; i &gt;= 1; --i) sv[i - 1] = sv[i] * a[i] % p;for (int i = 1; i &lt;= n; ++i) inv[i] = sv[i] * s[i - 1] % p;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="中国剩余定理"><a href="#中国剩余定理" class="headerlink" title="中国剩余定理"></a>中国剩余定理</h2><h3 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h3><p>中国剩余定理 (Chinese Remainder Theorem, CRT) 可求解如下形式的一元线性同余方程组（其中 $n_{1}, \ n_{2}, \ \cdots, \ n_{k}$ 两两互质）：<br>$$<br>\left {<br>\begin{array}{c}<br>x \ &amp;\equiv \ &amp;a_{1} \ (mod \ n_{1}) \<br>x \ &amp;\equiv \ &amp;a_{2} \ (mod \ n_{2}) \<br>&amp;\cdots\ \<br>x \ &amp;\equiv \ &amp;a_{k} \ (mod \ n_{k})<br>\end{array}<br>\right .<br>$$</p><h3 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h3><ol><li>计算所有模数的积 n；</li><li>对于第 i 个方程：<ol><li>计算 $m_{i} \ = \ \frac{n}{n_{i}}$；</li><li>计算 $m_{i}$ 在模 $n_{i}$ 意义下的逆元 $m_{i}^{-1}$</li><li>计算 $c_{i} \ = \ m_{i}m_{i}^{-1}$（<strong>不要对 $n_{i}$ 取模</strong>）。</li></ol></li><li>方程组的唯一解为：$a \ = \ \sum_{i=1}^{k}a_{i}c_{i} \ (mod \ n)$。</li></ol>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021.2.2</title>
      <link href="2021/02/02/2021-2-2/"/>
      <url>2021/02/02/2021-2-2/</url>
      
        <content type="html"><![CDATA[<h1 id="2021-2-2"><a href="#2021-2-2" class="headerlink" title="2021.2.2"></a>2021.2.2</h1><h2 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><blockquote><p>背包问题 (Knapsack problem) 是一种组合优化的 NP 完全问题。问题可以描述为：给定一组物品，每种物品都有自己的重量和价格，在限定的总重量内，我们如何选择，才能使得物品的总价格最高。</p><p>——百度百科</p></blockquote><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul><li>01 背包：有 N 件物品和一个容量为 V 的背包。第 i 件物品的重量是 w[i]，价值是 v[i]。求解将哪些物品装入背包可使这些物品的重量总和不超过背包容量，且价值总和最大。<strong>每样物品可取1件</strong></li><li>完全背包：有 N 种物品和一个容量为 V 的背包，每种物品都有 <strong>无限</strong> 件可用。第 i 种物品的体积是 c，价值是 w。将哪些物品装入背包可使这些物品的体积总和不超过背包容量，且价值总和最大。</li><li>多重背包：有 N 种物品和一个容量为 V 的背包。第 i 种物品最多 <strong>有 n 件</strong> 可用，每件体积是 c，价值是 w。求解将哪些物品装入背包可使这些物品的体积总和不超过背包容量，且价值总和最大。</li></ul><h2 id="01-背包"><a href="#01-背包" class="headerlink" title="01 背包"></a>01 背包</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>有 N 件物品和一个容量为 V 的背包。第 i 件物品的重量是 w[i]，价值是 v[i]。求解将哪些物品装入背包可使这些物品的重量总和不超过背包容量，且价值总和最大。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>每样物品最多可以取1次，即对于每样物品只有 <strong>取</strong> 或 <strong>不取</strong> 两种状态。</p>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> DP </tag>
            
            <tag> 01背包 </tag>
            
            <tag> 完全背包 </tag>
            
            <tag> 多重背包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最小生成树</title>
      <link href="2021/01/31/2021-1-31-zui-xiao-sheng-cheng-shu/"/>
      <url>2021/01/31/2021-1-31-zui-xiao-sheng-cheng-shu/</url>
      
        <content type="html"><![CDATA[<h1 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote><p>一个有 n 个结点的连通图的生成树是原图的极小连通子图，且包含原图中的所有 n 个结点，并且有保持图连通的最少的边。</p><p>——百度百科</p></blockquote><h2 id="Kruskal"><a href="#Kruskal" class="headerlink" title="Kruskal"></a>Kruskal</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>用贪心的思想，把所有的边从短到长排序，从最短的边开始判断，如果连接的两个点不是已经联通的，那就把这条边连起来。如果已经联通，则忽略这条边。</p><p>用并查集维护所有的点，联通的点在同一集合，从而判断点是否联通。</p><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define _CRTSECURE_NOWARNINGS#pragma warning(disable:4996)#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;cmath&gt;#include&lt;cctype&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;vector&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;list&gt;using namespace std;#define MAXN 110int n, m, f[MAXN];struct EDGE{int u, v, w;} E[MAXN * MAXN];bool cmp(EDGE x, EDGE y)//边从小到大排序{return x.w &lt; y.w;}void Init(int x)//并查集初始化{for (int i = 1; i &lt;= x; i++) f[i] = i;}int Find(int x){return x == f[x] ? x : f[x] = Find(f[x]);}void Kruskal(int n, int m){int res = 0;// 存放结果int num = 0;// 记录当前选择了多少条边Init(m);sort(E + 1, E + 1 + m, cmp);for (int i = 1; i &lt;= m; i++){int f1 = Find(E[i].u);//  查询u顶点在哪个集合中int f2 = Find(E[i].v);//  查询v顶点在哪个集合中if (f1 != f2)//  如果不在同一个集合中{num++;//  选中的边数 +1res += E[i].w;//  答案加上这条边的权值f[f1] = f2;//  将这两个点合并到一个集合中}if (num == n - 1)// 如果已经找到了 n - 1条边，说明最小生成树已经构建完成了break;}if (num == n - 1) printf("%d\n", res);else  puts("Impossible\n");}int main() {//freopen("in.txt", "r", stdin);while (scanf("%d %d", &amp;n, &amp;m) != EOF)//n 个点，m 条边{if (!m) break;for (int i = 1; i &lt;= m; i++)scanf("%d%d%d", &amp;E[i].u, &amp;E[i].v, &amp;E[i].w);Kruskal(n, m);}    return 0;    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="复杂度-·-O-m-log-m"><a href="#复杂度-·-O-m-log-m" class="headerlink" title="复杂度 · O(m log m)"></a>复杂度 · O(m log m)</h3><h2 id="Prim"><a href="#Prim" class="headerlink" title="Prim"></a>Prim</h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>选用图中的任意一个顶点 v<sub>0</sub>，从 v<sub>0</sub> 开始生成最小生成树</li><li>初始化 d[v<sub>0</sub>] = 0，其他的点的距离值 d[i] = INF，其中 d[i] 表示当前这棵小树到其他点的最小距离值</li><li>经过 N 次如下步骤操作，最后得到一个含 N 各顶点，N - 1 条边的最小生成树<ol><li>选择一个未标记的点 K，并且 d[K] 的值是最小的</li><li>标记点 K 进入这棵小树</li><li>以 K 为中间点，更新这棵小树到未标记点的距离的最小值</li></ol></li><li>得到最小生成树 T</li></ol><h3 id="模板-1"><a href="#模板-1" class="headerlink" title="模板"></a>模板</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define _CRTSECURE_NOWARNINGS#pragma warning(disable:4996)#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;cmath&gt;#include&lt;cctype&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;vector&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;list&gt;using namespace std;#define INF 0x3f3f3f3f#define MAXN 110int n, m, mp[MAXN][MAXN], vis[MAXN], d[MAXN];void Initmap(int x){memset(mp, INF, sizeof(mp));for (int i = 1; i &lt;= x; i++) mp[i][i] = 0;}void Prim(int n, int m){memset(vis, 0, sizeof(vis));int index = 1;//当前加入到小树的顶点int res = 0;//存放结果vis[index] = 1;for (int i = 1; i &lt;= n; i++)//更新这个点到其他点的距离  d[i] = mp[index][i];for (int i = 1; i &lt; n; i++)//执行 n - 1 次，找剩下的n - 1 个点{int minn = INF;for (int j = 1; j &lt;= n; j++)//找出未加入小树且 d 最小的点{if (!vis[j] &amp;&amp; d[j] &lt; minn){minn = d[j];index = j;}}if (minn == INF)//如果没有找到，说明不存在最小生成树{printf("Impossible\n");return;}res += minn;//累加答案vis[index] = 1;//将这个点加入最小生成树中for (int j = 1; j &lt;= n; j++)//更新这个点加入后，当前这棵小树到未加入的点的最近距离{if (!vis[j] &amp;&amp; d[j] &gt; mp[index][j]) d[j] = mp[index][j];}}printf("%d\n", res);}int main(){freopen("in.txt", "r", stdin);while (scanf("%d%d", &amp;n, &amp;m) != EOF){if (!m) break;Initmap(n);for (int i = 1, u, v, w; i &lt;= m; i++){scanf("%d%d%d", &amp;u, &amp;v, &amp;w);mp[v][u] = min(w, mp[u][v]);mp[u][v] = min(w, mp[u][v]);// 消除重边的影响}Prim(n, m);}    return 0;    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="复杂度-·-O-n2"><a href="#复杂度-·-O-n2" class="headerlink" title="复杂度 · O(n2)"></a>复杂度 · O(n<sup>2</sup>)</h3>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 最小生成树 </tag>
            
            <tag> Kruskal </tag>
            
            <tag> Prim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最短路</title>
      <link href="2021/01/30/2021-1-30-zui-duan-lu/"/>
      <url>2021/01/30/2021-1-30-zui-duan-lu/</url>
      
        <content type="html"><![CDATA[<h1 id="最短路"><a href="#最短路" class="headerlink" title="最短路"></a>最短路</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote><p>最短路问题是图论理论的一个经典问题。寻找最短路径就是在指定网络中两结点间找一条距离最小的路。最短路不仅仅指一般地理意义上的距离最短,还可以引申到其它的度量,如时间、费用、线路容量等。</p><p>——百度百科</p></blockquote><h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><ul><li><p>Chain • 链：一个点和边的交错序列 v<sub>0</sub> - e<sub>1</sub> - v<sub>1</sub> - e<sub>2</sub> - v<sub>2</sub> - … - e<sub>k</sub> - v<sub>k</sub></p></li><li><p>Trail • 迹：对于一条路径 w，若e<sub>1</sub>, e<sub>2</sub>, …, e<sub>k</sub> 两两互不相同，则 w 是一条迹</p></li><li><p>Path • 路径：对于一条迹 w，除了 v<sub>0</sub> 和 v<sub>k</sub> 允许相同外，其余点两两互不相同，则称 w 是一条路径</p></li><li><p>Circuit • 回路：对于一个迹 w，若 v<sub>0</sub> = v<sub>k</sub>，则称 w 是一个回路</p></li><li><p>Cycle • 环：对于一条路径 w，若 v<sub>0</sub> = v<sub>k</sub>，则称 w 是一个环</p></li></ul><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ul><li><p>单源最短路</p><p>包括确定起点的最短路径问题，确定终点的最短路径问题（与确定起点的问题相反，该问题是已知终结结点，求最短路径的问题。在无向图中该问题与确定起点的问题完全等同，在有向图中该问题等同于把所有路径方向反转的确定起点的问题。） 。</p></li><li><p>多源最短路</p></li></ul><h2 id="链式前向星"><a href="#链式前向星" class="headerlink" title="链式前向星"></a>链式前向星</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define _CRTSECURE_NOWARNINGS#pragma warning(disable:4996)#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;cmath&gt;#include&lt;cctype&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;vector&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;list&gt;using namespace std;#define INF 0x3f3f3f3fint n, m;//n 个点，m 条单向边int cnt;int front[10001];struct EDGE{int to, next, w;};EDGE edge[10001];void Init(){memset(front, 0, sizeof(front));cnt = 0;}void add_edge(int u, int v, int w){++cnt;edge[cnt].to   = v;edge[cnt].w    = w;edge[cnt].next = front[u];front[u] = cnt;}int main(){freopen("in.txt", "r", stdin);Init();scanf("%d%d", &amp;n, &amp;m);for (int i = 1; i &lt;= m; i++){int u, v, w;scanf("%d%d%d", &amp;u, &amp;v, &amp;w);add_edge(u, v, w);add_edge(v, u, w);//双向边}//遍历与每个点相连的所有边for (int i = 1; i &lt;= n; i++){printf("%d\n", i);for (int j = front[i]; j; j = edge[j].next){printf("%d %d %d\n", i, edge[j].to, edge[j].w);}printf("\n");}return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Dijkstra-•-单源最短路"><a href="#Dijkstra-•-单源最短路" class="headerlink" title="Dijkstra • 单源最短路"></a>Dijkstra • 单源最短路</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>将所有节点分成两个集合，已求出最短路的集合（集合1）和未求出最短路的集合（集合2）。</li><li>更新并记录集合2 中所有节点和源点的距离</li><li>从集合2 中找到距离源点距离最近的点</li><li>将该点移到集合1 中</li><li>重复步骤 2-3，直到集合2 为空</li></ol><p>这个方法用了贪心的思想，每次把距离最小的点视作确定的，因为它已经是未确定的点中距离源点最近的了，不可能存在一条路经过其他未确定的点到这个点，距离还比直接到这个点近的了。</p><ul><li><strong>不能有负权边</strong></li></ul><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><ul><li>dis[]：每个点到源点的距离</li><li>vis[]：每个点属于的集合，0 - 未确定，1 - 已确定</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define _CRTSECURE_NOWARNINGS#pragma warning(disable:4996)#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;cmath&gt;#include&lt;cctype&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;vector&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;list&gt;using namespace std;#define INF 0x3f3f3f3fint n, m;//n 个点，m 条边int mp[10001][10001];int dis[10001], vis[10001];void Init(){memset(mp, INF, sizeof(mp));for (int i = 1; i &lt;= n; i++) mp[i][i] = 0;}void Getmap(){int u, v, w;for (int t = 1; t &lt;= m; t++){scanf("%d%d%d", &amp;u, &amp;v, &amp;w);if (w &lt; mp[u][v]){mp[u][v] = w;mp[v][u] = w;}}}void Dijkstra(int x){memset(vis, 0, sizeof(vis));for (int t = 1; t &lt;= n; t++) dis[t] = mp[x][t];vis[x] = 1;for (int t = 1; t &lt; n; t++){int minn = INF, temp;for (int i = 1; i &lt;= n; i++){if (!vis[i] &amp;&amp; dis[i] &lt; minn){minn = dis[i];temp = i;}}vis[temp] = 1;for (int i = 1; i &lt;= n; i++)if (mp[temp][i] + dis[temp] &lt; dis[i])dis[i] = mp[temp][i] + dis[temp];}}int main(){scanf("%d%d", &amp;n, &amp;m);//n 个点，m 条边Init();//地图初始化Getmap();//读图Dijkstra(x);//以点 x 为出发点的单源最短路for (int i = 1; i &lt;= n; i++) printf("%d\t%d\n", i, dis[i]);//dis[i]：x 点到 n 点的最短距离return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="复杂度-·-O-n2"><a href="#复杂度-·-O-n2" class="headerlink" title="复杂度 · O(n2)"></a>复杂度 · O(n<sup>2</sup>)</h3><h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><ul><li><p>从一个点出发到所有点的距离：正 Dijkstra</p></li><li><p>从所有点出发到一个点的距离（<a href="http://poj.org/problem?id=3268">POJ 3268 • Silver Cow Party</a>）</p><ul><li><p>把图反向</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int tmp = map[i][j];map[i][j] = map[j][i];map[j][i] = tmp;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>Dijkstra</p></li></ul></li></ul><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><h2 id="Floyd-•-多源最短路"><a href="#Floyd-•-多源最短路" class="headerlink" title="Floyd • 多源最短路"></a>Floyd • 多源最短路</h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>我们定义一个数组 <code>dis[k][x][y]</code> ，表示只允许经过结点 V<sub>1</sub> 到 V<sub>k</sub>，结点 x 到结点 y 的最短路长度。很显然， <code>dis[n][x][y]</code> 就是最终结点 x 到结点 y 的最短路长度。</p><p><code>dis[0][x][y]</code> 是 x 与 y 的边权，或者 0 ，或者 INF（当 x 与 y 间有直接相连的边的时候，为它们的边权；当 x = y 的时候为零，因为到本身的距离为零；当 x 与 y 没有直接相连的边的时候，为 INF）</p><p><code>dis[k][x][y] = min(dis[k-1][x][y], dis[k-1][x][k]+dis[k-1][k][y])</code> （ <code>dis[k-1][x][y]</code> 为不经过 k 点的最短路径，而 <code>dis[k-1][x][k]+dis[k-1][k][y]</code> 为经过了 k 点的最短路）。</p><ul><li><p><strong>能有负权边</strong></p></li><li><p><strong>不能有负环</strong></p></li></ul><h3 id="模板-1"><a href="#模板-1" class="headerlink" title="模板"></a>模板</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void Floyd(){    for (int k = 1; k &lt;= n; k++)    {        for (int i = 1; i &lt;= n; i++)        {        for(int j = 1; j &lt;= n; j++)            {                dis[k][i][j] = min(dis[k - 1][i][j], dis[k - 1][i][k] + dis[k - 1][k][j]);            }        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>不难看出，k 每次循环后只是调用了 k - 1 的数据，而 k 之前的数据对结果没有作用，因此第一维是可以省略的（数据可以不保存，直接在下一次循环被覆盖，但是还是需要有这 k 次循环）</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#define _CRTSECURE_NOWARNINGS#pragma warning(disable:4996)#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;cmath&gt;#include&lt;cctype&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;vector&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;list&gt;using namespace std;#define INF 0x3f3f3f3fint n, m;//n 个点，m 条边int dis[10001][10001];void Init(){    memset(dis, INF, sizeof(dis));    for (int i = 1; i &lt;= n; i++) dis[i][i] = 0;}void Getmap(){    for (int i = 1; i &lt;= m; i++)    {        int u, v, w;        scanf("%d%d%d", &amp;u, &amp;v, &amp;w);        if (w &lt; dis[u][v])        {            dis[u][v] = w;            dis[v][u] = w;        }    }}void Floyd(){    for (int k = 1; k &lt;= n; k++)    {        for (int i = 1; i &lt;= n; i++)        {            for (int j = 1; j &lt;= n; j++)            {                dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]);            }        }    }}int main(){    scanf("%d%d", &amp;n, &amp;m);    Init();    Getmap();    Floyd();    for (int i = 1; i &lt;= n; i++)    {        for (int j = i; j &lt;= n; j++)        {            printf("%d %d %d\n", i, j, dis[i][j]);  //dis[i][j] = i 到 j 的最短距离        }    }return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><ul><li>时间复杂度：O(n<sup>3</sup>)</li><li>空间复杂度：O(n<sup>2</sup>)</li></ul><h2 id="Bellman-Ford-•-单源最短路"><a href="#Bellman-Ford-•-单源最短路" class="headerlink" title="Bellman-Ford • 单源最短路"></a>Bellman-Ford • 单源最短路</h2><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ul><li><p>松弛</p><p>每次松弛操作实际上是对相邻节点的访问，第 n 次松弛操作保证了所有深度为 n 的路径最短。由于图的最短路径最长不会经过超过 |V| - 1 条边，所以可知贝尔曼-福特算法所得为最短路径。</p></li><li><p>负边权操作</p><p>与 Dijkstra 算法不同的是，迪科斯彻算法的基本操作“拓展”是在深度上寻路，而“松弛”操作则是在广度上寻路，这就确定了贝尔曼-福特算法可以对负边进行操作而不会影响结果。</p></li><li><p>负权环判定</p><p>因为负权环可以无限制的降低总花费，所以如果发现第 n 次操作仍可降低花销，就一定存在负权环。</p></li></ul><ul><li><p><strong>能有负权边</strong></p></li><li><p><strong>能有负环</strong></p></li></ul><h3 id="优化-1"><a href="#优化-1" class="headerlink" title="优化"></a>优化</h3><ul><li><p>循环的提前跳出</p><p>在实际操作中，贝尔曼-福特算法经常会在未达到 |V| - 1 次前就出解，|V| - 1 其实是最大值。于是可以在循环中设置判定，在某次循环不再进行松弛时，直接退出循环，进行负权环判定。</p></li><li><p>最短路径快速算法</p><p>松弛操作必定只会发生在最短路径前导节点松弛成功过的节点上，用一个队列记录松弛过的节点，可以避免了冗余计算。该算法的复杂度为 O(k|E|)，k 是个比较小的系数，但该结论未得到广泛认可。</p></li></ul><h3 id="模板-2"><a href="#模板-2" class="headerlink" title="模板"></a>模板</h3><ul><li><del>SPFA已死</del></li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define _CRTSECURE_NOWARNINGS#pragma warning(disable:4996)#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;cmath&gt;#include&lt;cctype&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;vector&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;list&gt;using namespace std;#define INF 0x3f3f3f3fint n, m;//n 个点，m 条单向边int cnt;int dis[10001];int front[10001];struct EDGE{int to, next, w;};EDGE edge[10001];void Init(){memset(front, 0, sizeof(front));cnt = 0;}void add_edge(int u, int v, int w){++cnt;edge[cnt].to = v;edge[cnt].w = w;edge[cnt].next = front[u];front[u] = cnt;}bool SPFA(int s){queue&lt;int&gt; q;bool vis[10001];int  cnt[10001];memset(dis, INF, sizeof(dis));memset(vis, 0, sizeof(vis));memset(cnt, 0, sizeof(cnt));while (!q.empty()) q.pop();dis[s] = 0;cnt[s] = 1;q.push(s);vis[s] = 1;while (!q.empty()){int x = q.front();q.pop();vis[x] = 0;for (int i = front[x]; i; i = edge[i].next){int k = edge[i].to;if (dis[k] &gt; dis[x] + edge[i].w){dis[k] = dis[x] + edge[i].w;cnt[k] = cnt[x] + 1;if (cnt[k] &gt; n) return 0;if (!vis[k]){vis[k] = 1;q.push(k);}}}}return 1;}int main(){freopen("in.txt", "r", stdin);Init();scanf("%d%d", &amp;n, &amp;m);for (int i = 1; i &lt;= m; i++){int u, v, w;scanf("%d%d%d", &amp;u, &amp;v, &amp;w);add_edge(u, v, w);add_edge(v, u, w);//双向边}//SPFA(x)：以 x 点为源点的单源最短路//dis[y]：x 到 y 的最短距离//SPFA 返回值：是否存在负环for (int i = 1; i &lt;= n; i++){if (!SPFA(i)) printf("%d Yes\n", i);else printf("%d No\n", i);for (int j = 1; j &lt;= n; j++){printf("%d %d %d\n", i, j, dis[j]);}printf("\n");}return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="复杂度-·-O-V-·-E"><a href="#复杂度-·-O-V-·-E" class="headerlink" title="复杂度 · O(|V| · |E|)"></a>复杂度 · O(|V| · |E|)</h3><h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><h3 id="A-最短路-•-HDU-2544"><a href="#A-最短路-•-HDU-2544" class="headerlink" title="A  最短路 • HDU 2544"></a>A <a href="https://vjudge.net/contest/420578#problem/A"> 最短路</a> • <a href="http://acm.hdu.edu.cn/showproblem.php?pid=2544">HDU 2544</a></h3><h3 id="B-Til-the-Cows-Come-Home-•-POJ-2387"><a href="#B-Til-the-Cows-Come-Home-•-POJ-2387" class="headerlink" title="B  Til the Cows Come Home • POJ 2387"></a>B <a href="https://vjudge.net/contest/420578#problem/B"> Til the Cows Come Home</a> • <a href="http://poj.org/problem?id=2387">POJ 2387</a></h3><h3 id="C-Silver-Cow-Party-•-POJ-3268"><a href="#C-Silver-Cow-Party-•-POJ-3268" class="headerlink" title="C  Silver Cow Party • POJ 3268"></a>C <a href="https://vjudge.net/contest/420578#problem/C"> Silver Cow Party</a> • <a href="http://poj.org/problem?id=3268">POJ 3268</a></h3><h3 id="D-Heavy-Transportation-•-POJ-1797"><a href="#D-Heavy-Transportation-•-POJ-1797" class="headerlink" title="D  Heavy Transportation •  POJ 1797"></a>D <a href="https://vjudge.net/contest/420578#problem/D"> Heavy Transportation</a> • <a href="http://poj.org/problem?id=1797"> POJ 1797</a></h3><h3 id="E-Cow-Contest-•-POJ-3660"><a href="#E-Cow-Contest-•-POJ-3660" class="headerlink" title="E  Cow Contest • POJ 3660"></a>E <a href="https://vjudge.net/contest/420578#problem/E"> Cow Contest</a> • <a href="http://poj.org/problem?id=3660">POJ 3660</a></h3><h3 id="F-Edge-Deletion-•-CodeForces-1076D"><a href="#F-Edge-Deletion-•-CodeForces-1076D" class="headerlink" title="F Edge Deletion • CodeForces 1076D"></a>F <a href="https://vjudge.net/contest/420578#problem/F">Edge Deletion</a> • <a href="https://codeforces.com/problemset/problem/1076/D">CodeForces 1076D</a></h3>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> Floyd </tag>
            
            <tag> Dijkstra </tag>
            
            <tag> SPFA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021.1.29</title>
      <link href="2021/01/29/2021-1-29/"/>
      <url>2021/01/29/2021-1-29/</url>
      
        <content type="html"><![CDATA[<h1 id="2021-1-29"><a href="#2021-1-29" class="headerlink" title="2021.1.29"></a>2021.1.29</h1><h2 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h2><blockquote><p>Hash，一般翻译做散列、杂凑，或音译为哈希，是把任意长度的输入（又叫做预映射pre-image）通过散列算法变换成固定长度的输出，该输出就是散列值。这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，所以不可能从散列值来确定唯一的输入值。简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> Hash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021.1.27</title>
      <link href="2021/01/27/2021-1-27/"/>
      <url>2021/01/27/2021-1-27/</url>
      
        <content type="html"><![CDATA[<h1 id="Dynamic-Programming"><a href="#Dynamic-Programming" class="headerlink" title="Dynamic Programming"></a>Dynamic Programming</h1><h2 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h2><p>斐波那契数列：1, 1, 2, 3, 5, 8, 13, 21, 34, 55, …</p><p>即：</p><ul><li>a<sub>n</sub> = 1    (n = 1 or n = 2)</li><li>a<sub>n</sub> = a<sub>n-1</sub> + a<sub>n-2</sub>    (n &gt;= 3)</li></ul><p>求斐波那契的第 n 项</p><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>找到了其中的 <strong>最优子结构</strong>（递归公式）：f(n) = f(n - 1) + f(n - 2)</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">long long func(int n){    if (n == 1 || n == 2) return 1;    return func(n - 1) + func(n - 2);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="复杂度-•-O-2n"><a href="#复杂度-•-O-2n" class="headerlink" title="复杂度 • O(2n)"></a>复杂度 • O(2<sup>n</sup>)</h3><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>计算 f(n) 时要计算 f(n - 1) 和 f(n - 2)，而计算 f(n - 1) 要计算 f(n - 2) 和 f(n - 3)…因此有很多是重复计算，因此考虑到用空间换时间，记录下这些值，以后需要计算这些值的时候直接返回已经计算得到的值即可</p><h2 id="空间换时间-•-记忆化"><a href="#空间换时间-•-记忆化" class="headerlink" title="空间换时间 • 记忆化"></a>空间换时间 • 记忆化</h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>发现有很多值重复计算，用空间换时间</p><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">long long f[1001] = {0, 1, 1};long long func(int n){    if (!f[n]) f[n] = func(n - 1) + func(n - 2);    return f[n];}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="复杂度-•-O-n"><a href="#复杂度-•-O-n" class="headerlink" title="复杂度 • O(n)"></a>复杂度 • O(n)</h3><h3 id="优化-1"><a href="#优化-1" class="headerlink" title="优化"></a>优化</h3><p>不难发现，结果是从前往后一位一位计算得到的，第 3 位，第 4 位…第 n 位。而每次计算的时候只与这一位的前两位有关系，因此可以使用循环的方法完成。</p><h2 id="递归变循环"><a href="#递归变循环" class="headerlink" title="递归变循环"></a>递归变循环</h2><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>打印空间，发现是按顺序从前往后运行的</p><h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">long long f[10001] = {0, 1, 1};long long func(int n){    for (int i = 3; i &lt;= n; i++) f[i] = f[i - 1] + f[i - 2];    return f[n];}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><ul><li><p>时间复杂度 • O(n)</p></li><li><p>空间复杂度 • O(n)</p></li></ul><h3 id="优化-2"><a href="#优化-2" class="headerlink" title="优化"></a>优化</h3><p>不难发现，当前值至于前两个值有关，因此不需要保留前两个之前的值</p><h2 id="空间压缩-•-即用即抛"><a href="#空间压缩-•-即用即抛" class="headerlink" title="空间压缩 • 即用即抛"></a>空间压缩 • 即用即抛</h2><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>发现很多空间被重复利用，每次计算只与前两项有关</p><h3 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">long long a = 1, b = 1, c;long long func(int n){    for (int i = 3; i &lt;= n; i++)    {        c = b;        b = a + b;        a = c;    }    return b ;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>时间复杂度 • O(n)</p></li><li><p>空间复杂度 • O(1)</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线段树</title>
      <link href="2021/01/25/2021-1-25-xian-duan-shu/"/>
      <url>2021/01/25/2021-1-25-xian-duan-shu/</url>
      
        <content type="html"><![CDATA[<h1 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h1><h2 id="问题引入"><a href="#问题引入" class="headerlink" title="问题引入"></a>问题引入</h2><p>假设需要反复对一个数组 a[] 进行以下两个操作：</p><ul><li><p>Query • 求和</p><p>对 a[l] ~ a[r] 求和</p></li><li><p>Update • 修改</p><p>将 a[idx] 的值修改为 val</p></li></ul><p>则有如下解决办法：</p><h3 id="朴素做法"><a href="#朴素做法" class="headerlink" title="朴素做法"></a>朴素做法</h3><ul><li><p>Build</p><p><code>for (int i = 1; i &lt;= n; i++) scanf ("%d", &amp;a[i]);</code></p></li><li><p>Query</p><p><code>for (int i = l; i &lt;= r; i++) sum += a[i];</code> <code>O(n)</code></p></li><li><p>Update</p><p><code>a[idx] = val;</code> <code>O(1)</code></p></li></ul><h3 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h3><ul><li><p>Build</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">for (int i = 1; i &lt;= l; i++){scanf ("%d", &amp;a[i]);sum_a[i] = sum_a[i-1] + a[i];}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>Query</p><p><code>sum = sum_a[r] - sum_a[l - 1];</code> <code>O(1)</code></p></li><li><p>Update</p><p><code>for (int i = idx; i &lt;= n; i++) sum_a[i] += val; </code> <code>O(n)</code></p></li></ul><p>可见，两种方法的时间复杂度都较高，于是引入线段树的数据结构</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote><p>线段树是一种二叉搜索树，与区间树相似，它将一个区间划分成一些单元区间，每个单元区间对应线段树中的一个叶结点。</p><p>——百度百科</p></blockquote><ul><li><p>Build</p><p>如图，区间依次对半分，每个节点存储一部分区间的和，节点按序标记为 1 ~ n（图中为 0 ~ n - 1）</p><img src="https://cdn.jsdelivr.net/gh/OwlllOvO/Hexo-image/20210125202804.png" style="zoom: 50%;"></li><li><p>Query <code>O(logn)</code></p><ul><li>从根结点开始划分求和区间</li><li>如果节点区间为求和区间的子集：返回节点值</li><li>如果节点区间与求和区间无交集：返回 0</li></ul></li><li><p>Update <code>O(logn)</code></p><ul><li>找到修改的节点，修改值</li><li>向上更新节点值</li></ul></li></ul><h2 id="模板-•-单点修改-•-数组"><a href="#模板-•-单点修改-•-数组" class="headerlink" title="模板 • 单点修改 • 数组"></a>模板 • 单点修改 • 数组</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define _CRTSECURE_NOWARNINGS#pragma warning(disable:4996)#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;cmath&gt;#include&lt;cctype&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;vector&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;list&gt;using namespace std;const int MAX_LEN = 1000016;int n, m, q;int arr[MAX_LEN], tree[MAX_LEN &lt;&lt; 2];void build_tree(int node, int start, int end){if (start == end){tree[node] = arr[start];return;}int mid = (start + end) &gt;&gt; 1;int left_node  = node &lt;&lt; 1;int right_node = node &lt;&lt; 1 | 1;build_tree(left_node,  start,   mid);build_tree(right_node, mid + 1, end);tree[node] = tree[left_node] + tree[right_node];}void update_tree(int node, int start, int end, int idx, int val){if (start == end){arr[idx] = val;tree[node] = arr[idx];return;}int mid = (start + end) &gt;&gt; 1;int left_node  = node &lt;&lt; 1;int right_node = node &lt;&lt; 1 | 1;if (idx &lt;= mid)        update_tree(left_node,  start,   mid, idx, val);else        update_tree(right_node, mid + 1, end, idx, val);tree[node] = tree[left_node] + tree[right_node];}int query_tree(int node, int start, int end, int l, int r){if (r &lt; start || l &gt; end) return 0;if (l &lt;= start &amp;&amp; r &gt;= end) return tree[node];if (start == end) return tree[node];int mid = (start + end) &gt;&gt; 1;int left_node  = node &lt;&lt; 1;int right_node = node &lt;&lt; 1 | 1;int sum_left  = query_tree(left_node,  start,   mid, l, r);int sum_right = query_tree(right_node, mid + 1, end, l, r);return sum_left + sum_right;}int main(){while (scanf("%d", &amp;n) != EOF){for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;arr[i]);build_tree(1, 1, n);scanf("%d", &amp;m);while (m--){int idx, val;scanf("%d%d", &amp;idx, &amp;val);update_tree(1, 1, n, idx, val);}scanf("%d", &amp;q);while (q--){int l, r;scanf("%d%d", &amp;l, &amp;r);printf("%d\n", query_tree(1, 1, n, l, r));}}return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="模板-•-区间修改"><a href="#模板-•-区间修改" class="headerlink" title="模板 • 区间修改"></a>模板 • 区间修改</h2><h2 id="模板-•-权值线段树"><a href="#模板-•-权值线段树" class="headerlink" title="模板 • 权值线段树"></a>模板 • 权值线段树</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define _CRTSECURE_NOWARNINGS#pragma warning(disable:4996)#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;cmath&gt;#include&lt;cctype&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;vector&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;list&gt;using namespace std;int n, m, p;int a[10001];int arr[10001];//arr[x]表示数 x 有多少个int tree[10001];void build_tree(int node, int l, int r){int mid = (l + r) / 2;if (l == r){tree[node] = arr[l];return;}int left_node = node * 2;int right_node = node * 2 + 1;build_tree(left_node, l, mid);build_tree(right_node, mid + 1, r);tree[node] = tree[left_node] + tree[right_node];}void update_tree(int node, int l, int r, int k, int cnt)//表示数k的个数多cnt个{int mid = (l + r) / 2;if (l == r){tree[node] += cnt;return;}int left_node = node * 2;int right_node = node * 2 + 1;if (k &lt;= mid)update_tree(left_node, l, mid, k, cnt);elseupdate_tree(right_node, mid + 1, r, k, cnt);tree[node] = tree[left_node] + tree[right_node];}int query_tree(int node, int l, int r, int k)//查询数k有多少个{int mid = (l + r) / 2;if (l == r)return tree[node];int left_node = node * 2;int right_node = node * 2 + 1;if (k &lt;= mid)return query_tree(left_node, l, mid, k);elsereturn query_tree(right_node, mid + 1, r, k);}int kth_tree(int node, int l, int r, int k)//查询第k大值是多少{int mid = (l + r) / 2;if (l == r)return l;int left_node = node * 2;int right_node = node * 2 + 1;int s1 = tree[left_node];int s2 = tree[right_node];if (k &lt;= s2)return kth_tree(right_node, mid + 1, r, k);elsereturn kth_tree(left_node, l, mid, k - s2);}int main(){freopen("in.txt", "r", stdin);scanf("%d", &amp;n);for (int i = 1; i &lt;= n; i++){scanf("%d", &amp;a[i]);arr[a[i]]++;}scanf("%d%d", &amp;m, &amp;p);build_tree(1, 1, m);printf("%d", kth_tree(1, 1, m, p));return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><h3 id="A-例题1-•-SPOJ-GSS1"><a href="#A-例题1-•-SPOJ-GSS1" class="headerlink" title="A 例题1 • SPOJ GSS1"></a>A <a href="https://vjudge.net/contest/419506#problem/A">例题1</a> • <a href="https://vjudge.net/problem/SPOJ-GSS1/origin">SPOJ GSS1</a></h3><h3 id="B-例题2-•-Gym-102770B"><a href="#B-例题2-•-Gym-102770B" class="headerlink" title="B 例题2 • Gym 102770B"></a>B <a href="https://vjudge.net/contest/419506#problem/B">例题2</a> • <a href="https://vjudge.net/problem/Gym-102770B/origin">Gym 102770B</a></h3><h3 id="C-例题3-•-POJ-2182"><a href="#C-例题3-•-POJ-2182" class="headerlink" title="C 例题3 • POJ 2182"></a>C <a href="https://vjudge.net/contest/419506#problem/C">例题3</a> • <a href="https://vjudge.net/problem/POJ-2182/origin">POJ 2182</a></h3><h3 id="D-【模板】单点修改-•-HDU-1166"><a href="#D-【模板】单点修改-•-HDU-1166" class="headerlink" title="D 【模板】单点修改 • HDU 1166"></a>D <a href="https://vjudge.net/contest/419506#problem/D">【模板】单点修改</a> • <a href="https://vjudge.net/problem/HDU-1166/origin">HDU 1166</a></h3><h3 id="E-【模板】区间修改-•-POJ-3468"><a href="#E-【模板】区间修改-•-POJ-3468" class="headerlink" title="E 【模板】区间修改 • POJ 3468"></a>E <a href="https://vjudge.net/contest/419506#problem/E">【模板】区间修改</a> • <a href="https://vjudge.net/problem/POJ-3468/origin">POJ 3468</a></h3><h3 id="F-练习题1-•-CodeForces-339D"><a href="#F-练习题1-•-CodeForces-339D" class="headerlink" title="F 练习题1 • CodeForces 339D"></a>F <a href="https://vjudge.net/contest/419506#problem/F">练习题1</a> • <a href="https://vjudge.net/problem/CodeForces-339D/origin">CodeForces 339D</a></h3><h3 id="G-练习题2-•-HDU-2795"><a href="#G-练习题2-•-HDU-2795" class="headerlink" title="G 练习题2 • HDU 2795"></a>G <a href="https://vjudge.net/contest/419506#problem/G">练习题2</a> • <a href="https://vjudge.net/problem/HDU-2795/origin">HDU 2795</a></h3><h3 id="H-练习题3-•-HDU-2852"><a href="#H-练习题3-•-HDU-2852" class="headerlink" title="H 练习题3 • HDU 2852"></a>H <a href="https://vjudge.net/contest/419506#problem/H">练习题3</a> • <a href="https://vjudge.net/problem/HDU-2852/origin">HDU 2852</a></h3>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>拓扑排序</title>
      <link href="2021/01/23/2021-1-23-tuo-bu-pai-xu/"/>
      <url>2021/01/23/2021-1-23-tuo-bu-pai-xu/</url>
      
        <content type="html"><![CDATA[<h1 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote><p>对一个有向无环图 (Directed Acyclic Graph 简称 DAG) G 进行拓扑排序，是将 G 中所有顶点排成一个线性序列，使得图中任意一对顶点 u 和 v，若边 &lt;u,v&gt; ∈ E(G)，则 u 在线性序列中出现在 v 之前。通常，这样的线性序列称为满足拓扑次序 (Topological Order) 的序列，简称拓扑序列。简单的说，由某个集合上的一个偏序得到该集合上的一个全序，这个操作称之为拓扑排序。</p><p>——百度百科</p></blockquote><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p>由 AOV 网构造拓扑序列的拓扑排序算法主要是循环执行以下两步，直到不存在入度为0的顶点为止。</p><ol><li><p>选择一个入度为 0 的顶点并输出之；</p></li><li><p>从网中删除此顶点及所有出边。</p><p>循环结束后，若输出的顶点数小于网中的顶点数，则输出“有回路”信息，否则输出的顶点序列就是一种拓扑序列。</p></li></ol><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define _CRTSECURE_NOWARNINGS#pragma warning(disable:4996)#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;cmath&gt;#include&lt;cctype&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;vector&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;list&gt;using namespace std;#define MAXN 10005int n, m, cnt;  //n 个数, m 个关系, cnt: 存储ans数组的下标bool mp[MAXN][MAXN];int indeg[MAXN], ans[MAXN];//indeg[i]: 第i个点的入度; ans[]: 答案队列queue &lt;int&gt; q;void Getmap(void){scanf("%d%d", &amp;n, &amp;m);for (int i = 1; i &lt;= m; i++){int x, y;scanf("%d%d", &amp;x, &amp;y);mp[x][y] = 1;indeg[y]++;//建图, 同时统计入度}}void topo_sort(void){for (int i = 1; i &lt;= n; i++)if (!indeg[i])q.push(i);//将所有入度为 0 的点入队while (!q.empty())//开始搜索{int u = q.front();ans[++cnt] = u;//入度为0的点记得放到答案队列里, 判断环的核心, 看答案数组是否有 n 个q.pop();for (int i = 1; i &lt;= n; i++)if (mp[u][i])//删边的操作转化为入度减1{indeg[i]--;if (!indeg[i])//如果这个点变成入度为 0, 入队列q.push(i);}}}int main(){Getmap();topo_sort();if (cnt &lt; n)//判断是否有环, 答案队列不足即有环{printf("Circle\n");return 0;}for (int i = 1; i &lt;= n; i++)printf("%d\n", ans[i]);return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="GYM-102219-J-•-Kitchen-Plates"><a href="#GYM-102219-J-•-Kitchen-Plates" class="headerlink" title="GYM 102219 J • Kitchen Plates"></a><a href="https://codeforces.com/gym/102219/problem/J">GYM 102219 J • Kitchen Plates</a></h2><p>time limit per test: 1 second</p><p>memory limit per test: 256 megabytes</p><p>input: standard input</p><p>output: standard output</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>You are given 5 different sizes of kitchen plates. Each plate is marked with a letter A, B, C, D, or E. You are given 5 statements comparing two different plates, you need to rearrange the plates from smallest size to biggest size. For example: the sizes of these plates.</p><p><img src="https://cdn.jsdelivr.net/gh/OwlllOvO/Hexo-image/20210416193013.png"></p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The input consist of 5 lines. In each line there will be 3 characters, the first and last character will be either A, B, C, D, or E and the middle character will be either &gt; or &lt; describing the comparison between two plates sizes. No two plates will be equal.</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>The output consist of 55 characters, the sorted order of balls from smallest to biggest plate. Otherwise, if the statements are contradicting print impossibleimpossible. If there are multiple answers, print any of them.</p><h3 id="Example-Input-1"><a href="#Example-Input-1" class="headerlink" title="Example Input 1"></a>Example Input 1</h3><pre class="line-numbers language-none"><code class="language-none">D&gt;BA&gt;DE&lt;CA&gt;BB&gt;C<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Example-Output-1"><a href="#Example-Output-1" class="headerlink" title="Example Output 1"></a>Example Output 1</h3><pre class="line-numbers language-none"><code class="language-none">ECBDA<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="Example-Input-2"><a href="#Example-Input-2" class="headerlink" title="Example Input 2"></a>Example Input 2</h3><pre class="line-numbers language-none"><code class="language-none">B&gt;EA&gt;BE&gt;AC&lt;BD&lt;B<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Example-Output-2"><a href="#Example-Output-2" class="headerlink" title="Example Output 2"></a>Example Output 2</h3><pre class="line-numbers language-none"><code class="language-none">impossible<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>拓扑排序</p><h3 id="Accepted-Code"><a href="#Accepted-Code" class="headerlink" title="Accepted Code"></a>Accepted Code</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define _CRTSECURE_NOWARNINGS#pragma warning(disable:4996)#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;cmath&gt;#include&lt;cctype&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;vector&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;list&gt;using namespace std;char str[10], ans[10];int indegree[10], e[10][10];bool book[10];int main(){while (scanf("%s", str) != EOF){memset(e, 0, sizeof(e));memset(indegree, 0, sizeof(indegree));memset(book, 0, sizeof(book));if (str[1] == '&lt;'){indegree[str[0] - 'A']++;e[str[2] - 'A'][str[0] - 'A']++;}else{indegree[str[2] - 'A']++;e[str[0] - 'A'][str[2] - 'A']++;}for (int i = 1; i &lt;= 4; i++){scanf("%s", str);if (str[1] == '&lt;'){indegree[str[0] - 'A']++;e[str[2] - 'A'][str[0] - 'A']++;}else{indegree[str[2] - 'A']++;e[str[0] - 'A'][str[2] - 'A']++;}}int len = 0;while (1){int temp = 0;for (int i = 0; i &lt; 5; i++)if (!indegree[i] &amp;&amp; book[i] == false){temp = 1;book[i] = 1;ans[len++] = i + 'A';for (int j = 0; j &lt; 5; j++){if (e[i][j]){e[i][j]--;indegree[j]--;}}break;}if (!temp)break;}if (len == 5){for (int i = len - 1; i &gt;= 0; i--)printf("%c", ans[i]);printf("\n");}else printf("impossible\n");}return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 拓扑排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搜索</title>
      <link href="2021/01/23/2021-1-23-sou-suo/"/>
      <url>2021/01/23/2021-1-23-sou-suo/</url>
      
        <content type="html"><![CDATA[<h1 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h1><h2 id="DFS-•-深度优先搜索"><a href="#DFS-•-深度优先搜索" class="headerlink" title="DFS • 深度优先搜索"></a>DFS • 深度优先搜索</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><blockquote><p>深度优先搜索属于图算法的一种，英文缩写为 DFS 即 Depth First Search. 其过程简要来说是对每一个可能的分支路径深入到不能再深入为止，而且每个节点只能访问一次。</p><p>——百度百科</p></blockquote><p>在一条路上的分岔按顺序选择方向，一条路走到底再返回到最近分岔选择下一条路，这个分岔下所有路全走完后再返回到更上一个分岔走下一条路。</p><h3 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h3><blockquote><p>深度优先遍历图的方法是，从图中某顶点v出发：</p><ol><li>访问顶点 v ；</li><li>依次从v的未被访问的邻接点出发，对图进行深度优先遍历；直至图中和v有路径相通的顶点都被访问；</li><li>若此时图中尚有顶点未被访问，则从一个未被访问的顶点出发，重新进行深度优先遍历，直到图中所有顶点均被访问过为止。</li></ol></blockquote><p><strong>搜索完节点后注意是否需要回溯！</strong></p><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">bool judge(int x, int y) {};//判断当前状态是否合法bool check(int x, int y) {};//判断是否为最终答案void dfs(int x, int y, int z){    if(!judge(x, y)) return;    if(check(x, y))    {        //保存答案    }    vis[x][y] = 1;//标记已搜索过此节点，防止重复搜索    /*        操作...    */    dfs(x - 1, y, z + 1);    dfs(x + 1, y, z + 1);    dfs(x, y - 1, z + 1);    dfs(x, y + 1, z + 1);    vis[x][y] = 0;//回溯}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><h4 id="剪枝"><a href="#剪枝" class="headerlink" title="剪枝"></a>剪枝</h4><p>有些求最优解的题目，可以不用完全遍历，当目前 dfs 的解已经比历史遍历得到的最优解更差时，可以停止遍历，节省一部分时间复杂度。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">bool judge(int x, int y) {};//判断当前状态是否合法bool check(int x, int y) {};//判断是否为最终答案void dfs(int x, int y, int z){    if(!judge(x, y)) return;    if(z &gt;= ans) return;    if(check(x, y))    {        ans = z;        //保存答案    }    vis[x][y] = 1;//标记已搜索过此节点，防止重复搜索    /*        操作...    */    dfs(x - 1, y, z + 1);    dfs(x + 1, y, z + 1);    dfs(x, y - 1, z + 1);    dfs(x, y + 1, z + 1);    vis[x][y] = 0;//回溯}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="记忆化搜索"><a href="#记忆化搜索" class="headerlink" title="记忆化搜索"></a>记忆化搜索</h4><p>对于遍历某些确定的类型时，如果到达一个节点之后的遍历结果是可以确定的，第一遍先向下遍历得到结果，将这个结果保存，之后再遍历到此节点时直接返回已得到的结果，可以节省一部分时间复杂度。</p><p>如：<a href="https://www.luogu.com.cn/problem/P1434">洛谷 P1434 [SHOI2002]滑雪</a></p><p>题目大意：矩阵求最长下降线路长度</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int fx[5] = { 0, 0, 0, 1, -1 };int fy[5] = { 0, 1, -1, 0, 0 };int dfs(int x, int y){if (f[x][y]) return f[x][y];//记忆化搜索f[x][y] = 1;//题目中答案是有包含这个点的for (int i = 1; i &lt;= 4; i++){int xx = fx[i] + x;int yy = fy[i] + y;//四个方向if (xx &gt; 0 &amp;&amp; yy &gt; 0 &amp;&amp; xx &lt;= n &amp;&amp; yy &lt;= m &amp;&amp; a[x][y] &gt; a[xx][yy]){f[x][y] = max(f[x][y], dfs(xx, yy) + 1);}}return f[x][y];}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="BFS-•-广度优先搜索"><a href="#BFS-•-广度优先搜索" class="headerlink" title="BFS • 广度优先搜索"></a>BFS • 广度优先搜索</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><blockquote><p>从出发点一层一层向外遍历，到达终点就结束。因此，到达终点的方案一定是最优解。</p></blockquote><blockquote><p>无论有多少条路，每条路都只走一步，并记录下状态，等到所有的路都走完一步后，再从第一条路开始走第二步，直至有一条路走到终点。</p></blockquote><h3 id="基本思路-1"><a href="#基本思路-1" class="headerlink" title="基本思路"></a>基本思路</h3><blockquote><p>广度优先搜索使用队列（queue）来实现，整个过程也可以看做一个倒立的树形：</p><ol><li><p>把根节点放到队列的末尾。</p></li><li><p>每次从队列的头部取出一个元素，查看这个元素所有的下一级元素，把它们放到队列的末尾。并把这个元素记为它下一级元素的前驱。</p></li><li><p>找到所要找的元素时结束程序。</p></li><li><p>如果遍历整个树还没有找到，结束程序。</p></li></ol></blockquote><h3 id="模板-1"><a href="#模板-1" class="headerlink" title="模板"></a>模板</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int fx[5] = { 0, -1, 1, 0, 0 };int fy[5] = { 0, 0, 0, -1, 1 };//上下左右struct node{    int x, y, z;};bool check (int x, int y) {};//判断点是否能走void bfs(int x, int y, int z){    node start;start.x = x;start.y = y;start.z = 0;//start 为出发点，z 为步数    queue &lt;node&gt; q;q.push(start);//将出发点推入队列中等待处理while (!q.empty()){        node now;now = q.front();//从队列中取出首元素处理q.pop();//将该元素取出后要记得推出，否则只推入不推出，死循环t[now.x][now.y] = now.z;//这里是记录了到 [now.x][now.y] 的最短路径，也可以做其他操作for (int i = 1; i &lt;= 4; i++)//往四个方向继续遍历{            if (check (now.x + fx[i], now.y + fy[i])){node next;next.x = now.x + fx[i];next.y = now.y + fy[i];next.z = now.z + 1;vi[next.x][next.y] = 1;q.push(next);//将该点保存并推入队列中，等待前面的处理完后再走下一步}}}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><h3 id="A-Find-a-way-•-HDU-2612"><a href="#A-Find-a-way-•-HDU-2612" class="headerlink" title="A Find a way • HDU 2612"></a>A <a href="https://vjudge.net/contest/419048#problem/A">Find a way</a> • <a href="https://vjudge.net/problem/HDU-2612/origin">HDU 2612</a></h3><h3 id="B-Dungeon-Master-•-POJ-2251"><a href="#B-Dungeon-Master-•-POJ-2251" class="headerlink" title="B Dungeon Master • POJ 2251"></a>B <a href="https://vjudge.net/contest/419048#problem/B">Dungeon Master</a> • <a href="https://vjudge.net/problem/POJ-2251/origin">POJ 2251</a></h3><h3 id="C-Red-and-Black-•-HDU-1312"><a href="#C-Red-and-Black-•-HDU-1312" class="headerlink" title="C Red and Black • HDU 1312"></a>C <a href="https://vjudge.net/contest/419048#problem/C">Red and Black</a> • <a href="https://vjudge.net/problem/HDU-1312/origin">HDU 1312</a></h3><h3 id="D-Counting-Sheep-•-HDU-2952"><a href="#D-Counting-Sheep-•-HDU-2952" class="headerlink" title="D Counting Sheep • HDU 2952"></a>D <a href="https://vjudge.net/contest/419048#problem/D">Counting Sheep</a> • <a href="https://vjudge.net/problem/HDU-2952/origin">HDU 2952</a></h3><h3 id="E-N皇后问题-•-HDU-2553"><a href="#E-N皇后问题-•-HDU-2553" class="headerlink" title="E N皇后问题 • HDU 2553"></a>E <a href="https://vjudge.net/contest/419048#problem/E">N皇后问题</a> • <a href="https://vjudge.net/problem/HDU-2553/origin">HDU 2553</a></h3><h3 id="F-A-Funny-Bipartite-Graph-•-计蒜客-42577"><a href="#F-A-Funny-Bipartite-Graph-•-计蒜客-42577" class="headerlink" title="F  A Funny Bipartite Graph • 计蒜客 42577"></a>F <a href="https://vjudge.net/contest/419048#problem/F"> A Funny Bipartite Graph</a> • <a href="https://vjudge.net/problem/%E8%AE%A1%E8%92%9C%E5%AE%A2-42577/origin">计蒜客 42577</a></h3><h3 id="G-wyh2000-and-pupil-•-HDU-5285"><a href="#G-wyh2000-and-pupil-•-HDU-5285" class="headerlink" title="G wyh2000 and pupil • HDU 5285"></a>G <a href="https://vjudge.net/contest/419048#problem/G">wyh2000 and pupil</a> • <a href="https://vjudge.net/problem/HDU-5285/origin">HDU 5285</a></h3><h3 id="H-Legal-or-Not-•-HDU-3342"><a href="#H-Legal-or-Not-•-HDU-3342" class="headerlink" title="H Legal or Not • HDU 3342"></a>H <a href="https://vjudge.net/contest/419048#problem/H">Legal or Not</a> • <a href="https://vjudge.net/problem/HDU-3342/origin">HDU 3342</a></h3>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 搜索 </tag>
            
            <tag> DFS </tag>
            
            <tag> BFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分查找</title>
      <link href="2021/01/22/2021-1-22-er-fen-cha-zhao/"/>
      <url>2021/01/22/2021-1-22-er-fen-cha-zhao/</url>
      
        <content type="html"><![CDATA[<h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><blockquote><p>二分查找也称折半查找（Binary Search），它是一种效率较高的查找方法。但是，折半查找要求线性表必须采用顺序存储结构，而且表中元素按关键字有序排列。</p><p>——百度百科</p></blockquote><ul><li><p>有序排列</p><p><code>sort (a + 1, a + n + 1, cmp);</code></p></li><li><p>时间复杂度 <strong>O(logn)</strong></p></li></ul><p>学了二分以后给我的感觉就是很多东西都可以拿来二分，以前以为只有查找可以用二分，现在知道原来很多有范围的东西，都可以用二分来逼近答案。</p><h2 id="整数二分"><a href="#整数二分" class="headerlink" title="整数二分"></a>整数二分</h2><h3 id="找-gt-s-的数中最小的"><a href="#找-gt-s-的数中最小的" class="headerlink" title="找 >= s 的数中最小的"></a>找 &gt;= s 的数中最小的</h3><ul><li><p>记录答案</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">bool check (int x){    if (a[x] &gt;= s) return 1;    else return 0;}int l = 1, r = n, ans = 0;while (l &lt;= r){    int mid = (l + r) / 2;    if (check (mid))    {        ans = mid;        r = mid - 1;    }    else l = mid + 1;}printf ("%d", a[ans]);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><ul><li><p>不记录答案 • r 逼近答案</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int l = 1, r = n;while (l &lt; r){    int mid = (l + r) / 2;    if (a[mid] &gt;= s) r = mid;    else l = mid + 1;}printf ("%d", a[r]);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>如果 a[mid] &gt;= s 成立，接下来应该向左继续查找，而此时 mid 是符合要求的，所以要保留，因此 r = mid</p></li><li><p>如果 a[mid] &gt;= s 不成立，接下来应该向右继续查找，而此时 mid 是不符合要求的，所以要舍弃，因此 l = mid + 1</p></li><li><p>输出的数一定是要符合要求的，每次查找 r = mid，r一定是符合要求，而 l 不一定，所以输出 r</p></li></ul><h3 id="找-lt-s-的数中最大的"><a href="#找-lt-s-的数中最大的" class="headerlink" title="找 < s 的数中最大的"></a>找 &lt; s 的数中最大的</h3><ul><li><p>记录答案</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">bool check (int x){    if (a[x] &lt; s) return 1;    else return 0;}int l = 1, r = n, ans = 0;while (l &lt;= r){    int mid = (l + r) / 2;    if (check (mid))    {        ans = mid;        l = mid + 1;    }    else r = mid - 1;}printf ("%d", a[ans]);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><ul><li><p>不记录答案 • l 逼近答案</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int l = 1, r = n;while (l &lt; r){    int mid = (l + r + 1) / 2;    if (a[i] &lt; s) l = mid;    else r = mid - 1;}printf ("%d", a[l]);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>如果 a[mid] &lt; s 成立，接下来应该向右继续查找，而此时 mid 是符合答案的，所以要保留，因此 l = mid</p></li><li><p>如果 a[mid] &lt; s 不成立，接下来应该向左继续查找，而此时 mid 是不符合答案的，所以要舍弃，因此 r = mid - 1</p></li><li><p>输出的数一定是要符合要求的，每次查找 l = mid，l一定是符合要求，而 r 不一定，所以输出 l</p></li></ul><h2 id="浮点二分"><a href="#浮点二分" class="headerlink" title="浮点二分"></a>浮点二分</h2><p>浮点二分只能用记录答案方法，而且要设置一个范围使得查找能退出循环</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">const double eps = 1e-8;double l = 0, r = n;while (r - l &gt; eps){    double mid = (l + r) / 2;    if (check (mid))    {        ans = mid;        r = mid - 1;    }    else l = r + 1;}printf ("%d", ans);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><h3 id="A-Can-you-solve-this-equation-•-HDU-2199"><a href="#A-Can-you-solve-this-equation-•-HDU-2199" class="headerlink" title="A Can you solve this equation? • HDU 2199"></a>A <a href="https://vjudge.net/contest/418909#problem/A">Can you solve this equation?</a> • <a href="http://acm.hdu.edu.cn/showproblem.php?pid=2199">HDU 2199</a></h3><h3 id="B-Dating-with-girls-1-•-HDU-2578"><a href="#B-Dating-with-girls-1-•-HDU-2578" class="headerlink" title="B Dating with girls(1) • HDU 2578"></a>B <a href="https://vjudge.net/contest/418909#problem/B">Dating with girls(1)</a> • <a href="http://acm.hdu.edu.cn/showproblem.php?pid=2578">HDU 2578</a></h3><h3 id="C-Aggressive-cows-•-POJ-2456"><a href="#C-Aggressive-cows-•-POJ-2456" class="headerlink" title="C Aggressive cows • POJ 2456"></a>C <a href="https://vjudge.net/contest/418909#problem/C">Aggressive cows</a> • <a href="http://poj.org/problem?id=2456">POJ 2456</a></h3><h3 id="D-Pie-•-POJ-3122"><a href="#D-Pie-•-POJ-3122" class="headerlink" title="D  Pie • POJ 3122"></a>D <a href="https://vjudge.net/contest/418909#problem/D"> Pie</a> • <a href="http://poj.org/problem?id=3122">POJ 3122</a></h3><h3 id="E-River-Hopscotch-•-POJ-3258"><a href="#E-River-Hopscotch-•-POJ-3258" class="headerlink" title="E River Hopscotch • POJ 3258"></a>E <a href="https://vjudge.net/contest/418909#problem/E">River Hopscotch</a> • <a href="http://poj.org/problem?id=3258">POJ 3258</a></h3><h3 id="F-4-Values-whose-Sum-is-0-•-POJ-2785"><a href="#F-4-Values-whose-Sum-is-0-•-POJ-2785" class="headerlink" title="F 4 Values whose Sum is 0 • POJ 2785"></a>F <a href="https://vjudge.net/contest/418909#problem/F">4 Values whose Sum is 0</a> • <a href="http://poj.org/problem?id=2785">POJ 2785</a></h3><h3 id="G-Defuse-the-Bombs-•-Gym-102822D"><a href="#G-Defuse-the-Bombs-•-Gym-102822D" class="headerlink" title="G Defuse the Bombs • Gym 102822D"></a>G <a href="https://vjudge.net/contest/418909#problem/G">Defuse the Bombs</a> • <a href="https://vjudge.net/problem/Gym-102822D/origin">Gym 102822D</a></h3>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 二分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并查集</title>
      <link href="2021/01/21/2021-1-21-bing-cha-ji/"/>
      <url>2021/01/21/2021-1-21-bing-cha-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><blockquote><p>并查集是一种树型的数据结构，用于处理一些不相交集合（disjoint sets）的合并及查询问题。常常在使用中以森林来表示。</p><p>——百度百科</p></blockquote><h2 id="主要操作"><a href="#主要操作" class="headerlink" title="主要操作"></a>主要操作</h2><ul><li><p>初始化</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int f[N];void Init(int x){for (int i = 1; i &lt;= x; i++)f[i] = i;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使所有元素都指向自己，将自己作为父节点</p></li><li><p>查找</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int Find(int x){    if (x == f[x]) return x;    return Find(x);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>合并</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void Merge(int x, int y){    f[Find(x)] = Find(y);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><h3 id="路径压缩"><a href="#路径压缩" class="headerlink" title="路径压缩"></a>路径压缩</h3><blockquote><p>每次查找的时候，如果路径较长，则修改信息，以便下次查找的时候速度更快。</p><p>第一步，找到根结点。</p><p>第二步，修改查找路径上的所有节点，将它们都指向根结点。</p><p>——百度百科</p></blockquote><ul><li><p>查找</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int Find(int x){    if (x == f[x]) return x;    f[x] = Find (f[x]);    return f[x];}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>或者写成这样：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int Find(int x){    if (x != f[x]) f[x] = Find (f[x]);    return f[x];}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>再用二元运算符：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int Find(int x) { return x == f[x] ? x : (f[x] = Find(f[x])); }<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><del>这么写可以让自己看起来更加大佬</del></p></li></ul><h3 id="按秩合并"><a href="#按秩合并" class="headerlink" title="按秩合并"></a>按秩合并</h3><p>将深度小的树合并到深度大的树上</p><ul><li><p>初始化</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void Init(int x){for (int i = 1; i &lt;= x; i++){f[i] = i;rank[i] = 1;//深度都初始化为1}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>合并</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void Merge(int x, int y){int a = Find(x), b = Find(y);//先找到两个根节点if (rank[a] &lt;= rank[b]) f[a] = b;else fa[b] = a;if (rank[a] == rank[b] &amp;&amp; a != b) rank[b]++;//如果深度相同且根节点不同，则新的根节点的深度+1}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因为是小的直接连接到大的根节点，所以合并时小的那一支的深度+1，只有当两者深度相同时才会产生更大的深度</p></li></ul><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><h3 id="种族并查集"><a href="#种族并查集" class="headerlink" title="种族并查集"></a>种族并查集</h3><p>通过多个并查集将不同的元素归类，并维护相互之间的关系</p><p>例题：<a href="https://www.luogu.com.cn/problem/P2024">洛谷 P2024 食物链</a></p><p>用三个并查集分别表示自己、自己的猎物（自己吃的）以及自己的天敌（吃自己的），同时维护三个并查集，通过他们三者的关系判断当前读入数据是否为真</p><h3 id="带权并查集"><a href="#带权并查集" class="headerlink" title="带权并查集"></a>带权并查集</h3><p><strong>基于路径压缩</strong>，每个节点都记录的是与根节点之间的权值</p><ul><li><p>查找</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int Find(int x){if (x != f[x]){int t = f[x];f[x] = Find(f[x]);value[x] += value[t];}return f[x];}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>合并</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void Merge(int x, int y){    int px = Find(x);    int py = Find(y);    if (px != py)    {        f[px] = py;        value[px] = -value[x] + value[y] + s;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/OwlllOvO/Hexo-image/20210121213127.PNG"></p></li></ul><h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><h3 id="A-Ubiquitous-Religions-•-POJ-2524"><a href="#A-Ubiquitous-Religions-•-POJ-2524" class="headerlink" title="A Ubiquitous Religions • POJ 2524"></a>A <a href="https://vjudge.net/contest/418701#problem/A">Ubiquitous Religions</a> • <a href="http://poj.org/problem?id=252">POJ 2524</a></h3><h3 id="B-食物链-•-洛谷-P2024"><a href="#B-食物链-•-洛谷-P2024" class="headerlink" title="B 食物链 • 洛谷 P2024"></a>B <a href="https://vjudge.net/contest/418701#problem/B">食物链</a> • <a href="https://www.luogu.com.cn/problem/P2024">洛谷 P2024</a></h3><h3 id="C-How-Many-Tables-•-HDU-1213"><a href="#C-How-Many-Tables-•-HDU-1213" class="headerlink" title="C How Many Tables • HDU 1213"></a>C <a href="https://vjudge.net/contest/418701#problem/C">How Many Tables</a> • <a href="http://acm.hdu.edu.cn/showproblem.php?pid=1213">HDU 1213</a></h3><h3 id="D-畅通工程-•-HDU-1232"><a href="#D-畅通工程-•-HDU-1232" class="headerlink" title="D 畅通工程 • HDU 1232"></a>D <a href="https://vjudge.net/contest/418701#problem/D">畅通工程</a> • <a href="https://vjudge.net/problem/HDU-1232/origin">HDU 1232</a></h3><h3 id="E-人见人爱A-B-•-HDU-2035"><a href="#E-人见人爱A-B-•-HDU-2035" class="headerlink" title="E 人见人爱A^B •  HDU 2035"></a>E <a href="https://vjudge.net/contest/418701#problem/E">人见人爱A^B</a> • <a href="http://acm.hdu.edu.cn/showproblem.php?pid=2035"> HDU 2035</a></h3><h3 id="F-How-Many-Answers-Are-Wrong-•-HDU-3038"><a href="#F-How-Many-Answers-Are-Wrong-•-HDU-3038" class="headerlink" title="F How Many Answers Are Wrong •  HDU 3038"></a>F <a href="https://vjudge.net/contest/418701#problem/F">How Many Answers Are Wrong</a> • <a href="http://acm.hdu.edu.cn/showproblem.php?pid=3038"> HDU 3038</a></h3>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础知识</title>
      <link href="2021/01/20/2021-1-20-ji-chu-zhi-shi/"/>
      <url>2021/01/20/2021-1-20-ji-chu-zhi-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="常用-OJ"><a href="#常用-OJ" class="headerlink" title="常用 OJ"></a>常用 OJ</h2><ul><li><p><a href="https://vjudge.net/">Vjudge</a></p></li><li><p><a href="http://www.nowcoder.com/">nowcoder</a></p></li><li><p><a href="https://pintia.cn/">PTA</a></p></li></ul><h2 id="常用语言-C"><a href="#常用语言-C" class="headerlink" title="常用语言 - C++"></a>常用语言 - C++</h2><p><del>终于用回 C++ 了，上程序设计基础转 C 好累</del></p><p>万能头文件 <code>#include&lt;bits/stdc++.h&gt;</code></p><p>等于以下头文件：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;algorithm&gt;#include &lt;bitset&gt;#include &lt;complex&gt;#include &lt;deque&gt;#include &lt;exception&gt;#include &lt;fstream&gt;#include &lt;functional&gt;#include &lt;iomanip&gt;#include &lt;ios&gt;#include &lt;iosfwd&gt;#include &lt;iostream&gt;#include &lt;istream&gt;#include &lt;iterator&gt;#include &lt;limits&gt;#include &lt;list&gt;#include &lt;locale&gt;#include &lt;map&gt;#include &lt;memory&gt;#include &lt;new&gt;#include &lt;numeric&gt;#include &lt;ostream&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;sstream&gt;#include &lt;stack&gt;#include &lt;stdexcept&gt;#include &lt;streambuf&gt;#include &lt;string&gt;#include &lt;typeinfo&gt;#include &lt;utility&gt;#include &lt;valarray&gt;#include &lt;vector&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>(Visual Studio 不自带万能头文件)</p><h2 id="时间（空间）复杂度"><a href="#时间（空间）复杂度" class="headerlink" title="时间（空间）复杂度"></a>时间（空间）复杂度</h2><p><del>dddd懂的都懂</del></p><h2 id="C-STL"><a href="#C-STL" class="headerlink" title="C++: STL"></a>C++: STL</h2><h3 id="string-•-字符串"><a href="#string-•-字符串" class="headerlink" title="string • 字符串"></a>string • 字符串</h3><h4 id="头文件-include-lt-string-gt"><a href="#头文件-include-lt-string-gt" class="headerlink" title="头文件 : #include<string>"></a>头文件 : <code>#include&lt;string&gt;</code></h4><h4 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h4><ul><li>赋初值</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">string s1 = "1234";string s2;s2 = "1234";<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><p>清除</p><p><code>s1.clear();</code></p></li><li><p>求长度</p><p><code>l = s1.length();</code></p></li><li><p>在尾部插入字符</p><p><code>s1.push_back('x');</code></p></li><li><p>在尾部插入字符串</p><p><code>s1.append(s2);</code></p></li><li><p>从s1中找到字符 ‘x’ 的位置</p><p><code>pos = s1.find('x');</code></p></li><li><p>删除</p><p><code>s1.erase()</code></p></li></ul><h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><h4 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h4><p>​    <code>    vector&lt;int&gt;v1;</code></p><p>​    <code>vector&lt;string&gt;v2("1234");</code></p><p>​    <code>vecotr&lt;int&gt;v3(5,2);</code></p><p>​    <code>vector&lt;int&gt;v4(v3);</code></p><h4 id="常用函数-1"><a href="#常用函数-1" class="headerlink" title="常用函数"></a>常用函数</h4><ul><li><p>在数组的最后添加一个数据</p><p><code>v1.push_back();</code></p></li><li><p>去掉数组的最后一个数据</p><p><code>v1.pop_back();</code></p></li><li><p>得到数组头的引用</p><p><code>v1.front();</code></p></li><li><p>得到数组的最后一个单元的引用</p><p><code>v1.back();</code></p></li><li><p>获取 vector 大小</p><p><code>v1.size();</code></p></li></ul><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><ul><li>随机访问 <strong>O(1)</strong></li><li>删除 <strong>O(n)</strong></li></ul><h3 id="queue-•-FIFO"><a href="#queue-•-FIFO" class="headerlink" title="queue • FIFO"></a>queue • FIFO</h3><h4 id="构造-1"><a href="#构造-1" class="headerlink" title="构造"></a>构造</h4><p>​    <code>queue&lt;int&gt; q;</code></p><h4 id="常用函数-2"><a href="#常用函数-2" class="headerlink" title="常用函数"></a>常用函数</h4><ul><li><p>入队</p><p><code>q.push();</code></p></li><li><p>出队</p><p><code>q.pop();</code></p></li><li><p>首位</p><p><code>q.front();</code></p></li><li><p>末位</p><p><code>q.back();</code></p></li><li><p>大小</p><p><code>q.size();</code></p></li><li><p>判断是否为空</p><p><code>q.empty();</code></p></li></ul><h3 id="stack-•-FILO"><a href="#stack-•-FILO" class="headerlink" title="stack • FILO"></a>stack • FILO</h3><h4 id="构造-2"><a href="#构造-2" class="headerlink" title="构造"></a>构造</h4><p>​    <code>stack&lt;int&gt; s;</code></p><h4 id="常用函数-3"><a href="#常用函数-3" class="headerlink" title="常用函数"></a>常用函数</h4><ul><li><p>入队</p><p><code>s.push();</code></p></li><li><p>出队</p><p><code>s.pop();</code></p></li><li><p>首位</p><p><code>s.top();</code></p></li><li><p>大小</p><p><code>s.size();</code></p></li><li><p>判断是否为空</p><p><code>s.empty();</code></p></li></ul><h3 id="set-•-集合"><a href="#set-•-集合" class="headerlink" title="set • 集合"></a>set • 集合</h3><h4 id="构造-3"><a href="#构造-3" class="headerlink" title="构造"></a>构造</h4><p>​    <code>set&lt;int&gt;s;</code></p><h4 id="常用函数-4"><a href="#常用函数-4" class="headerlink" title="常用函数"></a>常用函数</h4><ul><li><p>插入</p><p><code>s.insert();</code></p></li><li><p>清除</p><p><code>s.erase();</code></p></li><li><p>查找</p><p><code>s.find([int]);</code></p></li><li><p>大小</p><p><code>[int] = s.size();</code></p></li><li><p>清空</p><p><code>s.clear();</code></p></li><li><p>值元素个数</p><p><code>s.count([int]);</code></p></li><li><p>首元</p><p><code>s.begin();</code></p></li><li><p>末元</p><p><code>s.end();</code></p></li><li><p>是否为空</p><p><code>s.empty();</code></p></li></ul><h4 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><ul><li>查询 <strong>O(logn)</strong></li><li>插入 <strong>O(logn)</strong></li><li>删除 <strong>O(logn)</strong></li></ul><h3 id="map-•-key-value"><a href="#map-•-key-value" class="headerlink" title="map • key - value"></a>map • key - value</h3><h4 id="构造-4"><a href="#构造-4" class="headerlink" title="构造"></a>构造</h4><p>​    1.<code>map&lt;int,int&gt;mp;</code></p><p>​    2.<code>map&lt;string,int&gt;mp;</code></p><h4 id="常用函数-5"><a href="#常用函数-5" class="headerlink" title="常用函数"></a>常用函数</h4><ul><li><p>访问</p><p>1.<code>mp[[int]] = [int];</code></p><p>2.<code>mp[[string]] = [int];</code></p></li></ul><h4 id="时间复杂度-2"><a href="#时间复杂度-2" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><ul><li>插入 <strong>O(logn)</strong></li><li>删除 <strong>O(logn)</strong></li></ul><h3 id="list-•-双向链表"><a href="#list-•-双向链表" class="headerlink" title="list • 双向链表"></a>list • 双向链表</h3><h4 id="构造-5"><a href="#构造-5" class="headerlink" title="构造"></a>构造</h4><p>​    <code>list&lt;int&gt;li;</code></p><h4 id="常用函数-6"><a href="#常用函数-6" class="headerlink" title="常用函数"></a>常用函数</h4><ul><li><p>加到末位</p><p><code>li.push_back();</code></p></li><li><p>加到首位</p><p><code>li.push_front();</code></p></li><li><p>去掉末位</p><p><code>li.pop_back();</code></p></li><li><p>去掉首位</p><p><code>li.pop_front();</code></p></li><li><p>插入</p><p><code>li.insert();</code></p></li><li><p>删除</p><p><code>li.erase();</code></p></li></ul><h4 id="时间复杂度-3"><a href="#时间复杂度-3" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><ul><li>随机访问 <strong>×</strong></li><li>插入 <strong>O(1)</strong></li><li>删除 <strong>O(1)</strong></li></ul><h3 id="sort-•-快速排序"><a href="#sort-•-快速排序" class="headerlink" title="sort • 快速排序"></a>sort • 快速排序</h3><p><del>用习惯 sort 后受够了 qsort 的折磨，现在终于回来了</del></p><p><del>qsort 到现在都还没学会，还好期末开卷照着书打</del></p><h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><h3 id="A-Rails-•-POJ-1363"><a href="#A-Rails-•-POJ-1363" class="headerlink" title="A Rails • POJ 1363"></a>A <a href="https://vjudge.net/contest/418487#problem/A">Rails</a> • <a href="https://vjudge.net/problem/POJ-1363/origin">POJ 1363</a></h3><h3 id="B-表达式括号匹配-•-计蒜客-T1655"><a href="#B-表达式括号匹配-•-计蒜客-T1655" class="headerlink" title="B 表达式括号匹配 • 计蒜客 T1655"></a>B <a href="https://vjudge.net/contest/418487#problem/B">表达式括号匹配</a> • <a href="https://vjudge.net/problem/%E8%AE%A1%E8%92%9C%E5%AE%A2-T1655/origin">计蒜客 T1655</a></h3><h3 id="C-Let-the-Balloon-Rise-•-HDU-1004"><a href="#C-Let-the-Balloon-Rise-•-HDU-1004" class="headerlink" title="C  Let the Balloon Rise  • HDU 1004"></a>C <a href="https://vjudge.net/contest/418487#problem/C"> Let the Balloon Rise</a>  • <a href="https://vjudge.net/problem/HDU-1004/origin">HDU 1004</a></h3><h3 id="D-ACboy-needs-your-help-again-•-HDU-1702"><a href="#D-ACboy-needs-your-help-again-•-HDU-1702" class="headerlink" title="D  ACboy needs your help again! • HDU 1702"></a>D <a href="https://vjudge.net/contest/418487#problem/D"> ACboy needs your help again!</a> • <a href="https://vjudge.net/problem/HDU-1702/origin">HDU 1702</a></h3><h3 id="E-排名-•-HDU-1236"><a href="#E-排名-•-HDU-1236" class="headerlink" title="E 排名 • HDU 1236"></a>E <a href="https://vjudge.net/contest/418487#problem/E">排名</a> • <a href="https://vjudge.net/problem/HDU-1236/origin">HDU 1236</a></h3><h3 id="F-人见人爱A-B-•-HDU-2034"><a href="#F-人见人爱A-B-•-HDU-2034" class="headerlink" title="F  人见人爱A-B • HDU 2034"></a>F <a href="https://vjudge.net/contest/418487#problem/F"> 人见人爱A-B</a> • <a href="https://vjudge.net/problem/HDU-2034/origin">HDU 2034</a></h3><h3 id="G-水果-•-HDU-1263"><a href="#G-水果-•-HDU-1263" class="headerlink" title="G 水果 • HDU 1263"></a>G <a href="https://vjudge.net/contest/418487#problem/G">水果</a> • <a href="https://vjudge.net/problem/HDU-1263/origin">HDU 1263</a></h3><h3 id="H-看病要排队-•-HDU-1873"><a href="#H-看病要排队-•-HDU-1873" class="headerlink" title="H 看病要排队 • HDU 1873"></a>H <a href="https://vjudge.net/contest/418487#problem/H">看病要排队</a> • <a href="https://vjudge.net/problem/HDU-1873/origin">HDU 1873</a></h3>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mouseline • 鼠标吸附线条效果</title>
      <link href="2021/01/20/2021-1-20-mouseline-shu-biao-xi-fu-xian-tiao-xiao-guo/"/>
      <url>2021/01/20/2021-1-20-mouseline-shu-biao-xi-fu-xian-tiao-xiao-guo/</url>
      
        <content type="html"><![CDATA[<p>将以下 JavaScript 代码粘贴到网页的页脚 HTML 中即可实现。</p><p>对于 matery 主题来说，放置在 <code>matery\layout\_partial\footer.ejs</code> 文件末尾即可。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token operator">&lt;</span>script<span class="token operator">&gt;</span><span class="token operator">!</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">function</span> <span class="token function">n</span><span class="token punctuation">(</span><span class="token parameter">n<span class="token punctuation">,</span>e<span class="token punctuation">,</span>t</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span> n<span class="token punctuation">.</span><span class="token function">getAttribute</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token operator">||</span>t<span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">e</span><span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span> document<span class="token punctuation">.</span><span class="token function">getElementsByTagName</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">t</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">var</span> t<span class="token operator">=</span><span class="token function">e</span><span class="token punctuation">(</span><span class="token string">"script"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>o<span class="token operator">=</span>t<span class="token punctuation">.</span>length<span class="token punctuation">,</span>i<span class="token operator">=</span>t<span class="token punctuation">[</span>o<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">return</span><span class="token punctuation">{</span>l<span class="token operator">:</span>o<span class="token punctuation">,</span>z<span class="token operator">:</span><span class="token function">n</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span><span class="token string">"zIndex"</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>o<span class="token operator">:</span><span class="token function">n</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span><span class="token string">"opacity"</span><span class="token punctuation">,</span><span class="token number">.5</span><span class="token punctuation">)</span><span class="token punctuation">,</span>c<span class="token operator">:</span><span class="token function">n</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span><span class="token string">"color"</span><span class="token punctuation">,</span><span class="token string">"0,0,0"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>n<span class="token operator">:</span><span class="token function">n</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span><span class="token string">"count"</span><span class="token punctuation">,</span><span class="token number">99</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">o</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>a<span class="token operator">=</span>m<span class="token punctuation">.</span>width<span class="token operator">=</span>window<span class="token punctuation">.</span>innerWidth<span class="token operator">||</span>document<span class="token punctuation">.</span>documentElement<span class="token punctuation">.</span>clientWidth<span class="token operator">||</span>document<span class="token punctuation">.</span>body<span class="token punctuation">.</span>clientWidth<span class="token punctuation">,</span>c<span class="token operator">=</span>m<span class="token punctuation">.</span>height<span class="token operator">=</span>window<span class="token punctuation">.</span>innerHeight<span class="token operator">||</span>document<span class="token punctuation">.</span>documentElement<span class="token punctuation">.</span>clientHeight<span class="token operator">||</span>document<span class="token punctuation">.</span>body<span class="token punctuation">.</span>clientHeight<span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">i</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>r<span class="token punctuation">.</span><span class="token function">clearRect</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>a<span class="token punctuation">,</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> n<span class="token punctuation">,</span>e<span class="token punctuation">,</span>t<span class="token punctuation">,</span>o<span class="token punctuation">,</span>m<span class="token punctuation">,</span>l<span class="token punctuation">;</span>s<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">i<span class="token punctuation">,</span>x</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token punctuation">.</span>x<span class="token operator">+=</span>i<span class="token punctuation">.</span>xa<span class="token punctuation">,</span>i<span class="token punctuation">.</span>y<span class="token operator">+=</span>i<span class="token punctuation">.</span>ya<span class="token punctuation">,</span>i<span class="token punctuation">.</span>xa<span class="token operator">*=</span>i<span class="token punctuation">.</span>x<span class="token operator">&gt;</span>a<span class="token operator">||</span>i<span class="token punctuation">.</span>x<span class="token operator">&lt;</span><span class="token number">0</span><span class="token operator">?</span><span class="token operator">-</span><span class="token number">1</span><span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">,</span>i<span class="token punctuation">.</span>ya<span class="token operator">*=</span>i<span class="token punctuation">.</span>y<span class="token operator">&gt;</span>c<span class="token operator">||</span>i<span class="token punctuation">.</span>y<span class="token operator">&lt;</span><span class="token number">0</span><span class="token operator">?</span><span class="token operator">-</span><span class="token number">1</span><span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">,</span>r<span class="token punctuation">.</span><span class="token function">fillRect</span><span class="token punctuation">(</span>i<span class="token punctuation">.</span>x<span class="token operator">-</span><span class="token number">.5</span><span class="token punctuation">,</span>i<span class="token punctuation">.</span>y<span class="token operator">-</span><span class="token number">.5</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>e<span class="token operator">=</span>x<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>e<span class="token operator">&lt;</span>u<span class="token punctuation">.</span>length<span class="token punctuation">;</span>e<span class="token operator">++</span><span class="token punctuation">)</span>n<span class="token operator">=</span>u<span class="token punctuation">[</span>e<span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">null</span><span class="token operator">!==</span>n<span class="token punctuation">.</span>x<span class="token operator">&amp;&amp;</span><span class="token keyword">null</span><span class="token operator">!==</span>n<span class="token punctuation">.</span>y<span class="token operator">&amp;&amp;</span><span class="token punctuation">(</span>o<span class="token operator">=</span>i<span class="token punctuation">.</span>x<span class="token operator">-</span>n<span class="token punctuation">.</span>x<span class="token punctuation">,</span>m<span class="token operator">=</span>i<span class="token punctuation">.</span>y<span class="token operator">-</span>n<span class="token punctuation">.</span>y<span class="token punctuation">,</span>l<span class="token operator">=</span>o<span class="token operator">*</span>o<span class="token operator">+</span>m<span class="token operator">*</span>m<span class="token punctuation">,</span>l<span class="token operator">&lt;</span>n<span class="token punctuation">.</span>max<span class="token operator">&amp;&amp;</span><span class="token punctuation">(</span>n<span class="token operator">===</span>y<span class="token operator">&amp;&amp;</span>l<span class="token operator">&gt;=</span>n<span class="token punctuation">.</span>max<span class="token operator">/</span><span class="token number">2</span><span class="token operator">&amp;&amp;</span><span class="token punctuation">(</span>i<span class="token punctuation">.</span>x<span class="token operator">-=</span><span class="token number">.03</span><span class="token operator">*</span>o<span class="token punctuation">,</span>i<span class="token punctuation">.</span>y<span class="token operator">-=</span><span class="token number">.03</span><span class="token operator">*</span>m<span class="token punctuation">)</span><span class="token punctuation">,</span>t<span class="token operator">=</span><span class="token punctuation">(</span>n<span class="token punctuation">.</span>max<span class="token operator">-</span>l<span class="token punctuation">)</span><span class="token operator">/</span>n<span class="token punctuation">.</span>max<span class="token punctuation">,</span>r<span class="token punctuation">.</span><span class="token function">beginPath</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>r<span class="token punctuation">.</span>lineWidth<span class="token operator">=</span>t<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">,</span>r<span class="token punctuation">.</span>strokeStyle<span class="token operator">=</span><span class="token string">"rgba("</span><span class="token operator">+</span>d<span class="token punctuation">.</span>c<span class="token operator">+</span><span class="token string">","</span><span class="token operator">+</span><span class="token punctuation">(</span>t<span class="token operator">+</span><span class="token number">.2</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">")"</span><span class="token punctuation">,</span>r<span class="token punctuation">.</span><span class="token function">moveTo</span><span class="token punctuation">(</span>i<span class="token punctuation">.</span>x<span class="token punctuation">,</span>i<span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">,</span>r<span class="token punctuation">.</span><span class="token function">lineTo</span><span class="token punctuation">(</span>n<span class="token punctuation">.</span>x<span class="token punctuation">,</span>n<span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">,</span>r<span class="token punctuation">.</span><span class="token function">stroke</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">x</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">var</span> a<span class="token punctuation">,</span>c<span class="token punctuation">,</span>u<span class="token punctuation">,</span>m<span class="token operator">=</span>document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">"canvas"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>d<span class="token operator">=</span><span class="token function">t</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>l<span class="token operator">=</span><span class="token string">"c_n"</span><span class="token operator">+</span>d<span class="token punctuation">.</span>l<span class="token punctuation">,</span>r<span class="token operator">=</span>m<span class="token punctuation">.</span><span class="token function">getContext</span><span class="token punctuation">(</span><span class="token string">"2d"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>x<span class="token operator">=</span>window<span class="token punctuation">.</span>requestAnimationFrame<span class="token operator">||</span>window<span class="token punctuation">.</span>webkitRequestAnimationFrame<span class="token operator">||</span>window<span class="token punctuation">.</span>mozRequestAnimationFrame<span class="token operator">||</span>window<span class="token punctuation">.</span>oRequestAnimationFrame<span class="token operator">||</span>window<span class="token punctuation">.</span>msRequestAnimationFrame<span class="token operator">||</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span><span class="token punctuation">{</span>window<span class="token punctuation">.</span><span class="token function">setTimeout</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span><span class="token number">1e3</span><span class="token operator">/</span><span class="token number">45</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">,</span>w<span class="token operator">=</span>Math<span class="token punctuation">.</span>random<span class="token punctuation">,</span>y<span class="token operator">=</span><span class="token punctuation">{</span>x<span class="token operator">:</span><span class="token keyword">null</span><span class="token punctuation">,</span>y<span class="token operator">:</span><span class="token keyword">null</span><span class="token punctuation">,</span>max<span class="token operator">:</span><span class="token number">2e4</span><span class="token punctuation">}</span><span class="token punctuation">;</span>m<span class="token punctuation">.</span>id<span class="token operator">=</span>l<span class="token punctuation">,</span>m<span class="token punctuation">.</span>style<span class="token punctuation">.</span>cssText<span class="token operator">=</span><span class="token string">"position:fixed;top:0;left:0;z-index:"</span><span class="token operator">+</span>d<span class="token punctuation">.</span>z<span class="token operator">+</span><span class="token string">";opacity:"</span><span class="token operator">+</span>d<span class="token punctuation">.</span>o<span class="token punctuation">,</span><span class="token function">e</span><span class="token punctuation">(</span><span class="token string">"body"</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">o</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>window<span class="token punctuation">.</span>onresize<span class="token operator">=</span>o<span class="token punctuation">,</span>window<span class="token punctuation">.</span><span class="token function-variable function">onmousemove</span><span class="token operator">=</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span><span class="token punctuation">{</span>n<span class="token operator">=</span>n<span class="token operator">||</span>window<span class="token punctuation">.</span>event<span class="token punctuation">,</span>y<span class="token punctuation">.</span>x<span class="token operator">=</span>n<span class="token punctuation">.</span>clientX<span class="token punctuation">,</span>y<span class="token punctuation">.</span>y<span class="token operator">=</span>n<span class="token punctuation">.</span>clientY<span class="token punctuation">}</span><span class="token punctuation">,</span>window<span class="token punctuation">.</span><span class="token function-variable function">onmouseout</span><span class="token operator">=</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>y<span class="token punctuation">.</span>x<span class="token operator">=</span><span class="token keyword">null</span><span class="token punctuation">,</span>y<span class="token punctuation">.</span>y<span class="token operator">=</span><span class="token keyword">null</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> s<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>f<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>d<span class="token punctuation">.</span>n<span class="token operator">&gt;</span>f<span class="token punctuation">;</span>f<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">var</span> h<span class="token operator">=</span><span class="token function">w</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">*</span>a<span class="token punctuation">,</span>g<span class="token operator">=</span><span class="token function">w</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">*</span>c<span class="token punctuation">,</span>v<span class="token operator">=</span><span class="token number">2</span><span class="token operator">*</span><span class="token function">w</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>p<span class="token operator">=</span><span class="token number">2</span><span class="token operator">*</span><span class="token function">w</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>s<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span>x<span class="token operator">:</span>h<span class="token punctuation">,</span>y<span class="token operator">:</span>g<span class="token punctuation">,</span>xa<span class="token operator">:</span>v<span class="token punctuation">,</span>ya<span class="token operator">:</span>p<span class="token punctuation">,</span>max<span class="token operator">:</span><span class="token number">6e3</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span>u<span class="token operator">=</span>s<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">i</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Creating my blog</title>
      <link href="2021/01/20/2021-1-20-creating-my-blog/"/>
      <url>2021/01/20/2021-1-20-creating-my-blog/</url>
      
        <content type="html"><![CDATA[<h1 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h1><h2 id="为什么选择-Hexo"><a href="#为什么选择-Hexo" class="headerlink" title="为什么选择 Hexo"></a>为什么选择 Hexo</h2><p>以前第一次建站的时候因为什么都不知道，就跟着一个教程做了 Wordpress 网站。Wordpress 的优点很明显——非常的方便。不仅建站的时候直接选择 Wordpress 就完成了，之后再在控制台维护网站就行。但之后因为上学，就没再去维护，服务器也没有续，网站就这么没有了..</p><p>这次 ACM 寒假训练，要求我们创建自己的博客，我想着自己都已经创建过自己的网站，就不想用 CSDN、博客园之类的博客，于是又准备重新搭建网站。这时候我了解到了 Hexo，这是一个静态网站，把文件都放在 Github 上，由 Github 托管。这是 Hexo 的一大优点，这样一来不仅不收费，而且只要 Github 还在，网站就不会消失。但这不是我选择 Hexo 的原因。我选择 Hexo 的主要原因还是看到很多非常精美的博客都是用的 Hexo，而 Wordpress 的网站实在找不到好看的主题，于是我也想搭建 Hexo 网站。</p><p>一开始用 Hexo 觉得很麻烦，什么东西都是在文件里修改参数，对网站的操作都要用命令执行，不像 Wordpress 有后台可以非常方便、直观地维护网站。但是用久了之后，学会了之后发现，Hexo 这样才更加方便。因为所有文件都在本地，网站的任何属性都写在文件里面了，想要修改什么直接在文件里修改，更加的灵活，这也是 Hexo 能做得更精美，更加个性化的原因。</p><h2 id="Hexo-建站过程"><a href="#Hexo-建站过程" class="headerlink" title="Hexo 建站过程"></a>Hexo 建站过程</h2><p>写这些不仅是记录我建站的整个过程，还详细地记录我对网站的操作和修改，以后万一需要重做网站，也可以帮助自己回忆 XD</p><h3 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h3><ul><li><p>macOS 切换 Root 用户</p><ul><li>终端输入指令：<code>sudo su</code></li><li>输入用户密码</li></ul></li><li><p>安装 Node.js</p><ul><li>访问网站 <a href="https://nodejs.org/en/">Node.js</a> 下载最新版本</li><li>安装</li><li>安装完成后即可在终端（cmd）输入指令：<ul><li><code>node -v </code>：查看已安装的 Node 版本，查看是否安装成功</li><li><code>npm -v</code>：查看已安装的 npm 版本，查看是否安装成功</li></ul></li></ul></li><li><p>安装淘宝 cnpm 管理器（加速）</p><ul><li><code>npm install -g cnpm --registry=http://registry.npm.taobao.org</code></li><li>自动安装</li><li><code>cnpm -v</code>：查看已安装的 cnpm 版本，查看是否安装成功</li></ul></li></ul><h3 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h3><ul><li><p>安装 Hexo 框架</p><ul><li><code>cnpm install -g hexo-cli</code></li><li>自动安装</li><li><code>hexo -v</code>：查看已安装的 Hexo 版本，查看是否安装成功</li></ul></li><li><p>建立 Blog 文件夹</p><ul><li><code>mkdir Blog</code>：创建 Blog 文件夹</li><li><code>cd blog</code>：进入 Blog 文件夹</li><li>之后要是出现问题，直接删除 Blog 文件夹从头开始重新做就行</li></ul></li><li><p>Windows 安装 Git</p><ul><li>访问 <a href="https://git-scm.com/">Git</a>，下载 Git 并安装</li><li>之后用 Git Bash 输命令或者继续用 cmd</li></ul></li><li><p>创建 Hexo</p><ul><li>macOS：<code>sudo hexo init</code>：用管理员权限初始化 Hexo</li><li>Windows：<code>hexo init</code>：初始化 Hexo</li></ul></li></ul><h3 id="Hexo-操作"><a href="#Hexo-操作" class="headerlink" title="Hexo 操作"></a>Hexo 操作</h3><ul><li><p>启动 Hexo（本地预览）</p><ul><li><code>hexo s</code> s: start 启动 Hexo</li><li>复制显示的网址用浏览器打开即可</li><li><code>Ctrl + C</code> <code>Y</code> 停止</li></ul></li><li><p>新建文章</p><ul><li><code>hexo n "title"</code> n: new 新建文章</li><li>在 <code>Blog\source\_posts\</code> 中找到新建的 .md 文件用 Typora 编辑</li></ul></li><li><p>生成 Hexo</p><ul><li><code>hexo clean</code>：清理 Hexo</li><li><code>hexo g</code>：生成 Hexo</li></ul></li><li><p>先生成，应用修改，后启动查看效果</p></li></ul><h3 id="将博客部署到远端（Github）"><a href="#将博客部署到远端（Github）" class="headerlink" title="将博客部署到远端（Github）"></a>将博客部署到远端（Github）</h3><ul><li><p>访问 <a href="https://github.com/">Github</a></p></li><li><p>注册/登录 账号</p></li><li><p>新建仓库</p><ul><li>点击右上角 <code>+</code></li><li>点击 <code>New repository</code></li><li>Repository name 填写：Username.github.io</li><li>点击 <code>create repository</code></li></ul></li><li><p><code>cnpm install --save hexo-deployer-git</code> ：在 Blog 目录下安装 Git 部署插件</p></li><li><p>自动安装 忽略 Warning</p></li><li><p>编辑 <code>Blog\_config.yml</code> 文件</p><ul><li><p>下拉找到 <code>\# Deployment</code></p><pre class="line-numbers language-none"><code class="language-none">deploy:  type: git  repo: https://github.com/Username/Username.github.io  branch: master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>如果 type 后有单引号’’，git 填在单引号里面</p><p>repo 填的是 Github Repo 的地址，复制过来就行</p></li><li><p>保存并退出</p></li></ul></li><li><p><code>hexo d</code> d: deploy 部署到远端</p><ul><li>第一次部署要求输入 Github 账号密码</li></ul></li><li><p>访问 Username.github.io 即可</p></li></ul><h3 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h3><ul><li><p><code>git clone 主题网址.git themes/主题名</code></p></li><li><p>编辑 <code>Blog\_config.yml</code> 文件</p><ul><li><p>下拉找到 <code>theme</code></p></li><li><p>修改为 <code>theme: 主题名</code></p></li><li><p>重新清理，生成，启动</p></li><li><p><code>hexo clean</code></p></li><li><p><code>hexo g</code></p></li><li><p><code>hexo s</code></p></li></ul></li></ul><h2 id="Hexo-个性化定制"><a href="#Hexo-个性化定制" class="headerlink" title="Hexo 个性化定制"></a>Hexo 个性化定制</h2><h3 id="将目录背景设为透明"><a href="#将目录背景设为透明" class="headerlink" title="将目录背景设为透明"></a>将目录背景设为透明</h3><p><code>themes/matery/source/libs/materialize/materialize.min.css</code> 中搜索 <code>.card</code>，有一个结果的 <code>.card</code> 后面直接跟着 <code>{</code>。在这个大括号中删除原来的背景，添加 <code>background-color: rgba(255,255,255, 0) !important;</code></p><p>（主要是在 <code>element.style</code> 里有将背景设为白色，但是找不到这个在哪，就用 <code>! important</code> 强制将背景改为透明，曲线救国）</p>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2021/01/20/hello-world/"/>
      <url>2021/01/20/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
