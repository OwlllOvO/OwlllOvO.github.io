<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>2021.2.4</title>
      <link href="2021/02/04/2021-2-4/"/>
      <url>2021/02/04/2021-2-4/</url>
      
        <content type="html"><![CDATA[<h1 id="2021-2-4"><a href="#2021-2-4" class="headerlink" title="2021.2.4"></a>2021.2.4</h1><h2 id="LCA"><a href="#LCA" class="headerlink" title="LCA"></a>LCA</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><blockquote><p>对于有根树 T 的两个结点 u、v，最近公共祖先 LCA(T, u, v) 表示一个结点 x，满足 x 是 u 和 v 的祖先且 x 的深度尽可能大。在这里，一个节点也可以是它自己的祖先。</p><p>——百度百科</p></blockquote><h3 id="Tarjan-•-离线"><a href="#Tarjan-•-离线" class="headerlink" title="Tarjan • 离线"></a>Tarjan • 离线</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><blockquote><p>利用并查集优越的时空复杂度，我们可以实现 LCA 问题的 O(n + Q) 算法，这里 Q 表示询问的次数。</p></blockquote><ul><li>Tarjan 算法基于深度优先搜索的框架，对于新搜索到的一个结点，首先创建由这个结点构成的集合，再对当前结点的每一个子树进行搜索，每搜索完一棵子树，则可确定子树内的 LCA 询问都已解决。其他的 LCA 询问的结果必然在这个子树之外，这时把子树所形成的集合与当前结点的集合合并，并将当前结点设为这个集合的祖先。</li><li>之后继续搜索下一棵子树，直到当前结点的所 有子树搜索完。这时把当前结点也设为已被检查过的，同时可以处理有关当前结点的 LCA 询问，如果有一个从当前结点到结点 v 的询问，且 v 已被检查过，则由于进行的是深度优先搜索，当前结点与 v 的最近公共祖先一定还没有被检查，而这个最近公共祖先的包涵 v 的子树一定已经搜索过了，那么这个最近公共祖先一定是 v 所在集合的祖先。</li></ul>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> LCA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021.2.3</title>
      <link href="2021/02/03/2021-2-3/"/>
      <url>2021/02/03/2021-2-3/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021.2.2</title>
      <link href="2021/02/02/2021-2-2/"/>
      <url>2021/02/02/2021-2-2/</url>
      
        <content type="html"><![CDATA[<h1 id="2021-2-2"><a href="#2021-2-2" class="headerlink" title="2021.2.2"></a>2021.2.2</h1><h2 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><blockquote><p>背包问题 (Knapsack problem) 是一种组合优化的 NP 完全问题。问题可以描述为：给定一组物品，每种物品都有自己的重量和价格，在限定的总重量内，我们如何选择，才能使得物品的总价格最高。</p><p>——百度百科</p></blockquote><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul><li>01 背包：有 N 件物品和一个容量为 V 的背包。第 i 件物品的重量是 w[i]，价值是 v[i]。求解将哪些物品装入背包可使这些物品的重量总和不超过背包容量，且价值总和最大。<strong>每样物品可取1件</strong></li><li>完全背包：有 N 种物品和一个容量为 V 的背包，每种物品都有 <strong>无限</strong> 件可用。第 i 种物品的体积是 c，价值是 w。将哪些物品装入背包可使这些物品的体积总和不超过背包容量，且价值总和最大。</li><li>多重背包：有 N 种物品和一个容量为 V 的背包。第 i 种物品最多 <strong>有 n 件</strong> 可用，每件体积是 c，价值是 w。求解将哪些物品装入背包可使这些物品的体积总和不超过背包容量，且价值总和最大。</li></ul><h2 id="01-背包"><a href="#01-背包" class="headerlink" title="01 背包"></a>01 背包</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>有 N 件物品和一个容量为 V 的背包。第 i 件物品的重量是 w[i]，价值是 v[i]。求解将哪些物品装入背包可使这些物品的重量总和不超过背包容量，且价值总和最大。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>每样物品最多可以取1次，即对于每样物品只有 <strong>取</strong> 或 <strong>不取</strong> 两种状态。</p>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> DP </tag>
            
            <tag> 01背包 </tag>
            
            <tag> 完全背包 </tag>
            
            <tag> 多重背包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021.1.31</title>
      <link href="2021/01/31/2021-1-31/"/>
      <url>2021/01/31/2021-1-31/</url>
      
        <content type="html"><![CDATA[<h1 id="2021-1-31"><a href="#2021-1-31" class="headerlink" title="2021.1.31"></a>2021.1.31</h1><h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><blockquote><p>一个有 n 个结点的连通图的生成树是原图的极小连通子图，且包含原图中的所有 n 个结点，并且有保持图连通的最少的边。</p><p>——百度百科</p></blockquote><h3 id="Kruskal"><a href="#Kruskal" class="headerlink" title="Kruskal"></a>Kruskal</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>用贪心的思想，把所有的边从短到长排序，从最短的边开始判断，如果连接的两个点不是已经联通的，那就把这条边连起来。如果已经联通，则忽略这条边。</p><p>用并查集维护所有的点，联通的点在同一集合，从而判断点是否联通。</p><h4 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 110;int n, m, f[maxn];struct Edge{int u, v, w;bool operator &lt; (const Edge&amp; r)const//边权从小到大排序{return w &lt; r.w;}} E[maxn * maxn];int find(int x){return x == f[x] ? x : f[x] = find(f[x]);}void Kruskal(int n, int m){int res = 0;// 存放结果int num = 0;// 记录当前选择了多少条边sort(E + 1, E + 1 + m);for (int i = 1; i &lt;= n; i++) f[i] = i;//初始化 每个点自己为一个集合for (int i = 1; i &lt;= m; i++){int f1 = find(E[i].u);//  查询u顶点在哪个集合中int f2 = find(E[i].v);//  查询v顶点在哪个集合中if (f1 != f2)//  如果不在同一个集合中{num++;//  选中的边数 +1res += E[i].w;//  答案加上这条边的权值f[f1] = f2;//  将这两个点合并到一个集合中}if (num == n - 1)// 如果已经找到了 n - 1条边，说明最小生成树已经构建完成了break;}if (num == n - 1) printf("%d\n", res);else  puts("?");}int main() {while (~scanf("%d %d", &amp;m, &amp;n)) {if (m == 0) break;for (int i = 1; i &lt;= m; i++)scanf("%d%d%d", &amp;E[i].u, &amp;E[i].v, &amp;E[i].w);Kruskal(n, m);}return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h4><ul><li>O(m log m)</li></ul><h3 id="Prim"><a href="#Prim" class="headerlink" title="Prim"></a>Prim</h3><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><ol><li>选用图中的任意一个顶点 v<sub>0</sub>，从 v<sub>0</sub> 开始生成最小生成树</li><li>初始化 d[v<sub>0</sub>] = 0，其他的点的距离值 d[i] = INF，其中 d[i] 表示当前这棵小树到其他点的最小距离值</li><li>经过 N 次如下步骤操作，最后得到一个含 N 各顶点，N - 1 条边的最小生成树<ol><li>选择一个未标记的点 K，并且 d[K] 的值是最小的</li><li>标记点 K 进入这棵小树</li><li>以 K 为中间点，更新这棵小树到未标记点的距离的最小值</li></ol></li><li>得到最小生成树 T</li></ol><h4 id="模板-1"><a href="#模板-1" class="headerlink" title="模板"></a>模板</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;bits/stdc++.h&gt;#define inf 0x3f3f3f3fusing namespace std;const int maxn = 110;int n, m, G[maxn][maxn], vis[maxn], d[maxn];void Prim(int n, int m){memset(vis, 0, sizeof(vis));int index = 1;  // 当前加入到小树的顶点int res = 0;    //  存放结果vis[index] = 1;for (int i = 1; i &lt;= n; i++)    // 更新这个点到其他点的距离  d[i] = G[index][i];for (int i = 1; i &lt; n; i++)     // 执行 n - 1 次， 找剩下的n - 1 个点{int minn = inf;for (int j = 1; j &lt;= n; j++)    // 找出未加入小树且 d 最小的点{if (!vis[j] &amp;&amp; d[j] &lt; minn){minn = d[j];index = j;}}if (minn == inf)     // 如果没有找到， 说明不存在最小生成树{puts("?");return;}res += minn;    // 累加答案vis[index] = 1;     // 将这个点加入最小生成树中for (int j = 1; j &lt;= n; j++)    // 更新这个点加入后，当前这棵小树到未加入的点的最近距离{if (!vis[j] &amp;&amp; d[j] &gt; G[index][j])  d[j] = G[index][j];}}printf("%d\n", res);}int main(){while (~scanf("%d%d", &amp;m, &amp;n)){if (m == 0) break;for (int i = 1; i &lt;= n; i++)    // 邻接矩阵的初始化{for (int j = 1; j &lt;= n; j++){if (i == j) G[i][j] = 0;else G[i][j] = inf;}}for (int i = 1, u, v, w; i &lt;= m; i++){scanf("%d%d%d", &amp;u, &amp;v, &amp;w);G[u][v] = G[v][u] = min(w, G[u][v]);    // 消除重边的影响}Prim(n, m);}return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h4><ul><li>O(n<sup>2</sup>)</li></ul>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 最小生成树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021.1.30</title>
      <link href="2021/01/30/2021-1-30/"/>
      <url>2021/01/30/2021-1-30/</url>
      
        <content type="html"><![CDATA[<h1 id="2021-1-30"><a href="#2021-1-30" class="headerlink" title="2021.1.30"></a>2021.1.30</h1><h2 id="最短路问题"><a href="#最短路问题" class="headerlink" title="最短路问题"></a>最短路问题</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><blockquote><p>最短路问题是图论理论的一个经典问题。寻找最短路径就是在指定网络中两结点间找一条距离最小的路。最短路不仅仅指一般地理意义上的距离最短,还可以引申到其它的度量,如时间、费用、线路容量等。</p><p>——百度百科</p></blockquote><h3 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h3><ul><li><p>Chain • 链：一个点和边的交错序列 v<sub>0</sub> - e<sub>1</sub> - v<sub>1</sub> - e<sub>2</sub> - v<sub>2</sub> - … - e<sub>k</sub> - v<sub>k</sub></p></li><li><p>Trail • 迹：对于一条路径 w，若e<sub>1</sub>, e<sub>2</sub>, …, e<sub>k</sub> 两两互不相同，则 w 是一条迹</p></li><li><p>Path • 路径：对于一条迹 w，除了 v<sub>0</sub> 和 v<sub>k</sub> 允许相同外，其余点两两互不相同，则称 w 是一条路径</p></li><li><p>Circuit • 回路：对于一个迹 w，若 v<sub>0</sub> = v<sub>k</sub>，则称 w 是一个回路</p></li><li><p>Cycle • 环：对于一条路径 w，若 v<sub>0</sub> = v<sub>k</sub>，则称 w 是一个环</p></li></ul><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul><li><p>单源最短路</p><p>包括确定起点的最短路径问题，确定终点的最短路径问题（与确定起点的问题相反，该问题是已知终结结点，求最短路径的问题。在无向图中该问题与确定起点的问题完全等同，在有向图中该问题等同于把所有路径方向反转的确定起点的问题。） 。</p></li><li><p>多源最短路</p></li></ul><h2 id="Dijkstra-•-单源最短路"><a href="#Dijkstra-•-单源最短路" class="headerlink" title="Dijkstra • 单源最短路"></a>Dijkstra • 单源最短路</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>将所有节点分成两个集合，已求出最短路的集合（集合1）和未求出最短路的集合（集合2）。</li><li>更新并记录集合2 中所有节点和源点的距离</li><li>从集合2 中找到距离源点距离最近的点</li><li>将该点移到集合1 中</li><li>重复步骤 2-3，直到集合2 为空</li></ol><p>这个方法用了贪心的思想，每次把距离最小的点视作确定的，因为它已经是未确定的点中距离源点最近的了，不可能存在一条路经过其他未确定的点到这个点，距离还比直接到这个点近的了。</p><ul><li><strong>不能有负权边</strong></li></ul><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><ul><li>dis[]：每个点到源点的距离</li><li>vis[]：每个点属于的集合，0 - 未确定，1 - 已确定</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void Dijkstra(int x){    memset (dis, INF, sizeof (dis));//源点到未更新到的点的距离为无穷大（无法达到）    memset (vis, 0, sizeof (vis));//所有点都先放在集合2 中    dis[x] = 0;    for (int i = 1; i &lt; n; i++)    {        int tmp;        for (int j = 1; j &lt;= n; j++)            if (!vis[j] &amp;&amp; dis[j] &lt; dis[tmp]) tmp = j;//找到集合2 中距离源点最近的点        vis[tmp] = 1;        for (int j = 1; j &lt;= n; j++)            dis[j] = min(dis[j], dis[tmp] + mp[x][j]);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><ul><li>O(n<sup>2</sup>)</li></ul><h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><ul><li><p>从一个点出发到所有点的距离：正 Dijkstra</p></li><li><p>从所有点出发到一个点的距离（<a href="http://poj.org/problem?id=3268">POJ 3268 • Silver Cow Party</a>）</p><ul><li><p>把图反向</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int tmp = map[i][j];map[i][j] = map[j][i];map[j][i] = tmp;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>Dijkstra</p></li></ul></li></ul><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><h2 id="Floyd-•-多源最短路"><a href="#Floyd-•-多源最短路" class="headerlink" title="Floyd • 多源最短路"></a>Floyd • 多源最短路</h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>我们定义一个数组 <code>dis[k][x][y]</code> ，表示只允许经过结点 V<sub>1</sub> 到 V<sub>k</sub>，结点 x 到结点 y 的最短路长度。很显然， <code>dis[n][x][y]</code> 就是最终结点 x 到结点 y 的最短路长度。</p><p><code>dis[0][x][y]</code> 是 x 与 y 的边权，或者 0 ，或者 INF（当 x 与 y 间有直接相连的边的时候，为它们的边权；当 x = y 的时候为零，因为到本身的距离为零；当 x 与 y 没有直接相连的边的时候，为 INF）</p><p><code>dis[k][x][y] = min(dis[k-1][x][y], dis[k-1][x][k]+dis[k-1][k][y])</code> （ <code>dis[k-1][x][y]</code> 为不经过 k 点的最短路径，而 <code>dis[k-1][x][k]+dis[k-1][k][y]</code> 为经过了 k 点的最短路）。</p><ul><li><p><strong>能有负权边</strong></p></li><li><p><strong>不能有负环</strong></p></li></ul><h3 id="模板-1"><a href="#模板-1" class="headerlink" title="模板"></a>模板</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void Floyd(){    for (int k = 1; k &lt;= n; k++)    {        for (int i = 1; i &lt;= n; i++)        {        for(int j = 1; j &lt;= n; j++)            {                dis[k][i][j] = min(dis[k - 1][i][j], dis[k - 1][i][k] + dis[k - 1][k][j]);            }        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>不难看出，k 每次循环后只是调用了 k - 1 的数据，而 k 之前的数据对结果没有作用，因此第一维是可以省略的（数据可以不保存，直接在下一次循环被覆盖，但是还是需要有这 k 次循环）</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void Floyd(){    for (int k = 1; k &lt;= n; k++)    {        for (int i = 1; i &lt;= n; i++)        {        for(int j = 1; j &lt;= n; j++)            {                dis[i][j] = min(dis[i][j], dis[i][k] + di[k][j]);            }        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h3><ul><li>时间复杂度：O(n<sup>3</sup>)</li><li>空间复杂度：O(n<sup>2</sup>)</li></ul><h2 id="Bellman-Ford-•-单源最短路"><a href="#Bellman-Ford-•-单源最短路" class="headerlink" title="Bellman-Ford • 单源最短路"></a>Bellman-Ford • 单源最短路</h2><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ul><li><p>松弛</p><p>每次松弛操作实际上是对相邻节点的访问，第 n 次松弛操作保证了所有深度为 n 的路径最短。由于图的最短路径最长不会经过超过 |V| - 1 条边，所以可知贝尔曼-福特算法所得为最短路径。</p></li><li><p>负边权操作</p><p>与 Dijkstra 算法不同的是，迪科斯彻算法的基本操作“拓展”是在深度上寻路，而“松弛”操作则是在广度上寻路，这就确定了贝尔曼-福特算法可以对负边进行操作而不会影响结果。</p></li><li><p>负权环判定</p><p>因为负权环可以无限制的降低总花费，所以如果发现第 n 次操作仍可降低花销，就一定存在负权环。</p></li></ul><ul><li><p><strong>能有负权边</strong></p></li><li><p><strong>能有负环</strong></p></li></ul><h3 id="优化-1"><a href="#优化-1" class="headerlink" title="优化"></a>优化</h3><ul><li><p>循环的提前跳出</p><p>在实际操作中，贝尔曼-福特算法经常会在未达到 |V| - 1 次前就出解，|V| - 1 其实是最大值。于是可以在循环中设置判定，在某次循环不再进行松弛时，直接退出循环，进行负权环判定。</p></li><li><p>最短路径快速算法</p><p>松弛操作必定只会发生在最短路径前导节点松弛成功过的节点上，用一个队列记录松弛过的节点，可以避免了冗余计算。该算法的复杂度为 O(k|E|)，k 是个比较小的系数，但该结论未得到广泛认可。</p></li></ul><h3 id="模板-2"><a href="#模板-2" class="headerlink" title="模板"></a>模板</h3><ul><li><del>SPFA已死</del></li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;list&gt;using namespace std;struct Edge{int to, len;};bool SPFA(const int&amp; beg,//出发点const vector&lt;list&lt;Edge&gt; &gt;&amp; adjlist,//邻接表，通过传引用避免拷贝vector&lt;int&gt;&amp; dist,//出发点到各点的最短路径长度vector&lt;int&gt;&amp; path)//路径上到达该点的前一个点//没有负权回路返回0{const int INF = 0x7FFFFFFF, NODE = adjlist.size();//用邻接表的大小传递顶点个数，减少参数传递dist.assign(NODE, INF);//初始化距离为无穷大path.assign(NODE, -1);//初始化路径为未知list&lt;int&gt; que(1, beg);//处理队列vector&lt;int&gt; cnt(NODE, 0);//记录各点入队次数，用于判断负权回路vector&lt;bool&gt; flag(NODE, 0);//标志数组，判断是否在队列中dist[beg] = 0;//出发点到自身路径长度为0cnt[beg] = flag[beg] = 1;//入队并开始计数while (!que.empty()){const int now = que.front();que.pop_front();flag[now] = 0;//将当前处理的点出队for (list&lt;Edge&gt;::const_iterator//用常量迭代器遍历邻接表i = adjlist[now].begin(); i != adjlist[now].end(); ++i)if (dist[i-&gt;to] &gt; dist[now] + i-&gt;len)//不满足三角不等式{dist[i-&gt;to] = dist[now] + i-&gt;len;//更新path[i-&gt;to] = now;//记录路径if (!flag[i-&gt;to])//若未在处理队列中{if (NODE == ++cnt[i-&gt;to])return 1;//计数后出现负权回路if (!que.empty() &amp;&amp; dist[i-&gt;to] &lt; dist[que.front()])//队列非空且优于队首（SLF）que.push_front(i-&gt;to);//放在队首else que.push_back(i-&gt;to);//否则放在队尾flag[i-&gt;to] = 1;//入队}}}return 0;}int main(){int n_num, e_num, beg;//含义见下cout &lt;&lt; "输入点数、边数、出发点：";cin &gt;&gt; n_num &gt;&gt; e_num &gt;&gt; beg;vector&lt;list&lt;Edge&gt; &gt; adjlist(n_num, list&lt;Edge&gt;());//默认初始化邻接表for (int i = 0, p; i != e_num; ++i){Edge tmp;cout &lt;&lt; "输入第" &lt;&lt; i + 1 &lt;&lt; "条边的起点、终点、长度：";cin &gt;&gt; p &gt;&gt; tmp.to &gt;&gt; tmp.len;adjlist[p].push_back(tmp);}vector&lt;int&gt; dist, path;//用于接收最短路径长度及路径各点if (SPFA(beg, adjlist, dist, path))cout &lt;&lt; "图中存在负权回路\n";else for (int i = 0; i != n_num; ++i){cout &lt;&lt; beg &lt;&lt; "到" &lt;&lt; i &lt;&lt; "的最短距离为" &lt;&lt; dist[i] &lt;&lt; "，反向打印路径：";for (int w = i; path[w] &gt;= 0; w = path[w])cout &lt;&lt; w &lt;&lt; "&lt;-";cout &lt;&lt; beg &lt;&lt; '\n';}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="复杂度-2"><a href="#复杂度-2" class="headerlink" title="复杂度"></a>复杂度</h3><ul><li>O(|V| · |E|)</li></ul><h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><h3 id="A-最短路-•-HDU-2544"><a href="#A-最短路-•-HDU-2544" class="headerlink" title="A  最短路 • HDU 2544"></a>A <a href="https://vjudge.net/contest/420578#problem/A"> 最短路</a> • <a href="http://acm.hdu.edu.cn/showproblem.php?pid=2544">HDU 2544</a></h3><h3 id="B-Til-the-Cows-Come-Home-•-POJ-2387"><a href="#B-Til-the-Cows-Come-Home-•-POJ-2387" class="headerlink" title="B  Til the Cows Come Home • POJ 2387"></a>B <a href="https://vjudge.net/contest/420578#problem/B"> Til the Cows Come Home</a> • <a href="http://poj.org/problem?id=2387">POJ 2387</a></h3><h3 id="C-Silver-Cow-Party-•-POJ-3268"><a href="#C-Silver-Cow-Party-•-POJ-3268" class="headerlink" title="C  Silver Cow Party • POJ 3268"></a>C <a href="https://vjudge.net/contest/420578#problem/C"> Silver Cow Party</a> • <a href="http://poj.org/problem?id=3268">POJ 3268</a></h3><h3 id="D-Heavy-Transportation-•-POJ-1797"><a href="#D-Heavy-Transportation-•-POJ-1797" class="headerlink" title="D  Heavy Transportation •  POJ 1797"></a>D <a href="https://vjudge.net/contest/420578#problem/D"> Heavy Transportation</a> • <a href="http://poj.org/problem?id=1797"> POJ 1797</a></h3><h3 id="E-Cow-Contest-•-POJ-3660"><a href="#E-Cow-Contest-•-POJ-3660" class="headerlink" title="E  Cow Contest • POJ 3660"></a>E <a href="https://vjudge.net/contest/420578#problem/E"> Cow Contest</a> • <a href="http://poj.org/problem?id=3660">POJ 3660</a></h3><h3 id="F-Edge-Deletion-•-CodeForces-1076D"><a href="#F-Edge-Deletion-•-CodeForces-1076D" class="headerlink" title="F Edge Deletion • CodeForces 1076D"></a>F <a href="https://vjudge.net/contest/420578#problem/F">Edge Deletion</a> • <a href="https://codeforces.com/problemset/problem/1076/D">CodeForces 1076D</a></h3>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> Floyd </tag>
            
            <tag> Dijkstra </tag>
            
            <tag> SPFA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021.1.29</title>
      <link href="2021/01/29/2021-1-29/"/>
      <url>2021/01/29/2021-1-29/</url>
      
        <content type="html"><![CDATA[<h1 id="2021-1-29"><a href="#2021-1-29" class="headerlink" title="2021.1.29"></a>2021.1.29</h1><h2 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h2><blockquote><p>Hash，一般翻译做散列、杂凑，或音译为哈希，是把任意长度的输入（又叫做预映射pre-image）通过散列算法变换成固定长度的输出，该输出就是散列值。这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，所以不可能从散列值来确定唯一的输入值。简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> Hash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021.1.27</title>
      <link href="2021/01/27/2021-1-27/"/>
      <url>2021/01/27/2021-1-27/</url>
      
        <content type="html"><![CDATA[<h1 id="2021-1-27"><a href="#2021-1-27" class="headerlink" title="2021.1.27"></a>2021.1.27</h1><h2 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>斐波那契数列：1, 1, 2, 3, 5, 8, 13, 21, 34, 55, …</p><p>即：</p><ul><li>a<sub>n</sub> = 1    (n = 1 or n = 2)</li><li>a<sub>n</sub> = a<sub>n-1</sub> + a<sub>n-2</sub>    (n &gt;= 3)</li></ul><p>求斐波那契的第 n 项</p><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>找到了其中的 <strong>最优子结构</strong>（递归公式）：f(n) = f(n - 1) + f(n - 2)</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">long long func(int n){    if (n == 1 || n == 2) return 1;    return func(n - 1) + func(n - 2);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h4><ul><li>时间复杂度 • O(2<sup>n</sup>)</li></ul><h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>计算 f(n) 时要计算 f(n - 1) 和 f(n - 2)，而计算 f(n - 1) 要计算 f(n - 2) 和 f(n - 3)…因此有很多是重复计算，因此考虑到用空间换时间，记录下这些值，以后需要计算这些值的时候直接返回已经计算得到的值即可</p><h3 id="空间换时间-•-记忆化"><a href="#空间换时间-•-记忆化" class="headerlink" title="空间换时间 • 记忆化"></a>空间换时间 • 记忆化</h3><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>发现有很多值重复计算，用空间换时间</p><h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">long long f[1001] = {0, 1, 1};long long func(int n){    if (!f[n]) f[n] = func(n - 1) + func(n - 2);    return f[n];}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h4><ul><li>时间复杂度 • O(n)</li></ul><h4 id="优化-1"><a href="#优化-1" class="headerlink" title="优化"></a>优化</h4><p>不难发现，结果是从前往后一位一位计算得到的，第 3 位，第 4 位…第 n 位。而每次计算的时候只与这一位的前两位有关系，因此可以使用循环的方法完成。</p><h3 id="递归变循环"><a href="#递归变循环" class="headerlink" title="递归变循环"></a>递归变循环</h3><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>打印空间，发现是按顺序从前往后运行的</p><h4 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">long long f[10001] = {0, 1, 1};long long func(int n){    for (int i = 3; i &lt;= n; i++) f[i] = f[i - 1] + f[i - 2];    return f[n];}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="复杂度-2"><a href="#复杂度-2" class="headerlink" title="复杂度"></a>复杂度</h4><ul><li><p>时间复杂度 • O(n)</p></li><li><p>空间复杂度 • O(n)</p></li></ul><h4 id="优化-2"><a href="#优化-2" class="headerlink" title="优化"></a>优化</h4><p>不难发现，当前值至于前两个值有关，因此不需要保留前两个之前的值</p><h3 id="空间压缩-•-即用即抛"><a href="#空间压缩-•-即用即抛" class="headerlink" title="空间压缩 • 即用即抛"></a>空间压缩 • 即用即抛</h3><h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><p>发现很多空间被重复利用，每次计算只与前两项有关</p><h4 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">long long a = 1, b = 1, c;long long func(int n){    for (int i = 3; i &lt;= n; i++)    {        c = b;        b = a + b;        a = c;    }    return b ;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>时间复杂度 • O(n)</p></li><li><p>空间复杂度 • O(1)</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021.1.25</title>
      <link href="2021/01/25/2021-1-25/"/>
      <url>2021/01/25/2021-1-25/</url>
      
        <content type="html"><![CDATA[<h1 id="2021-1-25"><a href="#2021-1-25" class="headerlink" title="2021.1.25"></a>2021.1.25</h1><h2 id="问题引入"><a href="#问题引入" class="headerlink" title="问题引入"></a>问题引入</h2><p>假设需要反复对一个数组 a[] 进行以下两个操作：</p><ul><li><p>Query • 求和</p><p>对 a[l] ~ a[r] 求和</p></li><li><p>Update • 修改</p><p>将 a[idx] 的值修改为 val</p></li></ul><p>则有如下解决办法：</p><h3 id="朴素做法"><a href="#朴素做法" class="headerlink" title="朴素做法"></a>朴素做法</h3><ul><li><p>Build</p><p><code>for (int i = 1; i &lt;= n; i++) scanf ("%d", &amp;a[i]);</code></p></li><li><p>Query</p><p><code>for (int i = l; i &lt;= r; i++) sum += a[i];</code> <code>O(n)</code></p></li><li><p>Update</p><p><code>a[idx] = val;</code> <code>O(1)</code></p></li></ul><h3 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h3><ul><li><p>Build</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">for (int i = 1; i &lt;= l; i++){scanf ("%d", &amp;a[i]);sum_a[i] = sum_a[i-1] + a[i];}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>Query</p><p><code>sum = sum_a[r] - sum_a[l - 1];</code> <code>O(1)</code></p></li><li><p>Update</p><p><code>for (int i = idx; i &lt;= n; i++) sum_a[i] += val; </code> <code>O(n)</code></p></li></ul><p>可见，两种方法的时间复杂度都较高，于是引入线段树的数据结构</p><h2 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><blockquote><p>线段树是一种二叉搜索树，与区间树相似，它将一个区间划分成一些单元区间，每个单元区间对应线段树中的一个叶结点。</p><p>——百度百科</p></blockquote><ul><li><p>Build</p><p>如图，区间依次对半分，每个节点存储一部分区间的和，节点按序标记为 1 ~ n（图中为 0 ~ n - 1）</p><img src="https://cdn.jsdelivr.net/gh/OwlllOvO/Hexo-image/20210125202804.png" style="zoom: 50%;"></li><li><p>Query <code>O(logn)</code></p><ul><li>从根结点开始划分求和区间</li><li>如果节点区间为求和区间的子集：返回节点值</li><li>如果节点区间与求和区间无交集：返回 0</li></ul></li><li><p>Update <code>O(logn)</code></p><ul><li>找到修改的节点，修改值</li><li>向上更新节点值</li></ul></li></ul><h3 id="模板-•-单点修改-•-结构体"><a href="#模板-•-单点修改-•-结构体" class="headerlink" title="模板 • 单点修改 • 结构体"></a>模板 • 单点修改 • 结构体</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define MAXN 1e6+10int a[MAXN], n;struct segmentTree{    int l, r, sum;} node[MAXN &lt;&lt; 2];void pushUp(int i){    node[i].sum = node[i &lt;&lt; 1].sum + node[i &lt;&lt; 1 | 1].sum;}void build_tree(int l, int r, int i){    node[i] = { l, r };    if (l == r)    {        node[i],sum = a[l];        return;    }    int mid = l + r &gt;&gt; 1;    build_tree(l, mid, i &lt;&lt; 1);    build_tree(mid + 1, r, i &lt;&lt; 1 | 1);    pushUp(i);}int query_tree(int l, int r, int i){    if (l &lt;= node[i].l &amp;&amp; node[i].r &lt;= r) return node[i].sum;    int mid = l + r &gt;&gt; 1;    int res = 0;    if (l &lt;= mid) res += query_tree(l, mid, i &lt;&lt; 1);    if (r &gt; mid)  res += query_tree(mid + 1, r, i &lt;&lt; 1 | 1);    return res;}void update_tree(int idx, int val, int i){    if (node[i].l == idx &amp;&amp; node[i].r == idx)    {        node[i].sum = val;        return;    }    int mid = l + r &gt;&gt; 1;    if (idx &lt;= mid) update_tree(idx, val, i &lt;&lt; 1);    else update_tree(idx, val, i &lt;&lt; 1 | 1);    pushUp();}int main(){    build_tree(1, n, 1);    query_tree(l, r, 1);    update_tree(idx, val, 1);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>x &lt;&lt; 1: x * 2</li><li>x &gt;&gt; 1: x / 2</li><li>x &lt;&lt; 1 | 1: x * 2 + 1</li></ul><h3 id="模板-•-单点修改-•-数组"><a href="#模板-•-单点修改-•-数组" class="headerlink" title="模板 • 单点修改 • 数组"></a>模板 • 单点修改 • 数组</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define MAXN 1e6+10int a[MAXN], tree[MAXN * 4], n;void build_tree(int node, int start, int end){    if (start == end) tree[node] = arr[start];    int mid = (start + end) / 2;    int left_node  = 2 * node;    int right_node = 2 * node + 1;    build_tree(left_node, start, mid);    build_tree(right_node, mid + 1, end);    tree[node] = tree[left_node] + tree[right_node];}int query_tree(int node, int start, int end, int L, int R){    if (R &lt; start || L &gt; end) return 0;    if (L &lt;= start &amp;&amp; end &lt;= R) return tree[node];    if (start == end) return tree[node];    int mid = (start + end) / 2;    int left_node  = 2 * node;int right_node = 2 * node + 1;    int sum_left  = query_tree(left_node,  start, mid, L, R);    int sum_right = query_tree(right_node, mid+1, end, L, R);}void update_tree(int node, int start, int end, int idx, int val){    if (start == end)    {        a[idx] = val;        tree[node] = val;        return;    }    int mid = (start + end) / 2;    int left_node  = 2 * node;int right_node = 2 * node + 1;    if (idx &gt;= start &amp;&amp; idx &lt;= mid)        update_tree(left_node, start, mid, idx, val);    else        update_tree(right_node, mid+1, end, idx, val);    tree[node] = tree[left_node] + tree[right_node];}int main(){    build_tree(1, 1, n);    query_tree(1, 1, n, L, R);    update_tree(1, 1, n, idx, val);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="模板-•-区间修改"><a href="#模板-•-区间修改" class="headerlink" title="模板 • 区间修改"></a>模板 • 区间修改</h3><h3 id="权值线段树"><a href="#权值线段树" class="headerlink" title="权值线段树"></a>权值线段树</h3><h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><h3 id="A-例题1-•-SPOJ-GSS1"><a href="#A-例题1-•-SPOJ-GSS1" class="headerlink" title="A 例题1 • SPOJ GSS1"></a>A <a href="https://vjudge.net/contest/419506#problem/A">例题1</a> • <a href="https://vjudge.net/problem/SPOJ-GSS1/origin">SPOJ GSS1</a></h3><h3 id="B-例题2-•-Gym-102770B"><a href="#B-例题2-•-Gym-102770B" class="headerlink" title="B 例题2 • Gym 102770B"></a>B <a href="https://vjudge.net/contest/419506#problem/B">例题2</a> • <a href="https://vjudge.net/problem/Gym-102770B/origin">Gym 102770B</a></h3><h3 id="C-例题3-•-POJ-2182"><a href="#C-例题3-•-POJ-2182" class="headerlink" title="C 例题3 • POJ 2182"></a>C <a href="https://vjudge.net/contest/419506#problem/C">例题3</a> • <a href="https://vjudge.net/problem/POJ-2182/origin">POJ 2182</a></h3><h3 id="D-【模板】单点修改-•-HDU-1166"><a href="#D-【模板】单点修改-•-HDU-1166" class="headerlink" title="D 【模板】单点修改 • HDU 1166"></a>D <a href="https://vjudge.net/contest/419506#problem/D">【模板】单点修改</a> • <a href="https://vjudge.net/problem/HDU-1166/origin">HDU 1166</a></h3><h3 id="E-【模板】区间修改-•-POJ-3468"><a href="#E-【模板】区间修改-•-POJ-3468" class="headerlink" title="E 【模板】区间修改 • POJ 3468"></a>E <a href="https://vjudge.net/contest/419506#problem/E">【模板】区间修改</a> • <a href="https://vjudge.net/problem/POJ-3468/origin">POJ 3468</a></h3><h3 id="F-练习题1-•-CodeForces-339D"><a href="#F-练习题1-•-CodeForces-339D" class="headerlink" title="F 练习题1 • CodeForces 339D"></a>F <a href="https://vjudge.net/contest/419506#problem/F">练习题1</a> • <a href="https://vjudge.net/problem/CodeForces-339D/origin">CodeForces 339D</a></h3><h3 id="G-练习题2-•-HDU-2795"><a href="#G-练习题2-•-HDU-2795" class="headerlink" title="G 练习题2 • HDU 2795"></a>G <a href="https://vjudge.net/contest/419506#problem/G">练习题2</a> • <a href="https://vjudge.net/problem/HDU-2795/origin">HDU 2795</a></h3><h3 id="H-练习题3-•-HDU-2852"><a href="#H-练习题3-•-HDU-2852" class="headerlink" title="H 练习题3 • HDU 2852"></a>H <a href="https://vjudge.net/contest/419506#problem/H">练习题3</a> • <a href="https://vjudge.net/problem/HDU-2852/origin">HDU 2852</a></h3>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021.1.23</title>
      <link href="2021/01/23/2021-1-23/"/>
      <url>2021/01/23/2021-1-23/</url>
      
        <content type="html"><![CDATA[<h1 id="2021-1-23"><a href="#2021-1-23" class="headerlink" title="2021.1.23"></a>2021.1.23</h1><h2 id="DFS-•-深度优先搜索"><a href="#DFS-•-深度优先搜索" class="headerlink" title="DFS • 深度优先搜索"></a>DFS • 深度优先搜索</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><blockquote><p>深度优先搜索属于图算法的一种，英文缩写为 DFS 即 Depth First Search. 其过程简要来说是对每一个可能的分支路径深入到不能再深入为止，而且每个节点只能访问一次。</p><p>——百度百科</p></blockquote><blockquote><p>在一条路上的分岔按顺序选择方向，一条路走到底再返回到最近分岔选择下一条路，这个分岔下所有路全走完后再返回到更上一个分岔走下一条路。</p></blockquote><h3 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h3><blockquote><p>深度优先遍历图的方法是，从图中某顶点v出发：</p><ol><li>访问顶点 v ；</li><li>依次从v的未被访问的邻接点出发，对图进行深度优先遍历；直至图中和v有路径相通的顶点都被访问；</li><li>若此时图中尚有顶点未被访问，则从一个未被访问的顶点出发，重新进行深度优先遍历，直到图中所有顶点均被访问过为止。</li></ol></blockquote><p><u>搜索完节点后注意是否需要回溯！</u></p><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">bool judge(int x, int y) {};//判断当前状态是否合法bool check(int x, int y) {};//判断是否为最终答案void dfs(int x, int y, int z){    if(!judge(x, y)) return;    if(check(x, y))    {        //保存答案    }    visited[x][y] = 1;//标记已搜索过此节点，防止重复搜索    /*        操作...    */    dfs(x - 1, y, z + 1);    dfs(x + 1, y, z + 1);    dfs(x, y - 1, z + 1);    dfs(x, y + 1, z + 1);    visited[x][y] = 0;//回溯}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><h4 id="剪枝"><a href="#剪枝" class="headerlink" title="剪枝"></a>剪枝</h4><p>有些求最优解的题目，可以不用完全遍历，当目前 dfs 的解已经比历史遍历得到的最优解更差时，可以停止遍历，节省一部分时间复杂度。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">bool judge(int x, int y) {};//判断当前状态是否合法bool check(int x, int y) {};//判断是否为最终答案void dfs(int x, int y, int z){    if(!judge(x, y)) return;    if(z &gt; ans) return;    if(check(x, y))    {        ans = z;        //保存答案    }    visited[x][y] = 1;//标记已搜索过此节点，防止重复搜索    /*        操作...    */    dfs(x - 1, y, z + 1);    dfs(x + 1, y, z + 1);    dfs(x, y - 1, z + 1);    dfs(x, y + 1, z + 1);    visited[x][y] = 0;//回溯}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="记忆化搜索"><a href="#记忆化搜索" class="headerlink" title="记忆化搜索"></a>记忆化搜索</h4><p>对于遍历某些确定的类型时，如果到达一个节点之后的遍历结果是可以确定的，第一遍先向下遍历得到结果，将这个结果保存，之后再遍历到此节点时直接返回已得到的结果，可以节省一部分时间复杂度。</p><p>如：<a href="https://www.luogu.com.cn/problem/P1434">洛谷 P1434 [SHOI2002]滑雪</a></p><p>题目大意：矩阵求最长下降线路长度</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int fx[5] = { 0, 0, 0, 1, -1 };int fy[5] = { 0, 1, -1, 0, 0 };int dfs(int x, int y){if (f[x][y]) return f[x][y];//记忆化搜索f[x][y] = 1;//题目中答案是有包含这个点的for (int i = 1; i &lt;= 4; i++){int xx = fx[i] + x;int yy = fy[i] + y;//四个方向if (xx &gt; 0 &amp;&amp; yy &gt; 0 &amp;&amp; xx &lt;= n &amp;&amp; yy &lt;= m &amp;&amp; a[x][y] &gt; a[xx][yy]){f[x][y] = max(f[x][y], dfs(xx, yy) + 1);}}return f[x][y];}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="BFS-•-广度优先搜索"><a href="#BFS-•-广度优先搜索" class="headerlink" title="BFS • 广度优先搜索"></a>BFS • 广度优先搜索</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><blockquote><p>从出发点一层一层向外遍历，到达终点就结束。因此，到达终点的方案一定是最优解。</p></blockquote><blockquote><p>无论有多少条路，每条路都只走一步，并记录下状态，等到所有的路都走完一步后，再从第一条路开始走第二步，直至有一条路走到终点。</p></blockquote><h3 id="基本思路-1"><a href="#基本思路-1" class="headerlink" title="基本思路"></a>基本思路</h3><blockquote><p>广度优先搜索使用队列（queue）来实现，整个过程也可以看做一个倒立的树形：</p><ol><li><p>把根节点放到队列的末尾。</p></li><li><p>每次从队列的头部取出一个元素，查看这个元素所有的下一级元素，把它们放到队列的末尾。并把这个元素记为它下一级元素的前驱。</p></li><li><p>找到所要找的元素时结束程序。</p></li><li><p>如果遍历整个树还没有找到，结束程序。</p></li></ol></blockquote><h3 id="模板-1"><a href="#模板-1" class="headerlink" title="模板"></a>模板</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int fx[5] = { 0, -1, 1, 0, 0 };int fy[5] = { 0, 0, 0, -1, 1 };//上下左右struct node{    int x, y, z;};bool check (int x, int y) {};//判断点是否能走void bfs(int x, int y, int z){    node start;start.x = x;start.y = y;start.z = 0;//start 为出发点，z 为步数    queue &lt;node&gt; q;q.push(start);//将出发点推入队列中等待处理while (!q.empty()){        node now;now = q.front();//从队列中取出首元素处理q.pop();//将该元素取出后要记得推出，否则只推入不推出，死循环t[now.x][now.y] = now.z;//这里是记录了到 [now.x][now.y] 的最短路径，也可以做其他操作for (int i = 1; i &lt;= 4; i++)//往四个方向继续遍历{            if (check (now.x + fx[i], now.y + fy[i])){node next;next.x = now.x + fx[i];next.y = now.y + fy[i];next.z = now.z + 1;vi[next.x][next.y] = 1;q.push(next);//将该点保存并推入队列中，等待前面的处理完后再走下一步}}}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><blockquote><p>对一个有向无环图 (Directed Acyclic Graph简称DAG) G进行拓扑排序，是将 G 中所有顶点排成一个线性序列，使得图中任意一对顶点 u 和 v，若边 &lt;u,v&gt;∈E(G)，则u在线性序列中出现在 v 之前。通常，这样的线性序列称为满足拓扑次序 (Topological Order) 的序列，简称拓扑序列。简单的说，由某个集合上的一个偏序得到该集合上的一个全序，这个操作称之为拓扑排序。</p><p>——百度百科</p></blockquote><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p>由 AOV 网构造拓扑序列的拓扑排序算法主要是循环执行以下两步，直到不存在入度为0的顶点为止。</p><ol><li><p>选择一个入度为 0 的顶点并输出之；</p></li><li><p>从网中删除此顶点及所有出边。</p><p>循环结束后，若输出的顶点数小于网中的顶点数，则输出“有回路”信息，否则输出的顶点序列就是一种拓扑序列。</p></li></ol><h2 id="二分图"><a href="#二分图" class="headerlink" title="二分图"></a>二分图</h2><p>待更</p><h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><h3 id="A-Find-a-way-•-HDU-2612"><a href="#A-Find-a-way-•-HDU-2612" class="headerlink" title="A Find a way • HDU 2612"></a>A <a href="https://vjudge.net/contest/419048#problem/A">Find a way</a> • <a href="https://vjudge.net/problem/HDU-2612/origin">HDU 2612</a></h3><h3 id="B-Dungeon-Master-•-POJ-2251"><a href="#B-Dungeon-Master-•-POJ-2251" class="headerlink" title="B Dungeon Master • POJ 2251"></a>B <a href="https://vjudge.net/contest/419048#problem/B">Dungeon Master</a> • <a href="https://vjudge.net/problem/POJ-2251/origin">POJ 2251</a></h3><h3 id="C-Red-and-Black-•-HDU-1312"><a href="#C-Red-and-Black-•-HDU-1312" class="headerlink" title="C Red and Black • HDU 1312"></a>C <a href="https://vjudge.net/contest/419048#problem/C">Red and Black</a> • <a href="https://vjudge.net/problem/HDU-1312/origin">HDU 1312</a></h3><h3 id="D-Counting-Sheep-•-HDU-2952"><a href="#D-Counting-Sheep-•-HDU-2952" class="headerlink" title="D Counting Sheep • HDU 2952"></a>D <a href="https://vjudge.net/contest/419048#problem/D">Counting Sheep</a> • <a href="https://vjudge.net/problem/HDU-2952/origin">HDU 2952</a></h3><h3 id="E-N皇后问题-•-HDU-2553"><a href="#E-N皇后问题-•-HDU-2553" class="headerlink" title="E N皇后问题 • HDU 2553"></a>E <a href="https://vjudge.net/contest/419048#problem/E">N皇后问题</a> • <a href="https://vjudge.net/problem/HDU-2553/origin">HDU 2553</a></h3><h3 id="F-A-Funny-Bipartite-Graph-•-计蒜客-42577"><a href="#F-A-Funny-Bipartite-Graph-•-计蒜客-42577" class="headerlink" title="F  A Funny Bipartite Graph • 计蒜客 42577"></a>F <a href="https://vjudge.net/contest/419048#problem/F"> A Funny Bipartite Graph</a> • <a href="https://vjudge.net/problem/%E8%AE%A1%E8%92%9C%E5%AE%A2-42577/origin">计蒜客 42577</a></h3><h3 id="G-wyh2000-and-pupil-•-HDU-5285"><a href="#G-wyh2000-and-pupil-•-HDU-5285" class="headerlink" title="G wyh2000 and pupil • HDU 5285"></a>G <a href="https://vjudge.net/contest/419048#problem/G">wyh2000 and pupil</a> • <a href="https://vjudge.net/problem/HDU-5285/origin">HDU 5285</a></h3><h3 id="H-Legal-or-Not-•-HDU-3342"><a href="#H-Legal-or-Not-•-HDU-3342" class="headerlink" title="H Legal or Not • HDU 3342"></a>H <a href="https://vjudge.net/contest/419048#problem/H">Legal or Not</a> • <a href="https://vjudge.net/problem/HDU-3342/origin">HDU 3342</a></h3>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> DFS </tag>
            
            <tag> BFS </tag>
            
            <tag> 拓扑排序 </tag>
            
            <tag> 二分图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021.1.22</title>
      <link href="2021/01/22/2021-1-22/"/>
      <url>2021/01/22/2021-1-22/</url>
      
        <content type="html"><![CDATA[<h1 id="2021-1-22"><a href="#2021-1-22" class="headerlink" title="2021.1.22"></a>2021.1.22</h1><h2 id="二分查找-•-Binary-Search"><a href="#二分查找-•-Binary-Search" class="headerlink" title="二分查找 • Binary Search"></a>二分查找 • Binary Search</h2><blockquote><p>二分查找也称折半查找（Binary Search），它是一种效率较高的查找方法。但是，折半查找要求线性表必须采用顺序存储结构，而且表中元素按关键字有序排列。</p><p>——百度百科</p></blockquote><ul><li><p>有序排列</p><p><code>sort (a + 1, a + n + 1, cmp);</code></p></li><li><p>时间复杂度 <strong>O(logn)</strong></p></li></ul><p>学了二分以后给我的感觉就是很多东西都可以拿来二分，以前以为只有查找可以用二分，现在知道原来很多有范围的东西，都可以用二分来逼近答案。</p><h3 id="整数二分"><a href="#整数二分" class="headerlink" title="整数二分"></a>整数二分</h3><h4 id="找-gt-s-的数中最小的"><a href="#找-gt-s-的数中最小的" class="headerlink" title="找 >= s 的数中最小的"></a>找 &gt;= s 的数中最小的</h4><ul><li><p>记录答案</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">bool check (int x){    if (a[x] &gt;= s) return 1;    else return 0;}int l = 1, r = n, ans = 0;while (l &lt;= r){    int mid = (l + r) / 2;    if (check (mid))    {        ans = mid;        r = mid - 1;    }    else l = mid + 1;}printf ("%d", a[ans]);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><ul><li><p>不记录答案 • r 逼近答案</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int l = 1, r = n;while (l &lt; r){    int mid = (l + r) / 2;    if (a[mid] &gt;= s) r = mid;    else l = mid + 1;}printf ("%d", a[r]);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>如果 a[mid] &gt;= s 成立，接下来应该向左继续查找，而此时 mid 是符合要求的，所以要保留，因此 r = mid</p></li><li><p>如果 a[mid] &gt;= s 不成立，接下来应该向右继续查找，而此时 mid 是不符合要求的，所以要舍弃，因此 l = mid + 1</p></li><li><p>输出的数一定是要符合要求的，每次查找 r = mid，r一定是符合要求，而 l 不一定，所以输出 r</p></li></ul><h4 id="找-lt-s-的数中最大的"><a href="#找-lt-s-的数中最大的" class="headerlink" title="找 < s 的数中最大的"></a>找 &lt; s 的数中最大的</h4><ul><li><p>记录答案</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">bool check (int x){    if (a[x] &lt; s) return 1;    else return 0;}int l = 1, r = n, ans = 0;while (l &lt;= r){    int mid = (l + r) / 2;    if (check (mid))    {        ans = mid;        l = mid + 1;    }    else r = mid - 1;}printf ("%d", a[ans]);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><ul><li><p>不记录答案 • l 逼近答案</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int l = 1, r = n;while (l &lt; r){    int mid = (l + r + 1) / 2;    if (a[i] &lt; s) l = mid;    else r = mid - 1;}printf ("%d", a[l]);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>如果 a[mid] &lt; s 成立，接下来应该向右继续查找，而此时 mid 是符合答案的，所以要保留，因此 l = mid</p></li><li><p>如果 a[mid] &lt; s 不成立，接下来应该向左继续查找，而此时 mid 是不符合答案的，所以要舍弃，因此 r = mid - 1</p></li><li><p>输出的数一定是要符合要求的，每次查找 l = mid，l一定是符合要求，而 r 不一定，所以输出 l</p></li></ul><h3 id="浮点二分"><a href="#浮点二分" class="headerlink" title="浮点二分"></a>浮点二分</h3><p>浮点二分只能用记录答案方法，而且要设置一个范围使得查找能退出循环</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">const double eps = 1e-8;double l = 0, r = n;while (r - l &gt; eps){    double mid = (l + r) / 2;    if (check (mid))    {        ans = mid;        r = mid - 1;    }    else l = r + 1;}printf ("%d", ans);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><h3 id="A-Can-you-solve-this-equation-•-HDU-2199"><a href="#A-Can-you-solve-this-equation-•-HDU-2199" class="headerlink" title="A Can you solve this equation? • HDU 2199"></a>A <a href="https://vjudge.net/contest/418909#problem/A">Can you solve this equation?</a> • <a href="http://acm.hdu.edu.cn/showproblem.php?pid=2199">HDU 2199</a></h3><h3 id="B-Dating-with-girls-1-•-HDU-2578"><a href="#B-Dating-with-girls-1-•-HDU-2578" class="headerlink" title="B Dating with girls(1) • HDU 2578"></a>B <a href="https://vjudge.net/contest/418909#problem/B">Dating with girls(1)</a> • <a href="http://acm.hdu.edu.cn/showproblem.php?pid=2578">HDU 2578</a></h3><h3 id="C-Aggressive-cows-•-POJ-2456"><a href="#C-Aggressive-cows-•-POJ-2456" class="headerlink" title="C Aggressive cows • POJ 2456"></a>C <a href="https://vjudge.net/contest/418909#problem/C">Aggressive cows</a> • <a href="http://poj.org/problem?id=2456">POJ 2456</a></h3><h3 id="D-Pie-•-POJ-3122"><a href="#D-Pie-•-POJ-3122" class="headerlink" title="D  Pie • POJ 3122"></a>D <a href="https://vjudge.net/contest/418909#problem/D"> Pie</a> • <a href="http://poj.org/problem?id=3122">POJ 3122</a></h3><h3 id="E-River-Hopscotch-•-POJ-3258"><a href="#E-River-Hopscotch-•-POJ-3258" class="headerlink" title="E River Hopscotch • POJ 3258"></a>E <a href="https://vjudge.net/contest/418909#problem/E">River Hopscotch</a> • <a href="http://poj.org/problem?id=3258">POJ 3258</a></h3><h3 id="F-4-Values-whose-Sum-is-0-•-POJ-2785"><a href="#F-4-Values-whose-Sum-is-0-•-POJ-2785" class="headerlink" title="F 4 Values whose Sum is 0 • POJ 2785"></a>F <a href="https://vjudge.net/contest/418909#problem/F">4 Values whose Sum is 0</a> • <a href="http://poj.org/problem?id=2785">POJ 2785</a></h3><h3 id="G-Defuse-the-Bombs-•-Gym-102822D"><a href="#G-Defuse-the-Bombs-•-Gym-102822D" class="headerlink" title="G Defuse the Bombs • Gym 102822D"></a>G <a href="https://vjudge.net/contest/418909#problem/G">Defuse the Bombs</a> • <a href="https://vjudge.net/problem/Gym-102822D/origin">Gym 102822D</a></h3>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 二分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021.1.21</title>
      <link href="2021/01/21/2021-1-21/"/>
      <url>2021/01/21/2021-1-21/</url>
      
        <content type="html"><![CDATA[<h1 id="2021-1-21"><a href="#2021-1-21" class="headerlink" title="2021.1.21"></a>2021.1.21</h1><h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><blockquote><p>并查集是一种树型的数据结构，用于处理一些不相交集合（disjoint sets）的合并及查询问题。常常在使用中以森林来表示。</p><p>——百度百科</p></blockquote><h3 id="主要操作"><a href="#主要操作" class="headerlink" title="主要操作"></a>主要操作</h3><ul><li><p>初始化</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int f[N];void ini(int x){for (int i = 1; i &lt;= x; i++)f[i] = i;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使所有元素都指向自己，将自己作为父节点</p></li><li><p>查找</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int find(int x){    if (x == f[x]) return x;    return find(x);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>合并</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void merge(int x, int y){    f[find(x)] = find(y);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><h4 id="路径压缩"><a href="#路径压缩" class="headerlink" title="路径压缩"></a>路径压缩</h4><blockquote><p>每次查找的时候，如果路径较长，则修改信息，以便下次查找的时候速度更快。</p><p>第一步，找到根结点。</p><p>第二步，修改查找路径上的所有节点，将它们都指向根结点。</p><p>——百度百科</p></blockquote><ul><li><p>查找</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int find(int x){    if (x == f[x]) return x;    f[x] = find (f[x]);    return f[x];}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>或者写成这样：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int find(int x){    if (x != f[x]) f[x] = find (f[x]);    return f[x];}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>再用二元运算符：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int find(int x) { return x == f[x] ? x : (f[x] = find(f[x])); }<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><del>这么写可以让自己看起来更加大佬</del></p></li></ul><h4 id="按秩合并"><a href="#按秩合并" class="headerlink" title="按秩合并"></a>按秩合并</h4><p>将深度小的树合并到深度大的树上</p><ul><li><p>初始化</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void ini(int x){for (int i = 1; i &lt;= x; i++){f[i] = i;rank[i] = 1;//深度都初始化为1}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>合并</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void merge(int x, int y){int a = find(x), b = find(y);//先找到两个根节点if (rank[a] &lt;= rank[b]) f[a] = b;else fa[b] = a;if (rank[a] == rank[b] &amp;&amp; a != b) rank[b]++;//如果深度相同且根节点不同，则新的根节点的深度+1}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因为是小的直接连接到大的根节点，所以合并时小的那一支的深度+1，只有当两者深度相同时才会产生更大的深度</p></li></ul><h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><h4 id="种族并查集"><a href="#种族并查集" class="headerlink" title="种族并查集"></a>种族并查集</h4><p>通过多个并查集将不同的元素归类，并维护相互之间的关系</p><p>例题：<a href="https://www.luogu.com.cn/problem/P2024">洛谷 P2024 食物链</a></p><p>​    用三个并查集分别表示自己、自己的猎物（自己吃的）以及自己的天敌（吃自己的），同时维护三个并查集，通过他们三者的关系判断当前读入数据是否为真</p><h4 id="带权并查集"><a href="#带权并查集" class="headerlink" title="带权并查集"></a>带权并查集</h4><p><u>基于路径压缩</u>，每个节点都记录的是与根节点之间的权值</p><ul><li><p>查找</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int find(int x){if (x != f[x]){int t = f[x];f[x] = find(f[x]);value[x] += value[t];}return f[x];}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>合并</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void merge(int x, int y){    int px = find(x);    int py = find(y);    if (px != py)    {        f[px] = py;        value[px] = -value[x] + value[y] + s;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/OwlllOvO/Hexo-image/20210121213127.PNG"></p></li></ul><h3 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h3><h4 id="A-Ubiquitous-Religions-•-POJ-2524"><a href="#A-Ubiquitous-Religions-•-POJ-2524" class="headerlink" title="A Ubiquitous Religions • POJ 2524"></a>A <a href="https://vjudge.net/contest/418701#problem/A">Ubiquitous Religions</a> • <a href="http://poj.org/problem?id=252">POJ 2524</a></h4><h4 id="B-食物链-•-洛谷-P2024"><a href="#B-食物链-•-洛谷-P2024" class="headerlink" title="B 食物链 • 洛谷 P2024"></a>B <a href="https://vjudge.net/contest/418701#problem/B">食物链</a> • <a href="https://www.luogu.com.cn/problem/P2024">洛谷 P2024</a></h4><h4 id="C-How-Many-Tables-•-HDU-1213"><a href="#C-How-Many-Tables-•-HDU-1213" class="headerlink" title="C How Many Tables • HDU 1213"></a>C <a href="https://vjudge.net/contest/418701#problem/C">How Many Tables</a> • <a href="http://acm.hdu.edu.cn/showproblem.php?pid=1213">HDU 1213</a></h4><h4 id="D-畅通工程-•-HDU-1232"><a href="#D-畅通工程-•-HDU-1232" class="headerlink" title="D 畅通工程 • HDU 1232"></a>D <a href="https://vjudge.net/contest/418701#problem/D">畅通工程</a> • <a href="https://vjudge.net/problem/HDU-1232/origin">HDU 1232</a></h4><h4 id="E-人见人爱A-B-•-HDU-2035"><a href="#E-人见人爱A-B-•-HDU-2035" class="headerlink" title="E 人见人爱A^B •  HDU 2035"></a>E <a href="https://vjudge.net/contest/418701#problem/E">人见人爱A^B</a> • <a href="http://acm.hdu.edu.cn/showproblem.php?pid=2035"> HDU 2035</a></h4><h4 id="F-How-Many-Answers-Are-Wrong-•-HDU-3038"><a href="#F-How-Many-Answers-Are-Wrong-•-HDU-3038" class="headerlink" title="F How Many Answers Are Wrong •  HDU 3038"></a>F <a href="https://vjudge.net/contest/418701#problem/F">How Many Answers Are Wrong</a> • <a href="http://acm.hdu.edu.cn/showproblem.php?pid=3038"> HDU 3038</a></h4>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021.1.20</title>
      <link href="2021/01/20/2021-1-20/"/>
      <url>2021/01/20/2021-1-20/</url>
      
        <content type="html"><![CDATA[<h1 id="2021-1-20"><a href="#2021-1-20" class="headerlink" title="2021.1.20"></a>2021.1.20</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="常用-OJ"><a href="#常用-OJ" class="headerlink" title="常用 OJ"></a>常用 OJ</h3><ul><li><p><a href="https://vjudge.net/">Vjudge</a></p></li><li><p><a href="http://www.nowcoder.com/">nowcoder</a></p></li><li><p><a href="https://pintia.cn/">PTA</a></p></li></ul><h3 id="常用语言-C"><a href="#常用语言-C" class="headerlink" title="常用语言 - C++"></a>常用语言 - C++</h3><p><del>终于用回 C++ 了，上程序设计基础转 C 好累</del></p><p>万能头文件 <code>#include&lt;bits/stdc++.h&gt;</code></p><p>等于以下头文件：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;algorithm&gt;#include &lt;bitset&gt;#include &lt;complex&gt;#include &lt;deque&gt;#include &lt;exception&gt;#include &lt;fstream&gt;#include &lt;functional&gt;#include &lt;iomanip&gt;#include &lt;ios&gt;#include &lt;iosfwd&gt;#include &lt;iostream&gt;#include &lt;istream&gt;#include &lt;iterator&gt;#include &lt;limits&gt;#include &lt;list&gt;#include &lt;locale&gt;#include &lt;map&gt;#include &lt;memory&gt;#include &lt;new&gt;#include &lt;numeric&gt;#include &lt;ostream&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;sstream&gt;#include &lt;stack&gt;#include &lt;stdexcept&gt;#include &lt;streambuf&gt;#include &lt;string&gt;#include &lt;typeinfo&gt;#include &lt;utility&gt;#include &lt;valarray&gt;#include &lt;vector&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>(Visual Studio 不自带万能头文件)</p><h3 id="时间（空间）复杂度"><a href="#时间（空间）复杂度" class="headerlink" title="时间（空间）复杂度"></a>时间（空间）复杂度</h3><p><del>dddd懂的都懂</del></p><h2 id="C-STL"><a href="#C-STL" class="headerlink" title="C++: STL"></a>C++: STL</h2><h3 id="string-•-字符串"><a href="#string-•-字符串" class="headerlink" title="string • 字符串"></a>string • 字符串</h3><h4 id="头文件-include-lt-string-gt"><a href="#头文件-include-lt-string-gt" class="headerlink" title="头文件 : #include<string>"></a>头文件 : <code>#include&lt;string&gt;</code></h4><h4 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h4><ul><li>赋初值</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">string s1 = "1234";string s2;s2 = "1234";<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><p>清除</p><p><code>s1.clear();</code></p></li><li><p>求长度</p><p><code>l = s1.length();</code></p></li><li><p>在尾部插入字符</p><p><code>s1.push_back('x');</code></p></li><li><p>在尾部插入字符串</p><p><code>s1.append(s2);</code></p></li><li><p>从s1中找到字符 ‘x’ 的位置</p><p><code>pos = s1.find('x');</code></p></li><li><p>删除</p><p><code>s1.erase()</code></p></li></ul><h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><h4 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h4><p>​    <code>    vector&lt;int&gt;v1;</code></p><p>​    <code>vector&lt;string&gt;v2("1234");</code></p><p>​    <code>vecotr&lt;int&gt;v3(5,2);</code></p><p>​    <code>vector&lt;int&gt;v4(v3);</code></p><h4 id="常用函数-1"><a href="#常用函数-1" class="headerlink" title="常用函数"></a>常用函数</h4><ul><li><p>在数组的最后添加一个数据</p><p><code>v1.push_back();</code></p></li><li><p>去掉数组的最后一个数据</p><p><code>v1.pop_back();</code></p></li><li><p>得到数组头的引用</p><p><code>v1.front();</code></p></li><li><p>得到数组的最后一个单元的引用</p><p><code>v1.back();</code></p></li><li><p>获取 vector 大小</p><p><code>v1.size();</code></p></li></ul><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><ul><li>随机访问 <strong>O(1)</strong></li><li>删除 <strong>O(n)</strong></li></ul><h3 id="queue-•-FIFO"><a href="#queue-•-FIFO" class="headerlink" title="queue • FIFO"></a>queue • FIFO</h3><h4 id="构造-1"><a href="#构造-1" class="headerlink" title="构造"></a>构造</h4><p>​    <code>queue&lt;int&gt; q;</code></p><h4 id="常用函数-2"><a href="#常用函数-2" class="headerlink" title="常用函数"></a>常用函数</h4><ul><li><p>入队</p><p><code>q.push();</code></p></li><li><p>出队</p><p><code>q.pop();</code></p></li><li><p>首位</p><p><code>q.front();</code></p></li><li><p>末位</p><p><code>q.back();</code></p></li><li><p>大小</p><p><code>q.size();</code></p></li><li><p>判断是否为空</p><p><code>q.empty();</code></p></li></ul><h3 id="stack-•-FILO"><a href="#stack-•-FILO" class="headerlink" title="stack • FILO"></a>stack • FILO</h3><h4 id="构造-2"><a href="#构造-2" class="headerlink" title="构造"></a>构造</h4><p>​    <code>stack&lt;int&gt; s;</code></p><h4 id="常用函数-3"><a href="#常用函数-3" class="headerlink" title="常用函数"></a>常用函数</h4><ul><li><p>入队</p><p><code>s.push();</code></p></li><li><p>出队</p><p><code>s.pop();</code></p></li><li><p>首位</p><p><code>s.top();</code></p></li><li><p>大小</p><p><code>s.size();</code></p></li><li><p>判断是否为空</p><p><code>s.empty();</code></p></li></ul><h3 id="set-•-集合"><a href="#set-•-集合" class="headerlink" title="set • 集合"></a>set • 集合</h3><h4 id="构造-3"><a href="#构造-3" class="headerlink" title="构造"></a>构造</h4><p>​    <code>set&lt;int&gt;s;</code></p><h4 id="常用函数-4"><a href="#常用函数-4" class="headerlink" title="常用函数"></a>常用函数</h4><ul><li><p>插入</p><p><code>s.insert();</code></p></li><li><p>清除</p><p><code>s.erase();</code></p></li><li><p>查找</p><p><code>s.find([int]);</code></p></li><li><p>大小</p><p><code>[int] = s.size();</code></p></li><li><p>清空</p><p><code>s.clear();</code></p></li><li><p>值元素个数</p><p><code>s.count([int]);</code></p></li><li><p>首元</p><p><code>s.begin();</code></p></li><li><p>末元</p><p><code>s.end();</code></p></li><li><p>是否为空</p><p><code>s.empty();</code></p></li></ul><h4 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><ul><li>查询 <strong>O(logn)</strong></li><li>插入 <strong>O(logn)</strong></li><li>删除 <strong>O(logn)</strong></li></ul><h3 id="map-•-key-value"><a href="#map-•-key-value" class="headerlink" title="map • key - value"></a>map • key - value</h3><h4 id="构造-4"><a href="#构造-4" class="headerlink" title="构造"></a>构造</h4><p>​    1.<code>map&lt;int,int&gt;mp;</code></p><p>​    2.<code>map&lt;string,int&gt;mp;</code></p><h4 id="常用函数-5"><a href="#常用函数-5" class="headerlink" title="常用函数"></a>常用函数</h4><ul><li><p>访问</p><p>1.<code>mp[[int]] = [int];</code></p><p>2.<code>mp[[string]] = [int];</code></p></li></ul><h4 id="时间复杂度-2"><a href="#时间复杂度-2" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><ul><li>插入 <strong>O(logn)</strong></li><li>删除 <strong>O(logn)</strong></li></ul><h3 id="list-•-双向链表"><a href="#list-•-双向链表" class="headerlink" title="list • 双向链表"></a>list • 双向链表</h3><h4 id="构造-5"><a href="#构造-5" class="headerlink" title="构造"></a>构造</h4><p>​    <code>list&lt;int&gt;li;</code></p><h4 id="常用函数-6"><a href="#常用函数-6" class="headerlink" title="常用函数"></a>常用函数</h4><ul><li><p>加到末位</p><p><code>li.push_back();</code></p></li><li><p>加到首位</p><p><code>li.push_front();</code></p></li><li><p>去掉末位</p><p><code>li.pop_back();</code></p></li><li><p>去掉首位</p><p><code>li.pop_front();</code></p></li><li><p>插入</p><p><code>li.insert();</code></p></li><li><p>删除</p><p><code>li.erase();</code></p></li></ul><h4 id="时间复杂度-3"><a href="#时间复杂度-3" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><ul><li>随机访问 <strong>×</strong></li><li>插入 <strong>O(1)</strong></li><li>删除 <strong>O(1)</strong></li></ul><h3 id="sort-•-快速排序"><a href="#sort-•-快速排序" class="headerlink" title="sort • 快速排序"></a>sort • 快速排序</h3><p><del>用习惯 sort 后受够了 qsort 的折磨，现在终于回来了</del></p><p><del>qsort 到现在都还没学会，还好期末开卷照着书打</del></p><h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><h3 id="A-Rails-•-POJ-1363"><a href="#A-Rails-•-POJ-1363" class="headerlink" title="A Rails • POJ 1363"></a>A <a href="https://vjudge.net/contest/418487#problem/A">Rails</a> • <a href="https://vjudge.net/problem/POJ-1363/origin">POJ 1363</a></h3><h3 id="B-表达式括号匹配-•-计蒜客-T1655"><a href="#B-表达式括号匹配-•-计蒜客-T1655" class="headerlink" title="B 表达式括号匹配 • 计蒜客 T1655"></a>B <a href="https://vjudge.net/contest/418487#problem/B">表达式括号匹配</a> • <a href="https://vjudge.net/problem/%E8%AE%A1%E8%92%9C%E5%AE%A2-T1655/origin">计蒜客 T1655</a></h3><h3 id="C-Let-the-Balloon-Rise-•-HDU-1004"><a href="#C-Let-the-Balloon-Rise-•-HDU-1004" class="headerlink" title="C  Let the Balloon Rise  • HDU 1004"></a>C <a href="https://vjudge.net/contest/418487#problem/C"> Let the Balloon Rise</a>  • <a href="https://vjudge.net/problem/HDU-1004/origin">HDU 1004</a></h3><h3 id="D-ACboy-needs-your-help-again-•-HDU-1702"><a href="#D-ACboy-needs-your-help-again-•-HDU-1702" class="headerlink" title="D  ACboy needs your help again! • HDU 1702"></a>D <a href="https://vjudge.net/contest/418487#problem/D"> ACboy needs your help again!</a> • <a href="https://vjudge.net/problem/HDU-1702/origin">HDU 1702</a></h3><h3 id="E-排名-•-HDU-1236"><a href="#E-排名-•-HDU-1236" class="headerlink" title="E 排名 • HDU 1236"></a>E <a href="https://vjudge.net/contest/418487#problem/E">排名</a> • <a href="https://vjudge.net/problem/HDU-1236/origin">HDU 1236</a></h3><h3 id="F-人见人爱A-B-•-HDU-2034"><a href="#F-人见人爱A-B-•-HDU-2034" class="headerlink" title="F  人见人爱A-B • HDU 2034"></a>F <a href="https://vjudge.net/contest/418487#problem/F"> 人见人爱A-B</a> • <a href="https://vjudge.net/problem/HDU-2034/origin">HDU 2034</a></h3><h3 id="G-水果-•-HDU-1263"><a href="#G-水果-•-HDU-1263" class="headerlink" title="G 水果 • HDU 1263"></a>G <a href="https://vjudge.net/contest/418487#problem/G">水果</a> • <a href="https://vjudge.net/problem/HDU-1263/origin">HDU 1263</a></h3><h3 id="H-看病要排队-•-HDU-1873"><a href="#H-看病要排队-•-HDU-1873" class="headerlink" title="H 看病要排队 • HDU 1873"></a>H <a href="https://vjudge.net/contest/418487#problem/H">看病要排队</a> • <a href="https://vjudge.net/problem/HDU-1873/origin">HDU 1873</a></h3>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mouseline • 鼠标吸附线条效果</title>
      <link href="2021/01/20/mouseline-shu-biao-xi-fu-xian-tiao-xiao-guo/"/>
      <url>2021/01/20/mouseline-shu-biao-xi-fu-xian-tiao-xiao-guo/</url>
      
        <content type="html"><![CDATA[<p>将以下 JavaScript 代码粘贴到网页的页脚 HTML 中即可实现。</p><p>对于 matery 主题来说，放置在 <code>matery\layout\_partial\footer.ejs</code> 文件末尾即可。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token operator">&lt;</span>script<span class="token operator">&gt;</span><span class="token operator">!</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">function</span> <span class="token function">n</span><span class="token punctuation">(</span><span class="token parameter">n<span class="token punctuation">,</span>e<span class="token punctuation">,</span>t</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span> n<span class="token punctuation">.</span><span class="token function">getAttribute</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token operator">||</span>t<span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">e</span><span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span> document<span class="token punctuation">.</span><span class="token function">getElementsByTagName</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">t</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">var</span> t<span class="token operator">=</span><span class="token function">e</span><span class="token punctuation">(</span><span class="token string">"script"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>o<span class="token operator">=</span>t<span class="token punctuation">.</span>length<span class="token punctuation">,</span>i<span class="token operator">=</span>t<span class="token punctuation">[</span>o<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">return</span><span class="token punctuation">{</span>l<span class="token operator">:</span>o<span class="token punctuation">,</span>z<span class="token operator">:</span><span class="token function">n</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span><span class="token string">"zIndex"</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>o<span class="token operator">:</span><span class="token function">n</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span><span class="token string">"opacity"</span><span class="token punctuation">,</span><span class="token number">.5</span><span class="token punctuation">)</span><span class="token punctuation">,</span>c<span class="token operator">:</span><span class="token function">n</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span><span class="token string">"color"</span><span class="token punctuation">,</span><span class="token string">"0,0,0"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>n<span class="token operator">:</span><span class="token function">n</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span><span class="token string">"count"</span><span class="token punctuation">,</span><span class="token number">99</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">o</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>a<span class="token operator">=</span>m<span class="token punctuation">.</span>width<span class="token operator">=</span>window<span class="token punctuation">.</span>innerWidth<span class="token operator">||</span>document<span class="token punctuation">.</span>documentElement<span class="token punctuation">.</span>clientWidth<span class="token operator">||</span>document<span class="token punctuation">.</span>body<span class="token punctuation">.</span>clientWidth<span class="token punctuation">,</span>c<span class="token operator">=</span>m<span class="token punctuation">.</span>height<span class="token operator">=</span>window<span class="token punctuation">.</span>innerHeight<span class="token operator">||</span>document<span class="token punctuation">.</span>documentElement<span class="token punctuation">.</span>clientHeight<span class="token operator">||</span>document<span class="token punctuation">.</span>body<span class="token punctuation">.</span>clientHeight<span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">i</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>r<span class="token punctuation">.</span><span class="token function">clearRect</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>a<span class="token punctuation">,</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> n<span class="token punctuation">,</span>e<span class="token punctuation">,</span>t<span class="token punctuation">,</span>o<span class="token punctuation">,</span>m<span class="token punctuation">,</span>l<span class="token punctuation">;</span>s<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">i<span class="token punctuation">,</span>x</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token punctuation">.</span>x<span class="token operator">+=</span>i<span class="token punctuation">.</span>xa<span class="token punctuation">,</span>i<span class="token punctuation">.</span>y<span class="token operator">+=</span>i<span class="token punctuation">.</span>ya<span class="token punctuation">,</span>i<span class="token punctuation">.</span>xa<span class="token operator">*=</span>i<span class="token punctuation">.</span>x<span class="token operator">&gt;</span>a<span class="token operator">||</span>i<span class="token punctuation">.</span>x<span class="token operator">&lt;</span><span class="token number">0</span><span class="token operator">?</span><span class="token operator">-</span><span class="token number">1</span><span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">,</span>i<span class="token punctuation">.</span>ya<span class="token operator">*=</span>i<span class="token punctuation">.</span>y<span class="token operator">&gt;</span>c<span class="token operator">||</span>i<span class="token punctuation">.</span>y<span class="token operator">&lt;</span><span class="token number">0</span><span class="token operator">?</span><span class="token operator">-</span><span class="token number">1</span><span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">,</span>r<span class="token punctuation">.</span><span class="token function">fillRect</span><span class="token punctuation">(</span>i<span class="token punctuation">.</span>x<span class="token operator">-</span><span class="token number">.5</span><span class="token punctuation">,</span>i<span class="token punctuation">.</span>y<span class="token operator">-</span><span class="token number">.5</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>e<span class="token operator">=</span>x<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>e<span class="token operator">&lt;</span>u<span class="token punctuation">.</span>length<span class="token punctuation">;</span>e<span class="token operator">++</span><span class="token punctuation">)</span>n<span class="token operator">=</span>u<span class="token punctuation">[</span>e<span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">null</span><span class="token operator">!==</span>n<span class="token punctuation">.</span>x<span class="token operator">&amp;&amp;</span><span class="token keyword">null</span><span class="token operator">!==</span>n<span class="token punctuation">.</span>y<span class="token operator">&amp;&amp;</span><span class="token punctuation">(</span>o<span class="token operator">=</span>i<span class="token punctuation">.</span>x<span class="token operator">-</span>n<span class="token punctuation">.</span>x<span class="token punctuation">,</span>m<span class="token operator">=</span>i<span class="token punctuation">.</span>y<span class="token operator">-</span>n<span class="token punctuation">.</span>y<span class="token punctuation">,</span>l<span class="token operator">=</span>o<span class="token operator">*</span>o<span class="token operator">+</span>m<span class="token operator">*</span>m<span class="token punctuation">,</span>l<span class="token operator">&lt;</span>n<span class="token punctuation">.</span>max<span class="token operator">&amp;&amp;</span><span class="token punctuation">(</span>n<span class="token operator">===</span>y<span class="token operator">&amp;&amp;</span>l<span class="token operator">&gt;=</span>n<span class="token punctuation">.</span>max<span class="token operator">/</span><span class="token number">2</span><span class="token operator">&amp;&amp;</span><span class="token punctuation">(</span>i<span class="token punctuation">.</span>x<span class="token operator">-=</span><span class="token number">.03</span><span class="token operator">*</span>o<span class="token punctuation">,</span>i<span class="token punctuation">.</span>y<span class="token operator">-=</span><span class="token number">.03</span><span class="token operator">*</span>m<span class="token punctuation">)</span><span class="token punctuation">,</span>t<span class="token operator">=</span><span class="token punctuation">(</span>n<span class="token punctuation">.</span>max<span class="token operator">-</span>l<span class="token punctuation">)</span><span class="token operator">/</span>n<span class="token punctuation">.</span>max<span class="token punctuation">,</span>r<span class="token punctuation">.</span><span class="token function">beginPath</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>r<span class="token punctuation">.</span>lineWidth<span class="token operator">=</span>t<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">,</span>r<span class="token punctuation">.</span>strokeStyle<span class="token operator">=</span><span class="token string">"rgba("</span><span class="token operator">+</span>d<span class="token punctuation">.</span>c<span class="token operator">+</span><span class="token string">","</span><span class="token operator">+</span><span class="token punctuation">(</span>t<span class="token operator">+</span><span class="token number">.2</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">")"</span><span class="token punctuation">,</span>r<span class="token punctuation">.</span><span class="token function">moveTo</span><span class="token punctuation">(</span>i<span class="token punctuation">.</span>x<span class="token punctuation">,</span>i<span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">,</span>r<span class="token punctuation">.</span><span class="token function">lineTo</span><span class="token punctuation">(</span>n<span class="token punctuation">.</span>x<span class="token punctuation">,</span>n<span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">,</span>r<span class="token punctuation">.</span><span class="token function">stroke</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">x</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">var</span> a<span class="token punctuation">,</span>c<span class="token punctuation">,</span>u<span class="token punctuation">,</span>m<span class="token operator">=</span>document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">"canvas"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>d<span class="token operator">=</span><span class="token function">t</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>l<span class="token operator">=</span><span class="token string">"c_n"</span><span class="token operator">+</span>d<span class="token punctuation">.</span>l<span class="token punctuation">,</span>r<span class="token operator">=</span>m<span class="token punctuation">.</span><span class="token function">getContext</span><span class="token punctuation">(</span><span class="token string">"2d"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>x<span class="token operator">=</span>window<span class="token punctuation">.</span>requestAnimationFrame<span class="token operator">||</span>window<span class="token punctuation">.</span>webkitRequestAnimationFrame<span class="token operator">||</span>window<span class="token punctuation">.</span>mozRequestAnimationFrame<span class="token operator">||</span>window<span class="token punctuation">.</span>oRequestAnimationFrame<span class="token operator">||</span>window<span class="token punctuation">.</span>msRequestAnimationFrame<span class="token operator">||</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span><span class="token punctuation">{</span>window<span class="token punctuation">.</span><span class="token function">setTimeout</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span><span class="token number">1e3</span><span class="token operator">/</span><span class="token number">45</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">,</span>w<span class="token operator">=</span>Math<span class="token punctuation">.</span>random<span class="token punctuation">,</span>y<span class="token operator">=</span><span class="token punctuation">{</span>x<span class="token operator">:</span><span class="token keyword">null</span><span class="token punctuation">,</span>y<span class="token operator">:</span><span class="token keyword">null</span><span class="token punctuation">,</span>max<span class="token operator">:</span><span class="token number">2e4</span><span class="token punctuation">}</span><span class="token punctuation">;</span>m<span class="token punctuation">.</span>id<span class="token operator">=</span>l<span class="token punctuation">,</span>m<span class="token punctuation">.</span>style<span class="token punctuation">.</span>cssText<span class="token operator">=</span><span class="token string">"position:fixed;top:0;left:0;z-index:"</span><span class="token operator">+</span>d<span class="token punctuation">.</span>z<span class="token operator">+</span><span class="token string">";opacity:"</span><span class="token operator">+</span>d<span class="token punctuation">.</span>o<span class="token punctuation">,</span><span class="token function">e</span><span class="token punctuation">(</span><span class="token string">"body"</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">o</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>window<span class="token punctuation">.</span>onresize<span class="token operator">=</span>o<span class="token punctuation">,</span>window<span class="token punctuation">.</span><span class="token function-variable function">onmousemove</span><span class="token operator">=</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span><span class="token punctuation">{</span>n<span class="token operator">=</span>n<span class="token operator">||</span>window<span class="token punctuation">.</span>event<span class="token punctuation">,</span>y<span class="token punctuation">.</span>x<span class="token operator">=</span>n<span class="token punctuation">.</span>clientX<span class="token punctuation">,</span>y<span class="token punctuation">.</span>y<span class="token operator">=</span>n<span class="token punctuation">.</span>clientY<span class="token punctuation">}</span><span class="token punctuation">,</span>window<span class="token punctuation">.</span><span class="token function-variable function">onmouseout</span><span class="token operator">=</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>y<span class="token punctuation">.</span>x<span class="token operator">=</span><span class="token keyword">null</span><span class="token punctuation">,</span>y<span class="token punctuation">.</span>y<span class="token operator">=</span><span class="token keyword">null</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> s<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>f<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>d<span class="token punctuation">.</span>n<span class="token operator">&gt;</span>f<span class="token punctuation">;</span>f<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">var</span> h<span class="token operator">=</span><span class="token function">w</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">*</span>a<span class="token punctuation">,</span>g<span class="token operator">=</span><span class="token function">w</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">*</span>c<span class="token punctuation">,</span>v<span class="token operator">=</span><span class="token number">2</span><span class="token operator">*</span><span class="token function">w</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>p<span class="token operator">=</span><span class="token number">2</span><span class="token operator">*</span><span class="token function">w</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>s<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span>x<span class="token operator">:</span>h<span class="token punctuation">,</span>y<span class="token operator">:</span>g<span class="token punctuation">,</span>xa<span class="token operator">:</span>v<span class="token punctuation">,</span>ya<span class="token operator">:</span>p<span class="token punctuation">,</span>max<span class="token operator">:</span><span class="token number">6e3</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span>u<span class="token operator">=</span>s<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">i</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Creating my blog</title>
      <link href="2021/01/20/creating-my-blog/"/>
      <url>2021/01/20/creating-my-blog/</url>
      
        <content type="html"><![CDATA[<h1 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h1><h2 id="为什么选择-Hexo"><a href="#为什么选择-Hexo" class="headerlink" title="为什么选择 Hexo"></a>为什么选择 Hexo</h2><p>以前第一次建站的时候因为什么都不知道，就跟着一个教程做了 Wordpress 网站。Wordpress 的优点很明显——非常的方便。不仅建站的时候直接选择 Wordpress 就完成了，之后再在控制台维护网站就行。但之后因为上学，就没再去维护，服务器也没有续，网站就这么没有了..</p><p>这次 ACM 寒假训练，要求我们创建自己的博客，我想着自己都已经创建过自己的网站，就不想用 CSDN、博客园之类的博客，于是又准备重新搭建网站。这时候我了解到了 Hexo，这是一个静态网站，把文件都放在 Github 上，由 Github 托管。这是 Hexo 的一大优点，这样一来不仅不收费，而且只要 Github 还在，网站就不会消失。但这不是我选择 Hexo 的原因。我选择 Hexo 的主要原因还是看到很多非常精美的博客都是用的 Hexo，而 Wordpress 的网站实在找不到好看的主题，于是我也想搭建 Hexo 网站。</p><p>一开始用 Hexo 觉得很麻烦，什么东西都是在文件里修改参数，对网站的操作都要用命令执行，不像 Wordpress 有后台可以非常方便、直观地维护网站。但是用久了之后，学会了之后发现，Hexo 这样才更加方便。因为所有文件都在本地，网站的任何属性都写在文件里面了，想要修改什么直接在文件里修改，更加的灵活，这也是 Hexo 能做得更精美，更加个性化的原因。</p><h2 id="Hexo-建站过程"><a href="#Hexo-建站过程" class="headerlink" title="Hexo 建站过程"></a>Hexo 建站过程</h2><p>写这些不仅是记录我建站的整个过程，还详细地记录我对网站的操作和修改，以后万一需要重做网站，也可以帮助自己回忆 XD</p><h3 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h3><ul><li><p>macOS 切换 Root 用户</p><ul><li>终端输入指令：<code>sudo su</code></li><li>输入用户密码</li></ul></li><li><p>安装 Node.js</p><ul><li>访问网站 <a href="https://nodejs.org/en/">Node.js</a> 下载最新版本</li><li>安装</li><li>安装完成后即可在终端（cmd）输入指令：<ul><li><code>node -v </code>：查看已安装的 Node 版本，查看是否安装成功</li><li><code>npm -v</code>：查看已安装的 npm 版本，查看是否安装成功</li></ul></li></ul></li><li><p>安装淘宝 cnpm 管理器（加速）</p><ul><li><code>npm install -g cnpm --registry=http://registry.npm.taobao.org</code></li><li>自动安装</li><li><code>cnpm -v</code>：查看已安装的 cnpm 版本，查看是否安装成功</li></ul></li></ul><h3 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h3><ul><li><p>安装 Hexo 框架</p><ul><li><code>cnpm install -g hexo-cli</code></li><li>自动安装</li><li><code>hexo -v</code>：查看已安装的 Hexo 版本，查看是否安装成功</li></ul></li><li><p>建立 Blog 文件夹</p><ul><li><code>mkdir Blog</code>：创建 Blog 文件夹</li><li><code>cd blog</code>：进入 Blog 文件夹</li><li>之后要是出现问题，直接删除 Blog 文件夹从头开始重新做就行</li></ul></li><li><p>Windows 安装 Git</p><ul><li>访问 <a href="https://git-scm.com/">Git</a>，下载 Git 并安装</li><li>之后用 Git Bash 输命令或者继续用 cmd</li></ul></li><li><p>创建 Hexo</p><ul><li>macOS：<code>sudo hexo init</code>：用管理员权限初始化 Hexo</li><li>Windows：<code>hexo init</code>：初始化 Hexo</li></ul></li></ul><h3 id="Hexo-操作"><a href="#Hexo-操作" class="headerlink" title="Hexo 操作"></a>Hexo 操作</h3><ul><li><p>启动 Hexo（本地预览）</p><ul><li><code>hexo s</code> s: start 启动 Hexo</li><li>复制显示的网址用浏览器打开即可</li><li><code>Ctrl + C</code> <code>Y</code> 停止</li></ul></li><li><p>新建文章</p><ul><li><code>hexo n "title"</code> n: new 新建文章</li><li>在 <code>Blog\source\_posts\</code> 中找到新建的 .md 文件用 Typora 编辑</li></ul></li><li><p>生成 Hexo</p><ul><li><code>hexo clean</code>：清理 Hexo</li><li><code>hexo g</code>：生成 Hexo</li></ul></li><li><p>先生成，应用修改，后启动查看效果</p></li></ul><h3 id="将博客部署到远端（Github）"><a href="#将博客部署到远端（Github）" class="headerlink" title="将博客部署到远端（Github）"></a>将博客部署到远端（Github）</h3><ul><li><p>访问 <a href="https://github.com/">Github</a></p></li><li><p>注册/登录 账号</p></li><li><p>新建仓库</p><ul><li>点击右上角 <code>+</code></li><li>点击 <code>New repository</code></li><li>Repository name 填写：Username.github.io</li><li>点击 <code>create repository</code></li></ul></li><li><p><code>cnpm install --save hexo-deployer-git</code> ：在 Blog 目录下安装 Git 部署插件</p></li><li><p>自动安装 忽略 Warning</p></li><li><p>编辑 <code>Blog\_config.yml</code> 文件</p><ul><li><p>下拉找到 <code>\# Deployment</code></p><pre class="line-numbers language-none"><code class="language-none">deploy:  type: git  repo: https://github.com/Username/Username.github.io  branch: master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>如果 type 后有单引号’’，git 填在单引号里面</p><p>repo 填的是 Github Repo 的地址，复制过来就行</p></li><li><p>保存并退出</p></li></ul></li><li><p><code>hexo d</code> d: deploy 部署到远端</p><ul><li>第一次部署要求输入 Github 账号密码</li></ul></li><li><p>访问 Username.github.io 即可</p></li></ul><h3 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h3><ul><li><p><code>git clone 主题网址.git themes/主题名</code></p></li><li><p>编辑 <code>Blog\_config.yml</code> 文件</p><ul><li><p>下拉找到 <code>theme</code></p></li><li><p>修改为 <code>theme: 主题名</code></p></li><li><p>重新清理，生成，启动</p></li><li><p><code>hexo clean</code></p></li><li><p><code>hexo g</code></p></li><li><p><code>hexo s</code></p></li></ul></li></ul><h2 id="Hexo-个性化定制"><a href="#Hexo-个性化定制" class="headerlink" title="Hexo 个性化定制"></a>Hexo 个性化定制</h2>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2021/01/20/hello-world/"/>
      <url>2021/01/20/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
